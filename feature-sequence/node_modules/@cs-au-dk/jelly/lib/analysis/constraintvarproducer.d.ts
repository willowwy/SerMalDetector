import { Expression, Function, Identifier, JSXIdentifier, JSXMemberExpression, JSXNamespacedName, Node } from "@babel/types";
import { NodePath } from "@babel/traverse";
import { AccessorType, AncestorsVar, ArgumentsVar, ConstraintVar, FunctionReturnVar, IntermediateVar, NodeVar, ObjectPropertyVar, ObjectPropertyVarObj, ReadResultVar, ThisVar } from "./constraintvars";
import { ArrayToken } from "./tokens";
import { FilePath } from "../misc/util";
import { PackageInfo } from "./infos";
import { FragmentState, MergeRepresentativeVar, RepresentativeVar } from "./fragmentstate";
import Solver from "./solver";
export declare class ConstraintVarProducer<RVT extends RepresentativeVar | MergeRepresentativeVar = RepresentativeVar> {
    private readonly s;
    private readonly f;
    private readonly a;
    constructor(s: Solver, f: FragmentState<RVT>);
    expVar(exp: Expression | JSXIdentifier | JSXMemberExpression | JSXNamespacedName, path: NodePath): ConstraintVar | undefined;
    identVar(id: Identifier | JSXIdentifier, path: NodePath): ConstraintVar;
    objPropVar(obj: ObjectPropertyVarObj, prop: string, accessor?: AccessorType): ObjectPropertyVar;
    arrayUnknownVar(arr: ArrayToken): ObjectPropertyVar;
    arrayAllVar(arr: ArrayToken): ObjectPropertyVar;
    packagePropVar(pck: FilePath | PackageInfo, prop: string, accessor?: AccessorType): ObjectPropertyVar;
    returnVar(fun: Function): FunctionReturnVar;
    thisVar(fun: Function): ThisVar;
    argumentsVar(fun: Function): ArgumentsVar;
    intermediateVar(n: Node, label: string): IntermediateVar;
    nodeVar(n: Node): NodeVar;
    ancestorsVar(t: ObjectPropertyVarObj): AncestorsVar;
    readResultVar(t: ObjectPropertyVarObj, prop: string): ReadResultVar;
}
