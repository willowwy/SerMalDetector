"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.widenObjects = void 0;
const tokens_1 = require("./tokens");
const logger_1 = __importDefault(require("../misc/logger"));
const constraintvars_1 = require("./constraintvars");
const util_1 = require("../misc/util");
const timer_1 = __importDefault(require("../misc/timer"));
const accesspaths_1 = require("./accesspaths");
const assert_1 = __importDefault(require("assert"));
function widenObjects(widened, solver) {
    const a = solver.globalState;
    const f = solver.fragmentState;
    if (logger_1.default.isVerboseEnabled())
        logger_1.default.verbose(`Widening (constraint vars: ${f.getNumberOfVarsWithTokens()}, widened tokens: ${widened.size})`);
    if (logger_1.default.isDebugEnabled())
        for (const t of widened)
            logger_1.default.debug(`Widening ${t}`);
    if (widened.size === 0)
        return;
    (0, util_1.addAll)(widened, f.widened);
    const timer = new timer_1.default;
    const tokenMap = new Map;
    for (const t of widened)
        tokenMap.set(t, a.canonicalizeToken(new tokens_1.PackageObjectToken(t.getPackageInfo())));
    function widenToken(t) {
        return (t instanceof tokens_1.ObjectToken && tokenMap.get(t)) || t;
    }
    function widenTokenSet(ts) {
        const res = new Set;
        for (const t of ts)
            res.add(widenToken(t));
        return res;
    }
    function widenTokenMapArrayValues(m) {
        const res = new Map;
        let size = 0;
        for (const [v, ts] of m) {
            const s = widenTokenSet(ts);
            res.set(v, Array.from(s));
            size += s.size;
        }
        return [res, size];
    }
    function widenTokenMapMapKeys(m) {
        const res = new Map;
        for (const [t, m2] of m) {
            const rm = (0, util_1.mapGetMap)(res, widenToken(t));
            for (const [k, v] of m2)
                rm.set(k, v);
        }
        return res;
    }
    const varMap = new Map;
    function widenVar(v) {
        if (v instanceof constraintvars_1.ObjectPropertyVar && v.obj instanceof tokens_1.ObjectToken && widened.has(v.obj)) {
            const vobj = v.obj;
            return (0, util_1.getOrSet)(varMap, v, () => f.varProducer.packagePropVar(vobj.getPackageInfo(), v.prop, v.accessor));
        }
        else if (v instanceof constraintvars_1.AncestorsVar && v.t instanceof tokens_1.ObjectToken && widened.has(v.t))
            return (0, util_1.getOrSet)(varMap, v, () => f.varProducer.ancestorsVar(v.t));
        else if (v instanceof constraintvars_1.ReadResultVar && v.t instanceof tokens_1.ObjectToken && widened.has(v.t))
            return (0, util_1.getOrSet)(varMap, v, () => f.varProducer.readResultVar(v.t, v.prop));
        else
            return v;
    }
    function widenVarSet(s) {
        const res = new Set;
        for (const v of s)
            res.add(widenVar(v));
        return res;
    }
    function widenPropertyAccessPath(ap) {
        const w = widenVar(ap.base);
        if (w === ap.base)
            return ap;
        return a.canonicalizeAccessPath(new accesspaths_1.PropertyAccessPath(w, ap.prop));
    }
    function widenCallResultAccessPath(ap) {
        const w = widenVar(ap.caller);
        if (w === ap.caller)
            return ap;
        return a.canonicalizeAccessPath(new accesspaths_1.CallResultAccessPath(w));
    }
    function widenComponentAccessPath(ap) {
        const w = widenVar(ap.component);
        if (w === ap.component)
            return ap;
        return a.canonicalizeAccessPath(new accesspaths_1.ComponentAccessPath(w));
    }
    [solver.unprocessedTokens, solver.diagnostics.unprocessedTokensSize] = widenTokenMapArrayValues(solver.unprocessedTokens);
    (0, assert_1.default)(solver.nodesWithNewEdges.size === 0);
    solver.replaceTokens(tokenMap);
    for (const [_, ls] of f.tokenListeners)
        for (const [id, _] of ls) {
            const { t } = solver.listeners.get(id);
            if (t instanceof tokens_1.ObjectToken && widened.has(t)) {
                ls.delete(id);
            }
        }
    f.objectPropertiesListeners = widenTokenMapMapKeys(f.objectPropertiesListeners);
    for (const [t, pt] of tokenMap) {
        const props = f.objectProperties.get(t);
        if (props !== undefined) {
            f.objectProperties.delete(t);
            for (const prop of props)
                solver.addObjectProperty(pt, prop);
        }
    }
    for (const v of [...f.vars, ...f.redirections.keys()]) {
        const vRep = f.getRepresentative(v);
        const wRep = f.getRepresentative(widenVar(v));
        solver.addSubsetEdge(vRep, wRep);
        solver.redirect(vRep, wRep);
    }
    f.dynamicPropertyWrites = widenVarSet(f.dynamicPropertyWrites);
    for (const e of f.maybeEmptyPropertyReads) {
        if ("result" in e)
            e.result = widenVar(e.result);
        e.base = widenVar(e.base);
    }
    for (const e of f.maybeEmptyMethodCalls.values()) {
        e.baseVar = widenVar(e.baseVar);
        e.calleeVar = widenVar(e.calleeVar);
    }
    for (const e of f.unhandledDynamicPropertyWrites.values())
        e.src = widenVar(e.src);
    for (const m of [f.propertyReadAccessPaths, f.propertyWriteAccessPaths])
        for (const m1 of m.values())
            for (const m2 of m1.values())
                for (const e of m2.values()) {
                    e.sub = widenVar(e.sub);
                    e.bp = widenPropertyAccessPath(e.bp);
                }
    for (const m of f.callResultAccessPaths.values())
        for (const e of m.values()) {
            e.sub = widenVar(e.sub);
            e.bp = widenCallResultAccessPath(e.bp);
        }
    for (const m of f.componentAccessPaths.values())
        for (const e of m.values()) {
            e.sub = widenVar(e.sub);
            e.bp = widenComponentAccessPath(e.bp);
        }
    const ms = timer.elapsed();
    solver.diagnostics.totalWideningTime += ms;
    if (logger_1.default.isVerboseEnabled())
        logger_1.default.verbose(`Widening completed in ${ms}ms`);
}
exports.widenObjects = widenObjects;
//# sourceMappingURL=widening.js.map