import { ConstraintVar, ObjectPropertyVarObj } from "./constraintvars";
import { ArrayToken, ObjectToken, PackageObjectToken, Token } from "./tokens";
import { GlobalState } from "./globalstate";
import { FunctionInfo, ModuleInfo, PackageInfo } from "./infos";
import { AccessPath } from "./accesspaths";
import { Node } from "@babel/types";
import { FragmentState, ListenerID, RepresentativeVar } from "./fragmentstate";
import { TokenListener } from "./listeners";
import AnalysisDiagnostics from "./diagnostics";
import { ConstraintVarProducer } from "./constraintvarproducer";
export declare class AbortedException extends Error {
}
export type ListenerKey = {
    l: TokenListener;
    n?: Node;
    t?: Token;
    s?: string;
};
export default class Solver {
    readonly globalState: GlobalState;
    fragmentState: FragmentState;
    get varProducer(): ConstraintVarProducer;
    unprocessedTokens: Map<RepresentativeVar, Array<Token>>;
    nodesWithNewEdges: Set<ConstraintVar>;
    restored: Set<ConstraintVar>;
    readonly listeners: Map<ListenerID, ListenerKey>;
    diagnostics: AnalysisDiagnostics;
    readonly abort?: () => boolean;
    fixpointIterationsThrottled: number;
    constructor(abort?: () => boolean);
    updateDiagnostics(): void;
    addTokenConstraint(t: Token, to: ConstraintVar | undefined): void;
    private enqueueListenerCall;
    addToken(t: Token, toRep: RepresentativeVar): boolean;
    private addTokens;
    replaceTokens(m: Map<ObjectToken, PackageObjectToken>): void;
    private tokenAdded;
    addAccessPath(ap: AccessPath, to: ConstraintVar | undefined, subap?: AccessPath): void;
    private printDiagnostics;
    addSubsetConstraint(from: ConstraintVar | undefined, to: ConstraintVar | undefined): void;
    addSubsetEdge(fromRep: RepresentativeVar, toRep: RepresentativeVar, propagate?: boolean): void;
    private getNodeHash;
    private checkListenerIDCollision;
    private getListenerID;
    addForAllTokensConstraint(v: ConstraintVar | undefined, key: TokenListener, opts: Node | Omit<ListenerKey, "l">, listener: (t: Token) => void): void;
    private addForAllTokensConstraintPrivate;
    private callTokenListener;
    addForAllPackageNeighborsConstraint(k: PackageInfo, opts: Omit<ListenerKey, "l">, listener: (neighbor: PackageInfo) => void): void;
    private runPackageNeighborsListener;
    addPackageNeighbor(k1: PackageInfo, k2: PackageInfo, propagate?: boolean): void;
    private addPackageNeighborPrivate;
    addForAllAncestorsConstraint(t: ObjectPropertyVarObj, key: TokenListener.READ_ANCESTORS | TokenListener.ASSIGN_ANCESTORS | TokenListener.CALL_FUNCTION_ANCESTORS, opts: Omit<ListenerKey, "l" | "t">, listener: (ancestor: Token) => void): void;
    addInherits(child: ObjectPropertyVarObj, parent: Token | ConstraintVar): void;
    addForAllArrayEntriesConstraint(t: ArrayToken, key: TokenListener, n: Node, listener: (prop: string) => void): void;
    private runArrayEntriesListener;
    addArrayEntry(a: ArrayToken, prop: string, propagate?: boolean): void;
    addForAllObjectPropertiesConstraint(t: ObjectPropertyVarObj, key: TokenListener, n: Node, listener: (prop: string) => void): void;
    private runObjectPropertiesListener;
    addObjectProperty(a: ObjectPropertyVarObj, prop: string, propagate?: boolean): void;
    collectPropertyRead(typ: "read" | "call", result: ConstraintVar | undefined, base: ConstraintVar | undefined, pck: PackageObjectToken, prop: string | undefined, node: Node, enclosing: FunctionInfo | ModuleInfo): void;
    collectDynamicPropertyWrite(base: ConstraintVar | undefined): void;
    redirect(v: RepresentativeVar, rep: RepresentativeVar): void;
    processTokens(v: RepresentativeVar): void;
    incrementIterations(): void;
    propagate(): Promise<void>;
    checkAbort(throttle?: boolean): Promise<void>;
    prepare(): void;
    merge(_s: FragmentState, propagate: boolean): void;
}
