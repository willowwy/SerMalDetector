"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.analyzeFiles = void 0;
const fs_1 = __importStar(require("fs"));
const path_1 = require("path");
const logger_1 = __importStar(require("../misc/logger"));
const solver_1 = require("./solver");
const timer_1 = __importStar(require("../misc/timer"));
const util_1 = require("../misc/util");
const astvisitor_1 = require("./astvisitor");
const infos_1 = require("./infos");
const options_1 = require("../options");
const assert_1 = __importDefault(require("assert"));
const widening_1 = require("./widening");
const modulefinder_1 = require("./modulefinder");
const parser_1 = require("../parsing/parser");
const escaping_1 = require("./escaping");
const nativebuilder_1 = require("../natives/nativebuilder");
const analysisstatereporter_1 = require("../output/analysisstatereporter");
const operations_1 = require("./operations");
const extras_1 = require("../parsing/extras");
const patchdynamics_1 = require("../patching/patchdynamics");
const patchmethodcalls_1 = require("../patching/patchmethodcalls");
async function analyzeFiles(files, solver) {
    const a = solver.globalState;
    const d = solver.diagnostics;
    const timer = new timer_1.default();
    (0, options_1.resolveBaseDir)();
    const fragmentStates = new Map();
    function merge(mp, propagate = true) {
        const f = fragmentStates.get(mp);
        if (f) {
            if (logger_1.default.isDebugEnabled())
                logger_1.default.debug(`Merging state for ${mp}`);
            solver.merge(f, propagate);
        }
        else if (logger_1.default.isVerboseEnabled())
            logger_1.default.verbose(`No state found for ${mp}`);
    }
    try {
        if (files.length === 0)
            logger_1.default.info("Error: No files to analyze");
        else {
            for (const file of files)
                a.entryFiles.add((0, path_1.resolve)(options_1.options.basedir, file));
            for (const file of a.entryFiles)
                a.reachedFile(file);
            while (a.pendingFiles.length > 0) {
                const file = a.pendingFiles.shift();
                const moduleInfo = a.getModuleInfo(file);
                solver.prepare();
                d.modules++;
                if (!options_1.options.modulesOnly && options_1.options.printProgress)
                    logger_1.default.info(`Analyzing module ${file} (${d.modules})`);
                const str = fs_1.default.readFileSync(file, "utf8");
                (0, logger_1.writeStdOutIfActive)(`Parsing ${file} (${Math.ceil(str.length / 1024)}KB)...`);
                const ast = (0, parser_1.parseAndDesugar)(str, file, solver.fragmentState);
                if (!ast) {
                    a.filesWithParseErrors.push(file);
                    continue;
                }
                moduleInfo.node = ast.program;
                a.filesAnalyzed.push(file);
                d.codeSize += (0, fs_1.statSync)(file).size;
                if (options_1.options.modulesOnly) {
                    (0, modulefinder_1.findModules)(ast, file, solver.fragmentState, moduleInfo);
                }
                else {
                    const { globals, globalsHidden, moduleSpecialNatives, globalSpecialNatives } = (0, nativebuilder_1.buildNatives)(solver, moduleInfo);
                    a.globalSpecialNatives = globalSpecialNatives;
                    (0, extras_1.preprocessAst)(ast, file, moduleInfo, globals, globalsHidden);
                    (0, logger_1.writeStdOutIfActive)("Traversing AST...");
                    solver.fragmentState.maybeEscapingFromModule.clear();
                    (0, astvisitor_1.visit)(ast, new operations_1.Operations(file, solver, moduleSpecialNatives));
                    await solver.propagate();
                    const escaping = (0, escaping_1.findEscapingObjects)(moduleInfo, solver);
                    if (options_1.options.alloc && options_1.options.widening)
                        (0, widening_1.widenObjects)(escaping, solver);
                    await solver.propagate();
                    if (logger_1.default.isDebugEnabled())
                        logger_1.default.debug(`Shelving state for ${moduleInfo}`);
                    fragmentStates.set(moduleInfo, solver.fragmentState);
                    solver.updateDiagnostics();
                }
                ast.tokens = undefined;
            }
            if (!options_1.options.modulesOnly) {
                solver.prepare();
                for (const p of a.packageInfos.values()) {
                    await solver.checkAbort();
                    if (!Array.from(p.modules.values()).some(m => fragmentStates.has(m)))
                        continue;
                    d.packages++;
                    for (const m of p.modules.values())
                        merge(m);
                    for (const d of p.directDependencies)
                        solver.addPackageNeighbor(p, d);
                }
                if (options_1.options.printProgress)
                    logger_1.default.info("Analyzing combined modules");
                await solver.propagate();
                const p1 = (0, patchdynamics_1.patchDynamics)(solver);
                const p2 = (0, patchmethodcalls_1.patchMethodCalls)(solver);
                if (p1 || p2)
                    await solver.propagate();
                (0, assert_1.default)(a.pendingFiles.length === 0, "Unexpected module");
                solver.fragmentState.resolveGetterCalls();
                solver.updateDiagnostics();
            }
        }
        const f = solver.fragmentState;
        f.reportUnhandledDynamicPropertyWrites();
        f.reportUnhandledDynamicPropertyReads();
    }
    catch (ex) {
        solver.updateDiagnostics();
        if (ex instanceof timer_1.TimeoutException)
            d.timeout = true;
        else if (ex instanceof solver_1.AbortedException)
            d.aborted = true;
        else
            throw ex;
    }
    d.time = timer.elapsed();
    d.cpuTime = timer.elapsedCPU();
    d.errors = (0, util_1.getMapHybridSetSize)(solver.fragmentState.errors) + a.filesWithParseErrors.length;
    d.warnings = (0, util_1.getMapHybridSetSize)(solver.fragmentState.warnings) + (0, util_1.getMapHybridSetSize)(solver.fragmentState.warningsUnsupported);
    if (d.aborted)
        logger_1.default.warn("Received abort signal, analysis aborted");
    else if (d.timeout)
        logger_1.default.warn("Time limit reached, analysis aborted");
    if (!options_1.options.modulesOnly && files.length > 0) {
        const f = solver.fragmentState;
        const r = new analysisstatereporter_1.AnalysisStateReporter(f);
        d.callsWithUniqueCallee = r.getOneCalleeCalls();
        d.callsWithMultipleCallees = r.getMultipleCalleeCalls();
        d.totalCallSites = f.callLocations.size;
        d.callsWithNoCallee = r.getZeroCalleeCalls().size;
        d.nativeOnlyCalls = r.getZeroButNativeCalleeCalls();
        d.externalOnlyCalls = r.getZeroButExternalCalleeCalls();
        d.nativeOrExternalCalls = r.getZeroButNativeOrExternalCalleeCalls();
        d.functionsWithZeroCallers = r.getZeroCallerFunctions().size;
        d.reachableFunctions = Array.from(r.getReachableModulesAndFunctions(r.getEntryModules())).filter(r => r instanceof infos_1.FunctionInfo).length;
        if (logger_1.default.isInfoEnabled()) {
            logger_1.default.info(`Analyzed packages: ${d.packages}, modules: ${d.modules}, functions: ${a.functionInfos.size}, code size: ${Math.ceil(d.codeSize / 1024)}KB`);
            logger_1.default.info(`Call edges function->function: ${f.numberOfFunctionToFunctionEdges}, call->function: ${f.numberOfCallToFunctionEdges}`);
            const total = d.totalCallSites, zeroOne = d.callsWithNoCallee + d.callsWithUniqueCallee, nativeExternal = d.nativeOnlyCalls + d.externalOnlyCalls + d.nativeOrExternalCalls;
            if (total > 0)
                logger_1.default.info(`Calls with zero or one callee: ${zeroOne}/${total} (${(0, util_1.percent)(zeroOne / total)}), ` +
                    `multiple: ${d.callsWithMultipleCallees}/${total} (${(0, util_1.percent)(d.callsWithMultipleCallees / total)}), ` +
                    `native or external: ${nativeExternal}/${total} (${(0, util_1.percent)(nativeExternal / total)})`);
            logger_1.default.info(`Functions with zero callers: ${d.functionsWithZeroCallers}/${a.functionInfos.size}${a.functionInfos.size > 0 ? ` (${(0, util_1.percent)(d.functionsWithZeroCallers / a.functionInfos.size)})` : ""}, ` +
                `reachable functions: ${d.reachableFunctions}/${a.functionInfos.size}${a.functionInfos.size > 0 ? ` (${(0, util_1.percent)(d.reachableFunctions / a.functionInfos.size)})` : ""}`);
            logger_1.default.info(`Analysis time: ${d.time}ms, memory usage: ${d.maxMemoryUsage}MB${!options_1.options.gc ? " (without --gc)" : ""}`);
            logger_1.default.info(`Analysis errors: ${d.errors}, warnings: ${d.warnings}${(0, util_1.getMapHybridSetSize)(f.warningsUnsupported) > 0 && !options_1.options.warningsUnsupported ? " (show all with --warnings-unsupported)" : ""}`);
            if (options_1.options.diagnostics) {
                logger_1.default.info(`Iterations: ${d.iterations}, listener notification rounds: ${d.listenerNotificationRounds}`);
                if (options_1.options.maxRounds !== undefined)
                    logger_1.default.info(`Fixpoint round limit reached: ${d.roundLimitReached} time${d.roundLimitReached !== 1 ? "s" : ""}`);
                logger_1.default.info(`Constraint vars: ${f.getNumberOfVarsWithTokens()} (${f.vars.size}), tokens: ${f.numberOfTokens}, subset edges: ${f.numberOfSubsetEdges}, max tokens: ${f.getLargestTokenSetSize()}, max subset out: ${f.getLargestSubsetEdgeOutDegree()}, redirections: ${f.redirections.size}`);
                logger_1.default.info(`Listeners (notifications) token: ${(0, util_1.mapMapSize)(f.tokenListeners)} (${d.tokenListenerNotifications}), ` +
                    (options_1.options.readNeighbors ? `neighbor: ${(0, util_1.mapMapSize)(f.packageNeighborListeners)} (${d.packageNeighborListenerNotifications}), ` : "") +
                    `array: ${(0, util_1.mapMapSize)(f.arrayEntriesListeners)} (${d.arrayEntriesListenerNotifications}), ` +
                    `obj: ${(0, util_1.mapMapSize)(f.objectPropertiesListeners)} (${d.objectPropertiesListenerNotifications})`);
                logger_1.default.info(`Canonicalize vars: ${a.canonicalConstraintVars.size} (${a.numberOfCanonicalizeVarCalls}), tokens: ${a.canonicalTokens.size} (${a.numberOfCanonicalizeTokenCalls}), access paths: ${a.canonicalAccessPaths.size} (${a.numberOfCanonicalizeAccessPathCalls})`);
                logger_1.default.info(`CPU time: ${d.cpuTime}ms, propagation: ${d.totalPropagationTime}ms, listeners: ${d.totalListenerCallTime}ms` +
                    (options_1.options.alloc && options_1.options.widening ? `, widening: ${d.totalWideningTime}ms` : ""));
                if (options_1.options.cycleElimination)
                    logger_1.default.info(`Cycle elimination time: ${d.totalCycleEliminationTime}ms, runs: ${d.totalCycleEliminationRuns}, nodes removed: ${f.redirections.size}`);
            }
        }
    }
}
exports.analyzeFiles = analyzeFiles;
//# sourceMappingURL=analyzer.js.map