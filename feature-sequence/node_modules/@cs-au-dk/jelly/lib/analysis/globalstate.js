"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.GlobalState = void 0;
const util_1 = require("../misc/util");
const constraintvars_1 = require("./constraintvars");
const tokens_1 = require("./tokens");
const packagejson_1 = require("../misc/packagejson");
const accesspaths_1 = require("./accesspaths");
const timer_1 = __importDefault(require("../misc/timer"));
const infos_1 = require("./infos");
const assert_1 = __importDefault(require("assert"));
const path_1 = require("path");
const options_1 = require("../options");
const logger_1 = __importDefault(require("../misc/logger"));
const moduleresolver_1 = require("../typescript/moduleresolver");
class GlobalState {
    canonicalConstraintVars = new Map;
    canonicalAncestorVars = new Map;
    canonicalReturnVar = new Map;
    canonicalThisVar = new Map;
    canonicalNodeVars = new WeakMap;
    canonicalTokens = new Map;
    canonicalUnknownAccessPathToken;
    canonicalIgnoredAccessPathToken;
    canonicalNativeObjectTokens = new Map;
    canonicalAccessPaths = new Map;
    canonicalGlobals = new Map;
    packageInfos = new Map;
    moduleInfosByPath = new Map;
    moduleInfos = new Map;
    dummyModuleInfos = new Map;
    functionInfos = new Map;
    entryFiles = new Set;
    reachedFiles = new Set;
    pendingFiles = [];
    filesWithParseErrors = [];
    filesAnalyzed = [];
    timeoutTimer = new timer_1.default;
    packageJsonInfos = new Map();
    tsModuleResolver = new moduleresolver_1.TSModuleResolver();
    numberOfCanonicalizeVarCalls = 0;
    numberOfCanonicalizeTokenCalls = 0;
    numberOfCanonicalizeAccessPathCalls = 0;
    vulnerabilities;
    globalSpecialNatives;
    canonicalizeVar(v) {
        if (v instanceof constraintvars_1.NodeVar)
            return (0, util_1.getOrSet)(this.canonicalNodeVars, v.node, () => v);
        else if (v instanceof constraintvars_1.AncestorsVar)
            return (0, util_1.getOrSet)(this.canonicalAncestorVars, v.t, () => v);
        else if (v instanceof constraintvars_1.FunctionReturnVar)
            return (0, util_1.getOrSet)(this.canonicalReturnVar, v.fun, () => v);
        else if (v instanceof constraintvars_1.ThisVar)
            return (0, util_1.getOrSet)(this.canonicalThisVar, v.fun, () => v);
        this.numberOfCanonicalizeVarCalls++;
        return (0, util_1.getOrSet)(this.canonicalConstraintVars, v.toString(), () => v);
    }
    canonicalizeToken(t) {
        if (t instanceof tokens_1.AccessPathToken) {
            if (t.ap === accesspaths_1.UnknownAccessPath.instance) {
                if (!this.canonicalUnknownAccessPathToken) {
                    t.hash = (0, util_1.strHash)(t.toString());
                    this.canonicalUnknownAccessPathToken = t;
                }
                return this.canonicalUnknownAccessPathToken;
            }
            if (t.ap === accesspaths_1.IgnoredAccessPath.instance) {
                if (!this.canonicalIgnoredAccessPathToken) {
                    t.hash = (0, util_1.strHash)(t.toString());
                    this.canonicalIgnoredAccessPathToken = t;
                }
                return this.canonicalIgnoredAccessPathToken;
            }
        }
        else if (t instanceof tokens_1.NativeObjectToken && !t.moduleInfo)
            return (0, util_1.getOrSet)(this.canonicalNativeObjectTokens, t.name, () => {
                t.hash = (0, util_1.strHash)(t.toString());
                return t;
            });
        this.numberOfCanonicalizeTokenCalls++;
        const s = t.toString();
        return (0, util_1.getOrSet)(this.canonicalTokens, s, () => (t.hash = (0, util_1.strHash)(s), t));
    }
    canonicalizeAccessPath(t) {
        if (t === accesspaths_1.IgnoredAccessPath.instance || t === accesspaths_1.UnknownAccessPath.instance)
            return t;
        this.numberOfCanonicalizeAccessPathCalls++;
        return (0, util_1.getOrSet)(this.canonicalAccessPaths, t.toString(), () => t);
    }
    getModuleInfo(file) {
        const m = this.moduleInfosByPath.get(file);
        if (!m)
            assert_1.default.fail(`ModuleInfo for ${file} not found`);
        return m;
    }
    registerFunctionInfo(file, path, name, fun) {
        const m = this.moduleInfosByPath.get(file);
        const f = new infos_1.FunctionInfo(name, fun, m);
        this.functionInfos.set(fun, f);
        const parent = path.getFunctionParent()?.node;
        (parent ? this.functionInfos.get(parent).functions : m.functions).add(f);
        if (this.vulnerabilities)
            this.vulnerabilities.reachedFunction(path, f);
    }
    reachedFile(tofile, from) {
        let moduleInfo;
        if (this.reachedFiles.has(tofile))
            moduleInfo = this.moduleInfosByPath.get(tofile);
        else {
            const p = (0, util_1.getOrSet)(this.packageJsonInfos, (0, path_1.dirname)(tofile), () => (0, packagejson_1.getPackageJsonInfo)(tofile));
            const rel = (0, path_1.relative)(p.dir, tofile);
            let packageInfo = this.packageInfos.get(p.packagekey);
            let otherfile;
            if (!packageInfo) {
                packageInfo = new infos_1.PackageInfo(p.name, p.version, p.main, p.dir, from === undefined);
                this.packageInfos.set(p.packagekey, packageInfo);
                if (!options_1.options.modulesOnly && options_1.options.printProgress && logger_1.default.isVerboseEnabled())
                    logger_1.default.verbose(`Reached package ${packageInfo} at ${p.dir}`);
                if (this.vulnerabilities)
                    this.vulnerabilities.reachedPackage(packageInfo);
            }
            else {
                otherfile = (0, path_1.resolve)(packageInfo.dir, rel);
                moduleInfo = this.moduleInfosByPath.get(otherfile);
            }
            if (moduleInfo) {
                if (logger_1.default.isVerboseEnabled())
                    logger_1.default.verbose(`${moduleInfo} already encountered in another directory`);
            }
            else {
                const ignoreModule = from && (options_1.options.ignoreDependencies ||
                    (!packageInfo.isEntry && ((options_1.options.includePackages && !options_1.options.includePackages.includes(packageInfo.name))
                        || options_1.options.excludePackages?.includes(packageInfo.name))));
                moduleInfo = new infos_1.ModuleInfo(rel, packageInfo, from === undefined, !ignoreModule);
                packageInfo.modules.set(rel, moduleInfo);
                this.reachedFiles.add(tofile);
                if (ignoreModule)
                    logger_1.default.info(`Ignoring module ${moduleInfo}`);
                else
                    this.pendingFiles.push(tofile);
                if (this.vulnerabilities)
                    this.vulnerabilities.reachedModule(moduleInfo);
                if (otherfile)
                    this.moduleInfosByPath.set(otherfile, moduleInfo);
            }
            this.moduleInfosByPath.set(tofile, moduleInfo);
            this.moduleInfos.set(moduleInfo.toString(), moduleInfo);
        }
        if (from) {
            const pf = from.packageInfo;
            const pt = this.moduleInfosByPath.get(tofile).packageInfo;
            if (pf !== pt && !pf.directDependencies.has(pt)) {
                pf.directDependencies.add(pt);
                if (logger_1.default.isDebugEnabled())
                    logger_1.default.debug(`Package ${pf} depends on ${pt}`);
            }
        }
        return moduleInfo;
    }
    getEnclosingFunctionOrModule(path, moduleInfo) {
        const p = path.getFunctionParent()?.node;
        const caller = p ? this.functionInfos.get(p) : moduleInfo;
        if (!caller)
            assert_1.default.fail(`Function/module info not found at ${moduleInfo}:${(0, util_1.locationToString)(path.node.loc)}!?!`);
        return caller;
    }
    getConstraintVarParent(v) {
        const p = v.getParent();
        if (p && "loc" in p && p.loc)
            return p.loc.module;
        return undefined;
    }
}
exports.GlobalState = GlobalState;
//# sourceMappingURL=globalstate.js.map