"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.visit = exports.IDENTIFIER_KIND = void 0;
const traverse_1 = __importDefault(require("@babel/traverse"));
const types_1 = require("@babel/types");
const tokens_1 = require("./tokens");
const infos_1 = require("./infos");
const logger_1 = __importDefault(require("../misc/logger"));
const util_1 = require("../misc/util");
const assert_1 = __importDefault(require("assert"));
const options_1 = require("../options");
const accesspaths_1 = require("./accesspaths");
const constraintvars_1 = require("./constraintvars");
const asthelpers_1 = require("../misc/asthelpers");
const ecmascript_1 = require("../natives/ecmascript");
const listeners_1 = require("./listeners");
const extras_1 = require("../parsing/extras");
exports.IDENTIFIER_KIND = Symbol();
function visit(ast, op) {
    const solver = op.solver;
    const a = solver.globalState;
    const f = solver.fragmentState;
    const vp = f.varProducer;
    const class2constructor = new Map();
    if (logger_1.default.isVerboseEnabled())
        logger_1.default.verbose(`Traversing AST of ${op.file}`);
    (0, traverse_1.default)(ast, {
        ThisExpression(path) {
            f.registerThis(path);
            if (!options_1.options.oldobj) {
                const encl = path.findParent((p) => (0, types_1.isFunctionDeclaration)(p.node) || (0, types_1.isFunctionExpression)(p.node) || (0, types_1.isObjectMethod)(p.node) ||
                    (0, types_1.isClassMethod)(p.node) || (0, types_1.isClassPrivateMethod)(p.node) ||
                    (0, types_1.isStaticBlock)(p.node) || (0, types_1.isClassProperty)(p.node) || (0, types_1.isClassPrivateProperty)(p.node));
                if (encl) {
                    if ((0, types_1.isFunction)(encl.node)) {
                        solver.addSubsetConstraint(vp.thisVar(encl.node), vp.nodeVar(path.node));
                    }
                    else {
                        const cls = encl.parentPath?.parentPath?.node;
                        (0, assert_1.default)(cls);
                        const constr = class2constructor.get(cls);
                        (0, assert_1.default)(constr);
                        if ((0, types_1.isStaticBlock)(encl.node) || (((0, types_1.isClassProperty)(encl.node) || (0, types_1.isClassPrivateProperty)(encl.node)) && encl.node.static))
                            solver.addTokenConstraint(op.newFunctionToken(constr), vp.nodeVar(path.node));
                        else
                            solver.addSubsetConstraint(vp.thisVar(constr), vp.nodeVar(path.node));
                    }
                }
                else {
                    solver.addTokenConstraint(op.globalSpecialNatives.get("globalThis"), vp.nodeVar(path.node));
                }
            }
            else {
                solver.addTokenConstraint(op.packageObjectToken, vp.nodeVar(path.node));
                const fun = f.getEnclosingFunction(path);
                if (fun) {
                    solver.addSubsetConstraint(vp.thisVar(fun), vp.nodeVar(path.node));
                }
                else {
                    solver.addTokenConstraint(op.globalSpecialNatives.get("globalThis"), vp.nodeVar(path.node));
                }
            }
        },
        Super(path) {
            const encl = path.findParent((p) => (0, types_1.isObjectMethod)(p.node) || (0, types_1.isClassMethod)(p.node) || (0, types_1.isClassPrivateMethod)(p.node) ||
                (0, types_1.isStaticBlock)(p.node) || (0, types_1.isClassProperty)(p.node) || (0, types_1.isClassPrivateProperty)(p.node));
            (0, assert_1.default)(encl);
            let src;
            if ((0, types_1.isObjectMethod)(encl.node)) {
                src = op.newObjectToken(encl.parent);
            }
            else {
                const cls = (0, asthelpers_1.getClass)(path);
                (0, assert_1.default)(cls);
                const constr = class2constructor.get(cls);
                (0, assert_1.default)(constr);
                if ((0, types_1.isCallExpression)(path.parent) ||
                    (0, types_1.isStaticBlock)(encl.node) ||
                    (((0, types_1.isClassMethod)(encl.node) || (0, types_1.isClassPrivateMethod)(encl.node) || (0, types_1.isClassProperty)(encl.node) || (0, types_1.isClassPrivateProperty)(encl.node)) &&
                        encl.node.static)) {
                    src = op.newFunctionToken(constr);
                }
                else {
                    src = op.newPrototypeToken(constr);
                }
            }
            solver.addSubsetConstraint(vp.objPropVar(src, (0, ecmascript_1.INTERNAL_PROTOTYPE)()), vp.nodeVar(path.node));
        },
        Identifier(path) {
            if (path.node.name === "arguments")
                vp.identVar(path.node, path);
            if (options_1.options.variableKinds) {
                const binding = path.scope.getBinding(path.node.name);
                if (binding)
                    binding.identifier[exports.IDENTIFIER_KIND] = binding.kind;
            }
        },
        MemberExpression: {
            exit(path) {
                visitMemberExpression(path);
            }
        },
        OptionalMemberExpression: {
            exit(path) {
                visitMemberExpression(path);
            }
        },
        JSXMemberExpression: {
            exit(path) {
                visitMemberExpression(path);
            }
        },
        ReturnStatement: {
            exit(path) {
                if (path.node.argument) {
                    const fun = path.getFunctionParent();
                    if (fun) {
                        const expVar = op.expVar(path.node.argument, path);
                        let resVar;
                        if (fun.node.generator) {
                            const iter = a.canonicalizeToken(new tokens_1.AllocationSiteToken("Iterator", fun.node.body));
                            resVar = vp.objPropVar(iter, "value");
                        }
                        else {
                            resVar = vp.returnVar(fun.node);
                        }
                        if (fun.node.async && !fun.node.generator) {
                            const promise = op.newPromiseToken(fun.node);
                            solver.addSubsetConstraint(expVar, vp.objPropVar(promise, ecmascript_1.PROMISE_FULFILLED_VALUES));
                            solver.addTokenConstraint(promise, resVar);
                        }
                        else
                            solver.addSubsetConstraint(expVar, resVar);
                    }
                }
            }
        },
        Function: {
            enter(path) {
                const fun = path.node;
                let cls;
                if ((0, types_1.isClassMethod)(fun) && fun.kind === "constructor")
                    cls = (0, asthelpers_1.getClass)(path);
                const name = (0, types_1.isFunctionDeclaration)(path.node) || (0, types_1.isFunctionExpression)(path.node) ? path.node.id?.name :
                    ((0, types_1.isObjectMethod)(path.node) || (0, types_1.isClassMethod)(path.node)) ? (0, asthelpers_1.getKey)(path.node) :
                        cls ? cls.id?.name : undefined;
                const anon = (0, types_1.isFunctionDeclaration)(path.node) || (0, types_1.isFunctionExpression)(path.node) ? path.node.id === null : (0, types_1.isArrowFunctionExpression)(path.node);
                const msg = cls ? "constructor" : `${name ?? (anon ? "<anonymous>" : "<computed>")}`;
                if (logger_1.default.isVerboseEnabled())
                    logger_1.default.verbose(`Reached function ${msg} at ${(0, util_1.locationToStringWithFile)(fun.loc)}`);
                a.registerFunctionInfo(op.file, path, name, fun);
                if (!name && !anon)
                    f.warnUnsupported(fun, `Dynamic ${(0, types_1.isFunctionDeclaration)(path.node) || (0, types_1.isFunctionExpression)(path.node) ? "function" : "method"} name`);
                for (const param of fun.params) {
                    const paramVar = op.solver.varProducer.nodeVar(param);
                    if ((0, types_1.isIdentifier)(param))
                        f.registerFunctionParameter(paramVar, path.node);
                    else
                        op.assign(paramVar, param, path);
                }
                if (!options_1.options.oldobj) {
                    if ((0, types_1.isFunctionDeclaration)(path.node) || (0, types_1.isFunctionExpression)(path.node) || (0, types_1.isClassMethod)(path.node) || (0, types_1.isClassPrivateMethod)(path.node)) {
                        const pt = op.newPrototypeToken(path.node);
                        const ft = op.newFunctionToken(path.node);
                        solver.addTokenConstraint(pt, vp.objPropVar(ft, "prototype"));
                        solver.addTokenConstraint(ft, vp.objPropVar(pt, "constructor"));
                    }
                    if (cls && !((0, types_1.isClassDeclaration)(cls) && cls.abstract)) {
                        const obj = op.newObjectToken(fun);
                        const proto = op.newPrototypeToken(fun);
                        solver.addTokenConstraint(obj, vp.thisVar(fun));
                        solver.addInherits(obj, proto);
                    }
                }
                if (fun.generator) {
                    const iter = a.canonicalizeToken(new tokens_1.AllocationSiteToken("Iterator", fun.body));
                    const iterNext = vp.objPropVar(iter, "next");
                    solver.addTokenConstraint(op.globalSpecialNatives.get(fun.async ? ecmascript_1.ASYNC_GENERATOR_PROTOTYPE_NEXT : ecmascript_1.GENERATOR_PROTOTYPE_NEXT), iterNext);
                    solver.addTokenConstraint(iter, vp.returnVar(fun));
                }
            },
            exit(path) {
                const fun = path.node;
                if (f.functionsWithArguments.has(fun)) {
                    const argumentsToken = a.canonicalizeToken(new tokens_1.ArrayToken(fun.body));
                    solver.addTokenConstraint(argumentsToken, vp.argumentsVar(fun));
                }
            }
        },
        FunctionDeclaration: {
            exit(path) {
                const to = path.node.id ? path.node.id : path.node;
                solver.addTokenConstraint(op.newFunctionToken(path.node), vp.nodeVar(to));
            }
        },
        FunctionExpression: {
            exit(path) {
                if (!(0, asthelpers_1.isParentExpressionStatement)(path))
                    solver.addTokenConstraint(op.newFunctionToken(path.node), vp.nodeVar(path.node));
                if (path.node.id)
                    solver.addTokenConstraint(op.newFunctionToken(path.node), vp.nodeVar(path.node.id));
            }
        },
        ArrowFunctionExpression: {
            exit(path) {
                if (!(0, asthelpers_1.isParentExpressionStatement)(path))
                    solver.addTokenConstraint(op.newFunctionToken(path.node), vp.nodeVar(path.node));
                if ((0, types_1.isExpression)(path.node.body))
                    solver.addSubsetConstraint(op.expVar(path.node.body, path), vp.returnVar(path.node));
            }
        },
        CallExpression: {
            exit(path) {
                op.callFunction(path);
            }
        },
        OptionalCallExpression: {
            exit(path) {
                op.callFunction(path);
            }
        },
        NewExpression: {
            exit(path) {
                op.callFunction(path);
            }
        },
        AssignmentExpression: {
            exit(path) {
                const oper = path.node.operator;
                if (oper === '=' || oper === '||=' || oper === '&&=' || oper === '??=') {
                    const eVar = op.expVar(path.node.right, path);
                    op.assign(eVar, path.node.left, path);
                    if (!(0, asthelpers_1.isParentExpressionStatement)(path))
                        solver.addSubsetConstraint(eVar, vp.nodeVar(path.node));
                }
            }
        },
        AssignmentPattern: {
            exit(path) {
                op.assign(op.expVar(path.node.right, path), path.node.left, path);
            }
        },
        VariableDeclarator: {
            exit(path) {
                if (path.node.init) {
                    op.assign(op.expVar(path.node.init, path), path.node.id, path);
                }
            }
        },
        ConditionalExpression: {
            exit(path) {
                if (!(0, asthelpers_1.isParentExpressionStatement)(path)) {
                    solver.addSubsetConstraint(op.expVar(path.node.consequent, path), vp.nodeVar(path.node));
                    solver.addSubsetConstraint(op.expVar(path.node.alternate, path), vp.nodeVar(path.node));
                }
            }
        },
        LogicalExpression: {
            exit(path) {
                if (!(0, asthelpers_1.isParentExpressionStatement)(path)) {
                    if (path.node.operator !== "&&")
                        solver.addSubsetConstraint(op.expVar(path.node.left, path), vp.nodeVar(path.node));
                    solver.addSubsetConstraint(op.expVar(path.node.right, path), vp.nodeVar(path.node));
                }
            }
        },
        SequenceExpression: {
            exit(path) {
                if (!(0, asthelpers_1.isParentExpressionStatement)(path))
                    solver.addSubsetConstraint(op.expVar(path.node.expressions[path.node.expressions.length - 1], path), vp.nodeVar(path.node));
            }
        },
        Property: {
            exit(path) {
                if ((0, types_1.isPattern)(path.parent))
                    return;
                if ((0, types_1.isClassAccessorProperty)(path.node))
                    assert_1.default.fail(`Encountered ClassAccessorProperty at ${(0, util_1.locationToStringWithFile)(path.node.loc)}`);
                const key = (0, asthelpers_1.getKey)(path.node);
                if (key) {
                    if (path.node.value) {
                        if (!(0, types_1.isExpression)(path.node.value))
                            assert_1.default.fail(`Unexpected Property value type ${path.node.value?.type} at ${(0, util_1.locationToStringWithFile)(path.node.loc)}`);
                        if (!options_1.options.oldobj) {
                            const rightvar = op.expVar(path.node.value, path);
                            if (rightvar)
                                if ((0, types_1.isObjectProperty)(path.node)) {
                                    const dst = vp.objPropVar(op.newObjectToken(path.parentPath.node), key);
                                    solver.addSubsetConstraint(rightvar, dst);
                                }
                                else {
                                    const cls = (0, asthelpers_1.getClass)(path);
                                    (0, assert_1.default)(cls);
                                    const constr = class2constructor.get(cls);
                                    (0, assert_1.default)(constr);
                                    if (path.node.static) {
                                        const t = op.newFunctionToken(constr);
                                        const dst = vp.objPropVar(t, key);
                                        solver.addSubsetConstraint(rightvar, dst);
                                    }
                                    else {
                                        solver.addForAllTokensConstraint(vp.thisVar(constr), listeners_1.TokenListener.CLASS_FIELD, path.node, (t) => {
                                            if ((0, constraintvars_1.isObjectPropertyVarObj)(t)) {
                                                const dst = vp.objPropVar(t, key);
                                                solver.addSubsetConstraint(rightvar, dst);
                                            }
                                        });
                                    }
                                }
                        }
                        else {
                            const rightvar = op.expVar(path.node.value, path);
                            let dst;
                            if (options_1.options.alloc && (0, types_1.isObjectProperty)(path.node)) {
                                dst = vp.objPropVar(a.canonicalizeToken(new tokens_1.ObjectToken(path.parentPath.node)), key);
                            }
                            else if (options_1.options.alloc && ((0, types_1.isClassProperty)(path.node) || (0, types_1.isClassAccessorProperty)(path.node) || (0, types_1.isClassPrivateProperty)(path.node)) && path.node.static) {
                                const cls = (0, asthelpers_1.getClass)(path);
                                (0, assert_1.default)(cls);
                                dst = vp.objPropVar(a.canonicalizeToken(new tokens_1.ClassToken(cls)), key);
                            }
                            else {
                                dst = vp.packagePropVar(op.file, key);
                            }
                            solver.addSubsetConstraint(rightvar, dst);
                        }
                    }
                }
                else
                    f.warnUnsupported(path.node, "Dynamic property name");
                (0, asthelpers_1.registerArtificialClassPropertyInitializer)(f, path);
            },
        },
        Method: {
            exit(path) {
                switch (path.node.kind) {
                    case "method":
                    case "get":
                    case "set":
                        const key = (0, asthelpers_1.getKey)(path.node);
                        if (key) {
                            if (!options_1.options.oldobj) {
                                const t = op.newFunctionToken(path.node);
                                const ac = path.node.kind === "method" ? "normal" : path.node.kind;
                                if ((0, types_1.isObjectMethod)(path.node)) {
                                    const it = op.newObjectToken(path.parentPath.node);
                                    const dst = vp.objPropVar(it, key, ac);
                                    solver.addTokenConstraint(t, dst);
                                    solver.addTokenConstraint(it, vp.thisVar(path.node));
                                }
                                else {
                                    const cls = (0, asthelpers_1.getClass)(path);
                                    (0, assert_1.default)(cls);
                                    const constr = class2constructor.get(cls);
                                    (0, assert_1.default)(constr);
                                    if (path.node.static) {
                                        const ct = op.newFunctionToken(constr);
                                        const dst = vp.objPropVar(ct, key, ac);
                                        solver.addTokenConstraint(t, dst);
                                    }
                                    else {
                                        const pt = op.newPrototypeToken(constr);
                                        const dst = vp.objPropVar(pt, key, ac);
                                        solver.addTokenConstraint(t, dst);
                                        solver.addSubsetConstraint(vp.thisVar(constr), vp.thisVar(path.node));
                                    }
                                }
                            }
                            else {
                                const t = op.newFunctionToken(path.node);
                                const ac = path.node.kind === "method" ? "normal" : path.node.kind;
                                let dst;
                                if (options_1.options.alloc && (0, types_1.isObjectMethod)(path.node)) {
                                    dst = vp.objPropVar(a.canonicalizeToken(new tokens_1.ObjectToken(path.parentPath.node)), key, ac);
                                }
                                else if (options_1.options.alloc && ((0, types_1.isClassMethod)(path.node) || (0, types_1.isClassPrivateMethod)(path.node)) && path.node.static) {
                                    const cls = (0, asthelpers_1.getClass)(path);
                                    (0, assert_1.default)(cls);
                                    dst = vp.objPropVar(a.canonicalizeToken(new tokens_1.ClassToken(cls)), key, ac);
                                }
                                else {
                                    dst = vp.packagePropVar(op.file, key, ac);
                                }
                                solver.addTokenConstraint(t, dst);
                            }
                        }
                        else
                            f.warnUnsupported(path.node, "Dynamic method name");
                        break;
                    case "constructor":
                        const cls = (0, asthelpers_1.getClass)(path);
                        if (cls && cls.id)
                            solver.addTokenConstraint(op.newFunctionToken(path.node), vp.nodeVar(cls.id));
                        break;
                }
            }
        },
        Class(path) {
            let constructor;
            for (const b of path.node.body.body)
                if ((0, types_1.isClassMethod)(b) && b.kind === "constructor") {
                    constructor = b;
                    break;
                }
            (0, assert_1.default)(constructor);
            class2constructor.set(path.node, constructor);
            const exported = (0, types_1.isExportDeclaration)(path.parent);
            if (!options_1.options.oldobj) {
                const ct = op.newFunctionToken(constructor);
                if ((0, types_1.isClassExpression)(path.node) || exported) {
                    if (!(0, asthelpers_1.isParentExpressionStatement)(path) || exported)
                        solver.addTokenConstraint(ct, vp.nodeVar(path.node));
                }
                if (path.node.id)
                    solver.addTokenConstraint(ct, vp.nodeVar(path.node.id));
                if (path.node.superClass) {
                    const eVar = op.expVar(path.node.superClass, path);
                    solver.addForAllTokensConstraint(eVar, listeners_1.TokenListener.EXTENDS, path.node, (w) => {
                        solver.addInherits(ct, w);
                        if (w instanceof tokens_1.FunctionToken || w instanceof tokens_1.AccessPathToken) {
                            const pt = op.newPrototypeToken(constructor);
                            if (w instanceof tokens_1.FunctionToken) {
                                solver.addInherits(pt, solver.varProducer.objPropVar(w, "prototype"));
                                solver.addSubsetConstraint(solver.varProducer.thisVar(constructor), solver.varProducer.thisVar(w.fun));
                                solver.addSubsetConstraint(solver.varProducer.returnVar(w.fun), solver.varProducer.returnVar(ct.fun));
                            }
                            else {
                                const p = a.canonicalizeToken(new tokens_1.AccessPathToken(a.canonicalizeAccessPath(new accesspaths_1.PropertyAccessPath(eVar, "prototype"))));
                                solver.addInherits(pt, p);
                            }
                        }
                    });
                }
            }
            else {
                if (constructor) {
                    if ((0, types_1.isClassExpression)(path.node) || exported) {
                        if (!(0, asthelpers_1.isParentExpressionStatement)(path) || exported)
                            solver.addTokenConstraint(op.newFunctionToken(constructor), vp.nodeVar(path.node));
                    }
                }
                else
                    f.registerArtificialFunction(op.moduleInfo, path.node.loc);
                const ct = op.newClassToken(path.node);
                if ((0, types_1.isClassExpression)(path.node) || exported)
                    solver.addTokenConstraint(ct, vp.nodeVar(path.node));
                if (path.node.id)
                    solver.addTokenConstraint(ct, vp.nodeVar(path.node.id));
            }
        },
        ObjectExpression(path) {
            if (!(0, asthelpers_1.isParentExpressionStatement)(path)) {
                const ot = op.newObjectToken(path.node);
                solver.addTokenConstraint(ot, vp.nodeVar(path.node));
                for (const p of path.node.properties)
                    if ((0, types_1.isSpreadElement)(p)) {
                        if (options_1.options.objSpread) {
                            const enclosing = a.getEnclosingFunctionOrModule(path, op.moduleInfo);
                            solver.addForAllTokensConstraint(vp.expVar(p.argument, path), listeners_1.TokenListener.OBJECT_SPREAD, p, (t) => {
                                if ((0, constraintvars_1.isObjectPropertyVarObj)(t))
                                    solver.addForAllObjectPropertiesConstraint(t, listeners_1.TokenListener.OBJECT_SPREAD, p, (prop) => op.readPropertyBound(t, prop, vp.objPropVar(ot, prop), { n: p, s: prop }, enclosing));
                            });
                        }
                        else
                            f.warnUnsupported(p, "SpreadElement in ObjectExpression (use --obj-spread)");
                    }
            }
        },
        ArrayExpression(path) {
            if (!(0, asthelpers_1.isParentExpressionStatement)(path)) {
                const t = op.newArrayToken(path.node);
                solver.addTokenConstraint(t, vp.nodeVar(path.node));
                let indexKnown = true;
                for (const [index, e] of path.node.elements.entries())
                    if ((0, types_1.isExpression)(e)) {
                        const prop = indexKnown ? String(index) : ecmascript_1.ARRAY_UNKNOWN;
                        solver.addSubsetConstraint(op.expVar(e, path), vp.objPropVar(t, prop));
                    }
                    else if ((0, types_1.isSpreadElement)(e)) {
                        indexKnown = false;
                        op.readIteratorValue(op.expVar(e.argument, path), vp.arrayUnknownVar(t), path.node);
                    }
                    else
                        e;
            }
        },
        StaticBlock(path) {
            f.registerArtificialFunction(op.moduleInfo, path.node.loc);
        },
        ThrowStatement: {
            exit(path) {
                f.registerEscapingFromModule(op.expVar(path.node.argument, path));
            }
        },
        CatchClause: {},
        ImportDeclaration(path) {
            op.requireModule(path.node.source.value, vp.nodeVar(path.node), path);
            let any = false;
            for (const imp of path.node.specifiers) {
                switch (imp.type) {
                    case "ImportNamespaceSpecifier":
                        solver.addSubsetConstraint(vp.nodeVar(path.node), vp.nodeVar(imp.local));
                        break;
                    case "ImportSpecifier":
                    case "ImportDefaultSpecifier":
                        any = true;
                        break;
                }
                const refs = path.scope.getBinding(imp.local.name)?.referencePaths;
                if (refs)
                    for (const ref of refs)
                        if (ref.node[extras_1.JELLY_NODE_ID])
                            (0, util_1.mapArrayAdd)(imp.local, ref.node, f.importDeclRefs);
            }
            if (any) {
                solver.addForAllTokensConstraint(vp.nodeVar(path.node), listeners_1.TokenListener.IMPORT_BASE, path.node, (t) => {
                    for (const imp of path.node.specifiers)
                        if ((0, types_1.isImportSpecifier)(imp) || (0, types_1.isImportDefaultSpecifier)(imp)) {
                            const prop = (0, asthelpers_1.getImportName)(imp);
                            const dst = solver.varProducer.nodeVar(imp.local);
                            if (t instanceof tokens_1.AllocationSiteToken || t instanceof tokens_1.FunctionToken || t instanceof tokens_1.NativeObjectToken || t instanceof tokens_1.PackageObjectToken)
                                solver.addSubsetConstraint(solver.varProducer.objPropVar(t, prop), dst);
                            else if (t instanceof tokens_1.AccessPathToken)
                                solver.addAccessPath(new accesspaths_1.PropertyAccessPath(solver.varProducer.nodeVar(path.node), prop), dst, t.ap);
                        }
                });
            }
        },
        ExportDeclaration(path) {
            switch (path.node.type) {
                case "ExportNamedDeclaration":
                case "ExportDefaultDeclaration":
                    if (path.node.declaration) {
                        (0, assert_1.default)(!(0, types_1.isExportNamedDeclaration)(path.node) || path.node.specifiers.length === 0, "Unexpected specifiers at ExportNamedDeclaration with declaration");
                        (0, assert_1.default)(!(0, types_1.isExportNamedDeclaration)(path.node) || !path.node.source, "Unexpected source at ExportNamedDeclaration with declaration");
                        const decl = path.node.declaration;
                        switch (decl.type) {
                            case "FunctionDeclaration":
                            case "ClassDeclaration": {
                                const from = decl.id ? decl.id : decl;
                                (0, assert_1.default)((0, types_1.isExportDefaultDeclaration)(path.node) || decl.id, "Unexpected missing id");
                                const prop = (0, types_1.isExportDefaultDeclaration)(path.node) ? "default" : decl.id.name;
                                solver.addSubsetConstraint(vp.nodeVar(from), vp.objPropVar(op.exportsObjectToken, prop));
                                break;
                            }
                            case "VariableDeclaration": {
                                function exportDeclared(lval) {
                                    if ((0, types_1.isIdentifier)(lval))
                                        solver.addSubsetConstraint(vp.nodeVar(lval), vp.objPropVar(op.exportsObjectToken, lval.name));
                                    else if ((0, types_1.isAssignmentPattern)(lval))
                                        exportDeclared(lval.left);
                                    else if ((0, types_1.isObjectPattern)(lval)) {
                                        for (const p of lval.properties)
                                            if ((0, types_1.isRestElement)(p))
                                                exportDeclared(p.argument);
                                            else {
                                                if (!(0, types_1.isLVal)(p.value))
                                                    assert_1.default.fail(`Unexpected expression ${p.value.type}, expected LVal`);
                                                exportDeclared(p.value);
                                            }
                                    }
                                    else if ((0, types_1.isArrayPattern)(lval)) {
                                        for (const p of lval.elements)
                                            if (p)
                                                if ((0, types_1.isRestElement)(p))
                                                    exportDeclared(p.argument);
                                                else
                                                    exportDeclared(p);
                                    }
                                    else
                                        assert_1.default.fail(`Unexpected LVal type ${lval.type}`);
                                }
                                for (const decl2 of decl.declarations)
                                    exportDeclared(decl2.id);
                                break;
                            }
                            default: {
                                if ((0, types_1.isDeclaration)(decl))
                                    assert_1.default.fail(`Unexpected declaration type ${decl.type} in ExportDeclaration`);
                                if ((0, types_1.isExpression)(decl))
                                    solver.addSubsetConstraint(op.expVar(decl, path), vp.objPropVar(op.exportsObjectToken, "default"));
                                break;
                            }
                        }
                    }
                    else {
                        if (!(0, types_1.isExportNamedDeclaration)(path.node))
                            assert_1.default.fail(`Unexpected node type ${path.node.type}`);
                        const node = path.node;
                        function getExportVar(name) {
                            const m = node.source ? op.requireModule(node.source.value, vp.nodeVar(node), path) : undefined;
                            return m instanceof infos_1.ModuleInfo ? vp.objPropVar(a.canonicalizeToken(new tokens_1.NativeObjectToken("exports", m)), name) : undefined;
                        }
                        for (const spec of path.node.specifiers)
                            switch (spec.type) {
                                case "ExportSpecifier":
                                case "ExportDefaultSpecifier":
                                    const from = (0, types_1.isExportDefaultSpecifier)(spec) ? getExportVar("default") : node.source ? getExportVar(spec.local.name) : vp.identVar(spec.local, path);
                                    solver.addSubsetConstraint(from, vp.objPropVar(op.exportsObjectToken, (0, asthelpers_1.getExportName)(spec.exported)));
                                    break;
                                case "ExportNamespaceSpecifier":
                                    f.warnUnsupported(spec);
                                    break;
                            }
                    }
                    break;
                case "ExportAllDeclaration":
                    const m = op.requireModule(path.node.source.value, vp.nodeVar(path.node), path);
                    if (m instanceof infos_1.ModuleInfo) {
                        const t = a.canonicalizeToken(new tokens_1.NativeObjectToken("exports", m));
                        solver.addForAllObjectPropertiesConstraint(t, listeners_1.TokenListener.EXPORT_BASE, path.node, (prop) => solver.addSubsetConstraint(solver.varProducer.objPropVar(t, prop), solver.varProducer.objPropVar(op.exportsObjectToken, prop)));
                    }
                    break;
            }
        },
        ForOfStatement(path) {
            op.readIteratorValue(op.expVar(path.node.right, path), vp.nodeVar(path.node), path.node);
            const lval = (0, types_1.isVariableDeclaration)(path.node.left) ? path.node.left.declarations.length === 1 ? path.node.left.declarations[0]?.id : undefined : path.node.left;
            (0, assert_1.default)(lval, "Unexpected number of declarations at for-of");
            op.assign(vp.nodeVar(path.node), lval, path);
        },
        YieldExpression(path) {
            const fun = path.getFunctionParent()?.node;
            (0, assert_1.default)(fun, "yield not in function?!");
            const iter = a.canonicalizeToken(new tokens_1.AllocationSiteToken("Iterator", fun.body));
            const iterValue = vp.objPropVar(iter, "value");
            if (path.node.argument) {
                if (path.node.delegate) {
                    op.readIteratorValue(op.expVar(path.node.argument, path), iterValue, fun.body);
                }
                else {
                    solver.addSubsetConstraint(op.expVar(path.node.argument, path), iterValue);
                }
            }
            if (!(0, asthelpers_1.isParentExpressionStatement)(path))
                solver.addSubsetConstraint(iterValue, vp.nodeVar(path.node));
        },
        AwaitExpression(path) {
            op.awaitPromise(op.expVar(path.node.argument, path), op.expVar(path.node, path), path.node);
        },
        TaggedTemplateExpression(_path) {
            assert_1.default.fail("TaggedTemplateExpression should be handled by @babel/plugin-transform-template-literals");
        },
        RegExpLiteral(path) {
            solver.addTokenConstraint(op.newRegExpToken(), vp.nodeVar(path.node));
        },
        WithStatement(path) {
            f.warnUnsupported(path.node);
        },
        JSXElement(path) {
            const componentVar = op.expVar(path.node.openingElement.name, path);
            if (componentVar)
                solver.addForAllTokensConstraint(componentVar, listeners_1.TokenListener.JSX_ELEMENT, path.node, (t) => {
                    if (t instanceof tokens_1.AccessPathToken)
                        solver.addAccessPath(new accesspaths_1.ComponentAccessPath(componentVar), solver.varProducer.nodeVar(path.node), t.ap);
                });
        }
    });
    function visitMemberExpression(path) {
        if ((0, types_1.isAssignmentExpression)(path.parent) && path.parent.left === path.node)
            return;
        if ((0, asthelpers_1.isCalleeExpression)(path))
            return;
        op.readProperty(op.expVar(path.node.object, path), (0, asthelpers_1.getProperty)(path.node), (0, asthelpers_1.isParentExpressionStatement)(path) ? undefined : vp.nodeVar(path.node), path.node, a.getEnclosingFunctionOrModule(path, op.moduleInfo));
    }
}
exports.visit = visit;
//# sourceMappingURL=astvisitor.js.map