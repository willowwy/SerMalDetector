"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AccessPathToken = exports.PackageObjectToken = exports.NativeObjectToken = exports.ClassToken = exports.ArrayToken = exports.PrototypeToken = exports.ObjectToken = exports.AllocationSiteToken = exports.FunctionToken = exports.Token = void 0;
const util_1 = require("../misc/util");
const assert_1 = __importDefault(require("assert"));
class Token {
    hash;
}
exports.Token = Token;
class FunctionToken extends Token {
    fun;
    constructor(fun) {
        super();
        this.fun = fun;
    }
    toString() {
        return `Function[${(0, util_1.locationToStringWithFileAndEnd)(this.fun.loc, true)}]`;
    }
}
exports.FunctionToken = FunctionToken;
class AllocationSiteToken extends Token {
    kind;
    allocSite;
    constructor(kind, allocSite) {
        super();
        this.kind = kind;
        this.allocSite = allocSite;
        (0, assert_1.default)(this instanceof ArrayToken || kind !== "Array", "AllocationSiteTokens of kind Array must be created using ArrayToken");
        (0, assert_1.default)(this instanceof ObjectToken || kind !== "Object", "AllocationSiteTokens of kind Object must be created using ObjectToken");
        (0, assert_1.default)(this instanceof PrototypeToken || kind !== "Prototype", "AllocationSiteTokens of kind Prototype must be created using PrototypeToken");
    }
    toString() {
        return `${this.kind}[${(0, util_1.locationToStringWithFileAndEnd)(this.allocSite.loc, true)}]`;
    }
}
exports.AllocationSiteToken = AllocationSiteToken;
class ObjectToken extends AllocationSiteToken {
    constructor(allocSite) {
        super("Object", allocSite);
    }
    getPackageInfo() {
        const loc = this.allocSite.loc;
        (0, assert_1.default)(loc && loc.module);
        return loc.module.packageInfo;
    }
}
exports.ObjectToken = ObjectToken;
class PrototypeToken extends AllocationSiteToken {
    constructor(allocSite) {
        super("Prototype", allocSite);
    }
}
exports.PrototypeToken = PrototypeToken;
class ArrayToken extends AllocationSiteToken {
    constructor(allocSite) {
        super("Array", allocSite);
    }
}
exports.ArrayToken = ArrayToken;
class ClassToken extends AllocationSiteToken {
    constructor(allocSite) {
        super("Class", allocSite);
    }
}
exports.ClassToken = ClassToken;
class NativeObjectToken extends Token {
    name;
    moduleInfo;
    invoke;
    constr;
    constructor(name, moduleInfo, invoke, constr = false) {
        super();
        this.name = name;
        this.moduleInfo = moduleInfo;
        this.invoke = invoke;
        this.constr = constr;
    }
    toString() {
        return `%${this.name}${this.moduleInfo ? `[${this.moduleInfo}]` : ""}`;
    }
}
exports.NativeObjectToken = NativeObjectToken;
class PackageObjectToken extends Token {
    packageInfo;
    kind;
    constructor(packageInfo, kind = "Object") {
        super();
        this.packageInfo = packageInfo;
        this.kind = kind;
    }
    toString() {
        return `*${this.kind === "Object" ? "" : `(${this.kind})`}[${this.packageInfo}]`;
    }
}
exports.PackageObjectToken = PackageObjectToken;
class AccessPathToken extends Token {
    ap;
    constructor(ap) {
        super();
        this.ap = ap;
    }
    toString() {
        return `@${this.ap}`;
    }
}
exports.AccessPathToken = AccessPathToken;
//# sourceMappingURL=tokens.js.map