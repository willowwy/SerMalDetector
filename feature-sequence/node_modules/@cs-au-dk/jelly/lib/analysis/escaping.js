"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.findEscapingObjects = void 0;
const tokens_1 = require("./tokens");
const logger_1 = __importDefault(require("../misc/logger"));
const types_1 = require("@babel/types");
const accesspaths_1 = require("./accesspaths");
const ecmascript_1 = require("../natives/ecmascript");
const options_1 = require("../options");
const packagejson_1 = require("../misc/packagejson");
function findEscapingObjects(m, solver) {
    const a = solver.globalState;
    const f = solver.fragmentState;
    const worklist = [];
    const visited = new Set();
    const escaping = new Set();
    const theUnknownAccessPathToken = a.canonicalizeToken(new tokens_1.AccessPathToken(accesspaths_1.UnknownAccessPath.instance));
    function addToWorklist(v) {
        for (const t of v instanceof tokens_1.Token ? [v] : f.getTokens(f.getRepresentative(v)))
            if ((t instanceof tokens_1.AllocationSiteToken || t instanceof tokens_1.FunctionToken || (t instanceof tokens_1.NativeObjectToken && t.name === "exports")) && !visited.has(t)) {
                worklist.push(t);
                visited.add(t);
            }
    }
    let isModuleExporting = true;
    if (!m.getPath().includes("node_modules") && !options_1.options.assumeInNodeModules)
        isModuleExporting = false;
    else {
        const pi = a.packageJsonInfos.get(m.packageInfo.dir);
        if (pi?.exports && !(0, packagejson_1.isInExports)(`./${m.relativePath}`, pi.exports))
            isModuleExporting = false;
    }
    if (isModuleExporting) {
        addToWorklist(f.varProducer.objPropVar(a.canonicalizeToken(new tokens_1.NativeObjectToken("module", m)), "exports"));
        const w2 = [];
        while (worklist.length !== 0) {
            const t = worklist.shift();
            if (t instanceof tokens_1.FunctionToken)
                w2.push(t);
            else if (t instanceof tokens_1.ObjectToken || (t instanceof tokens_1.NativeObjectToken && t.name === "exports"))
                for (const p of f.objectProperties.get(t) ?? [])
                    if (!(0, ecmascript_1.isInternalProperty)(p))
                        addToWorklist(f.varProducer.objPropVar(t, p));
        }
        visited.clear();
        for (const t of w2) {
            visited.add(t);
            worklist.push(t);
        }
    }
    for (const v of f.maybeEscapingFromModule)
        addToWorklist(v);
    f.maybeEscapingFromModule.clear();
    while (worklist.length !== 0) {
        const t = worklist.shift();
        if (t instanceof tokens_1.ObjectToken) {
            if (logger_1.default.isDebugEnabled())
                logger_1.default.debug(`Escaping object: ${t}`);
            escaping.add(t);
        }
        if (t instanceof tokens_1.FunctionToken) {
            addToWorklist(f.varProducer.returnVar(t.fun));
            for (const param of t.fun.params)
                if ((0, types_1.isIdentifier)(param))
                    solver.addToken(theUnknownAccessPathToken, f.getRepresentative(f.varProducer.nodeVar(param)));
            if (f.functionsWithThis.has(t.fun))
                solver.addToken(theUnknownAccessPathToken, f.getRepresentative(f.varProducer.thisVar(t.fun)));
        }
        for (const p of f.objectProperties.get(t) ?? [])
            if (!(0, ecmascript_1.isInternalProperty)(p)) {
                const w = f.varProducer.objPropVar(t, p);
                addToWorklist(w);
                solver.addToken(theUnknownAccessPathToken, f.getRepresentative(w));
            }
    }
    if (logger_1.default.isVerboseEnabled()) {
        const objecttokens = new Set();
        for (const [, ts] of f.getAllVarsAndTokens())
            for (const t of ts)
                if (t instanceof tokens_1.ObjectToken)
                    objecttokens.add(t);
        logger_1.default.verbose(`Escaping objects: ${escaping.size}/${objecttokens.size}`);
    }
    return escaping;
}
exports.findEscapingObjects = findEscapingObjects;
//# sourceMappingURL=escaping.js.map