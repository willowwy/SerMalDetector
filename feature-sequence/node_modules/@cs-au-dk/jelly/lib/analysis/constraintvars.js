"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ReadResultVar = exports.AncestorsVar = exports.IntermediateVar = exports.ArgumentsVar = exports.ThisVar = exports.FunctionReturnVar = exports.ObjectPropertyVar = exports.isObjectPropertyVarObj = exports.NodeVar = exports.ConstraintVar = void 0;
const types_1 = require("@babel/types");
const util_1 = require("../misc/util");
const tokens_1 = require("./tokens");
const astvisitor_1 = require("./astvisitor");
const assert_1 = __importDefault(require("assert"));
function getTokenParent(obj) {
    if (obj instanceof tokens_1.AllocationSiteToken)
        return obj.allocSite;
    else if (obj instanceof tokens_1.FunctionToken)
        return obj.fun;
    else if (obj instanceof tokens_1.NativeObjectToken)
        return obj.moduleInfo;
    else if (obj instanceof tokens_1.PackageObjectToken)
        return obj.packageInfo;
    else {
        (0, assert_1.default)(obj instanceof tokens_1.AccessPathToken);
        return undefined;
    }
}
class ConstraintVar {
    getKind() {
        return this.constructor.name;
    }
}
exports.ConstraintVar = ConstraintVar;
class NodeVar extends ConstraintVar {
    node;
    constructor(node) {
        super();
        this.node = node;
    }
    toString() {
        return (0, util_1.nodeToString)(this.node);
    }
    getParent() {
        return this.node;
    }
    getKind() {
        return (0, types_1.isIdentifier)(this.node) ? `Identifier[${this.node[astvisitor_1.IDENTIFIER_KIND]}]` : this.node.type;
    }
}
exports.NodeVar = NodeVar;
function isObjectPropertyVarObj(t) {
    return !(t instanceof tokens_1.AccessPathToken);
}
exports.isObjectPropertyVarObj = isObjectPropertyVarObj;
class ObjectPropertyVar extends ConstraintVar {
    obj;
    prop;
    accessor;
    constructor(obj, prop, accessor) {
        super();
        this.obj = obj;
        this.prop = prop;
        this.accessor = accessor;
    }
    static make(solver, obj, prop, accessor = "normal") {
        solver.addObjectProperty(obj, prop);
        if (obj instanceof tokens_1.ArrayToken)
            solver.addArrayEntry(obj, prop);
        return new ObjectPropertyVar(obj, prop, accessor);
    }
    toString() {
        return `${this.accessor === "get" ? "(get)" : this.accessor === "set" ? "(set)" : ""}${this.obj}.${this.prop}`;
    }
    getParent() {
        return getTokenParent(this.obj);
    }
}
exports.ObjectPropertyVar = ObjectPropertyVar;
class FunctionReturnVar extends ConstraintVar {
    fun;
    constructor(fun) {
        super();
        this.fun = fun;
    }
    toString() {
        return `Return[${(0, util_1.locationToStringWithFileAndEnd)(this.fun.loc, true)}]`;
    }
    getParent() {
        return this.fun;
    }
}
exports.FunctionReturnVar = FunctionReturnVar;
class ThisVar extends ConstraintVar {
    fun;
    constructor(fun) {
        super();
        this.fun = fun;
    }
    toString() {
        return `This[${(0, util_1.locationToStringWithFileAndEnd)(this.fun.loc, true)}]`;
    }
    getParent() {
        return this.fun;
    }
}
exports.ThisVar = ThisVar;
class ArgumentsVar extends ConstraintVar {
    fun;
    constructor(fun) {
        super();
        this.fun = fun;
    }
    toString() {
        return `Arguments[${(0, util_1.locationToStringWithFileAndEnd)(this.fun.loc, true)}]`;
    }
    getParent() {
        return this.fun;
    }
}
exports.ArgumentsVar = ArgumentsVar;
class IntermediateVar extends ConstraintVar {
    node;
    label;
    constructor(node, label) {
        super();
        this.node = node;
        this.label = label;
    }
    toString() {
        return `#${this.label}[${(0, util_1.locationToStringWithFileAndEnd)(this.node.loc, true)}]`;
    }
    getParent() {
        return this.node;
    }
}
exports.IntermediateVar = IntermediateVar;
class AncestorsVar extends ConstraintVar {
    t;
    constructor(t) {
        super();
        this.t = t;
    }
    toString() {
        return `Ancestors(${this.t})`;
    }
    getParent() {
        return getTokenParent(this.t);
    }
}
exports.AncestorsVar = AncestorsVar;
class ReadResultVar extends ConstraintVar {
    t;
    prop;
    constructor(t, prop) {
        super();
        this.t = t;
        this.prop = prop;
    }
    toString() {
        return `ReadResult[${this.t}.${this.prop}]`;
    }
    getParent() {
        return getTokenParent(this.t);
    }
}
exports.ReadResultVar = ReadResultVar;
//# sourceMappingURL=constraintvars.js.map