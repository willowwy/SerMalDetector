"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.FragmentState = void 0;
const constraintvars_1 = require("./constraintvars");
const tokens_1 = require("./tokens");
const types_1 = require("@babel/types");
const assert_1 = __importDefault(require("assert"));
const util_1 = require("../misc/util");
const options_1 = require("../options");
const logger_1 = __importDefault(require("../misc/logger"));
const constraintvarproducer_1 = require("./constraintvarproducer");
class FragmentState {
    a;
    varProducer;
    tokens = new Map;
    vars = new Set;
    redirections = new Map;
    numberOfTokens = 0;
    numberOfSubsetEdges = 0;
    subsetEdges = new Map;
    reverseSubsetEdges = new Map;
    arrayEntries = new Map;
    objectProperties = new Map;
    tokenListeners = new Map;
    listenersProcessed = new Map;
    packageNeighborListeners = new Map;
    arrayEntriesListeners = new Map;
    objectPropertiesListeners = new Map;
    packageNeighbors = new Map;
    postponedListenerCalls = [];
    requireGraph = new Map;
    functionToFunction = new Map;
    callToFunction = new Map;
    callToFunctionOrModule = new Map;
    callToContainingFunction = new Map;
    callToModule = new Map;
    numberOfFunctionToFunctionEdges = 0;
    numberOfCallToFunctionEdges = 0;
    functionsWithArguments = new Set;
    functionsWithThis = new Set;
    artificialFunctions = [];
    callLocations = new Set;
    nativeCallLocations = new Set;
    externalCallLocations = new Set;
    callsWithUnusedResult = new Set;
    callsWithResultMaybeUsedAsPromise = new Set;
    functionParameters = new Map;
    invokedExpressions = new Set;
    maybeEscapingFromModule = new Set;
    widened = new Set;
    maybeEscapingToExternal = new Map;
    unhandledDynamicPropertyWrites = new Map;
    unhandledDynamicPropertyReads = new Set;
    errors = new Map;
    warnings = new Map;
    warningsUnsupported = new Map;
    moduleAccessPaths = new Map;
    propertyReadAccessPaths = new Map;
    propertyWriteAccessPaths = new Map;
    callResultAccessPaths = new Map;
    componentAccessPaths = new Map;
    importDeclRefs = new Map;
    propertyReads = new Set;
    maybeEmptyPropertyReads = [];
    dynamicPropertyWrites = new Set;
    maybeEmptyMethodCalls = new Map;
    constructor(s) {
        this.a = s.globalState;
        this.varProducer = new constraintvarproducer_1.ConstraintVarProducer(s, this);
    }
    registerCallEdge(call, from, to, { native, accessor, external } = {}) {
        if ((!accessor || options_1.options.callgraphImplicit) &&
            (!native || options_1.options.callgraphNative) &&
            (!external || options_1.options.callgraphExternal)) {
            const fs = (0, util_1.mapGetSet)(this.functionToFunction, from);
            if (!fs.has(to))
                this.numberOfFunctionToFunctionEdges++;
            fs.add(to);
            const cs = (0, util_1.mapGetSet)(this.callToFunction, call);
            if (!cs.has(to)) {
                this.numberOfCallToFunctionEdges++;
                if (logger_1.default.isVerboseEnabled())
                    logger_1.default.verbose(`Adding call edge from call ${(0, util_1.locationToStringWithFileAndEnd)(call.loc)}, function ${from} -> ${to}`);
            }
            cs.add(to);
        }
        (0, util_1.mapGetSet)(this.callToFunctionOrModule, call).add(to);
        this.callToContainingFunction.set(call, from);
    }
    registerCall(n, { native, external, accessor } = {}) {
        if (accessor && !options_1.options.callgraphImplicit)
            return;
        if (!this.callLocations.has(n) ||
            (native && !this.nativeCallLocations.has(n)) ||
            (external && !this.externalCallLocations.has(n))) {
            if (logger_1.default.isDebugEnabled())
                logger_1.default.debug(`Adding ${native ? "native " : external ? "external " : accessor ? "accessor " : ""}call ${(0, util_1.locationToStringWithFileAndEnd)(n.loc)}`);
            this.callLocations.add(n);
            if (native)
                this.nativeCallLocations.add(n);
            else if (external)
                this.externalCallLocations.add(n);
        }
    }
    registerMethodCall(node, baseVar, prop, calleeVar) {
        if (baseVar && prop !== undefined && calleeVar && options_1.options.patchMethodCalls)
            this.maybeEmptyMethodCalls.set(node, { baseVar, prop, calleeVar });
    }
    registerRequireCall(node, from, m) {
        if (options_1.options.callgraphRequire)
            (0, util_1.mapGetSet)(this.callToModule, node).add(m);
        (0, util_1.mapGetSet)(this.callToFunctionOrModule, node).add(m);
        this.callToContainingFunction.set(node, from);
    }
    registerRequireEdge(from, to) {
        (0, util_1.mapGetSet)(this.requireGraph, from).add(to);
    }
    registerCallWithUnusedResult(n) {
        this.callsWithUnusedResult.add(n);
    }
    registerCallWithResultMaybeUsedAsPromise(n) {
        this.callsWithResultMaybeUsedAsPromise.add(n);
    }
    registerFunctionParameter(v, fun) {
        (0, util_1.mapGetSet)(this.functionParameters, fun).add(v);
    }
    registerEscapingFromModule(v) {
        if (v)
            this.maybeEscapingFromModule.add(v);
    }
    registerEscapingFromModuleArguments(args, path) {
        for (const arg of args)
            if ((0, types_1.isExpression)(arg))
                this.registerEscapingFromModule(this.varProducer.expVar(arg, path));
    }
    registerEscapingToExternal(v, n) {
        if (v && options_1.options.externalMatches) {
            if (logger_1.default.isDebugEnabled())
                logger_1.default.debug(`Values of ${v} escape to non-analyzed code at ${(0, util_1.locationToStringWithFileAndEnd)(n.loc)}`);
            (0, util_1.mapGetSet)(this.maybeEscapingToExternal, v).add(n);
        }
    }
    registerInvokedExpression(n) {
        this.invokedExpressions.add(n);
    }
    registerArtificialFunction(m, sl) {
        if (sl)
            this.artificialFunctions.push([m, sl]);
    }
    registerUnhandledDynamicPropertyWrite(node, src, source) {
        this.unhandledDynamicPropertyWrites.set(node, { src, source });
    }
    registerUnhandledDynamicPropertyRead(node) {
        this.unhandledDynamicPropertyReads.add(node);
    }
    makeMsg(msg, node) {
        return `${msg}${node ? ` at ${(0, util_1.locationToStringWithFile)(node.loc)}` : ""}`;
    }
    error(msg, node) {
        if ((0, util_1.addMapHybridSet)(node, msg, this.errors))
            logger_1.default.error(`Error: ${this.makeMsg(msg, node)}`);
    }
    warn(msg, node) {
        if ((0, util_1.addMapHybridSet)(node, msg, this.warnings))
            logger_1.default.warn(`Warning: ${this.makeMsg(msg, node)}`);
    }
    warnUnsupported(node, msg = node.type) {
        if ((0, util_1.addMapHybridSet)(node, msg, this.warningsUnsupported) && options_1.options.warningsUnsupported)
            logger_1.default.warn(`Warning: ${this.makeMsg(msg, node)}`);
    }
    reportUnhandledDynamicPropertyWrites() {
        for (const [node, { src, source }] of this.unhandledDynamicPropertyWrites.entries()) {
            const ts = this.getTokens(this.getRepresentative(src));
            let funs = 0, others = 0;
            for (const t of ts)
                if (t instanceof tokens_1.FunctionToken)
                    funs++;
                else if (!(t instanceof tokens_1.AccessPathToken))
                    others++;
            if (funs > 0 || others > 0) {
                this.warnUnsupported(node, `Dynamic property write (${funs} function${funs === 1 ? "" : "s"}, ${others} other object${others === 1 ? "" : "s"})`);
                if (logger_1.default.isVerboseEnabled() && source !== undefined) {
                    logger_1.default.warn(source);
                    for (const t of ts)
                        logger_1.default.warn(`  ${t}`);
                }
            }
        }
    }
    reportUnhandledDynamicPropertyReads() {
        for (const node of this.unhandledDynamicPropertyReads)
            this.warnUnsupported(node, "Dynamic property read");
    }
    registerArguments(path) {
        const f = this.getEnclosingFunction(path);
        if (f) {
            this.functionsWithArguments.add(f);
            if (logger_1.default.isDebugEnabled())
                logger_1.default.debug(`Function uses 'arguments': ${(0, util_1.locationToStringWithFile)(f.loc)}`);
        }
        return f;
    }
    registerThis(path) {
        const f = this.getEnclosingFunction(path);
        if (f) {
            this.functionsWithThis.add(f);
            if (logger_1.default.isDebugEnabled())
                logger_1.default.debug(`Function uses 'this': ${(0, util_1.locationToStringWithFile)(f.loc)}`);
        }
        return f;
    }
    getEnclosingFunction(path) {
        let p = path, f;
        do {
            f = (p = p?.getFunctionParent())?.node;
        } while (f && (0, types_1.isArrowFunctionExpression)(f));
        return f;
    }
    getRepresentative(v) {
        let w = v;
        const ws = [];
        while (true) {
            const w2 = this.redirections.get(w);
            if (!w2)
                break;
            (0, assert_1.default)(ws.length < 100);
            ws.push(w);
            w = w2;
        }
        for (let i = 0; i + 1 < ws.length; i++) {
            (0, assert_1.default)(ws[i] !== w);
            this.redirections.set(ws[i], w);
        }
        return w;
    }
    isRepresentative(v) {
        return !this.redirections.has(v);
    }
    getTokens(v) {
        if (v) {
            const ts = this.tokens.get(v);
            if (ts) {
                if (ts instanceof tokens_1.Token)
                    return [ts];
                return ts;
            }
        }
        return [];
    }
    getTokensSize(v) {
        if (v) {
            const ts = this.tokens.get(v);
            if (ts) {
                if (ts instanceof tokens_1.Token)
                    return [1, [ts]];
                return [ts.size, ts];
            }
        }
        return [0, []];
    }
    *getAllVarsAndTokens() {
        for (const [v, ts] of this.tokens)
            if (ts instanceof tokens_1.Token)
                yield [v, [ts], 1];
            else
                yield [v, ts, ts.size];
    }
    getSizeAndHas(v) {
        if (v) {
            const ts = this.tokens.get(v);
            if (ts) {
                if (ts instanceof tokens_1.Token)
                    return [1, (t) => ts === t];
                return [ts.size, (t) => ts.has(t)];
            }
        }
        return [0, (_t) => false];
    }
    getNumberOfVarsWithTokens() {
        return this.tokens.size;
    }
    getLargestTokenSetSize() {
        let c = 0;
        for (const v of this.tokens.values()) {
            const s = v instanceof tokens_1.Token ? 1 : v.size;
            if (s > c)
                c = s;
        }
        return c;
    }
    getLargestSubsetEdgeOutDegree() {
        let c = 0;
        for (const vs of this.subsetEdges.values())
            if (vs.size > c)
                c = vs.size;
        return c;
    }
    deleteVar(v) {
        this.tokens.delete(v);
    }
    replaceTokens(v, ts, old) {
        this.tokens.set(v, ts.size === 1 ? ts.values().next().value : ts);
        this.numberOfTokens += ts.size - old;
    }
    addToken(t, v) {
        const ts = this.tokens.get(v);
        if (!ts)
            this.tokens.set(v, t);
        else if (ts instanceof tokens_1.Token) {
            if (ts === t)
                return false;
            this.tokens.set(v, new Set([ts, t]));
        }
        else {
            if (ts.has(t))
                return false;
            ts.add(t);
        }
        this.numberOfTokens++;
        return true;
    }
    addTokens(ts, v) {
        const added = [];
        let vs = this.tokens.get(v);
        for (const t of ts) {
            let add = false;
            if (!vs) {
                vs = t;
                this.tokens.set(v, vs);
                add = true;
            }
            else if (vs instanceof tokens_1.Token) {
                if (vs !== t) {
                    vs = new Set([vs, t]);
                    this.tokens.set(v, vs);
                    add = true;
                }
            }
            else if (!vs.has(t)) {
                vs.add(t);
                add = true;
            }
            if (add)
                added.push(t);
        }
        this.numberOfTokens += added.length;
        return added;
    }
    maybeWidened(t) {
        if (t instanceof tokens_1.ObjectToken && this.widened.has(t))
            return this.a.canonicalizeToken(new tokens_1.PackageObjectToken(t.getPackageInfo(), t.kind));
        else
            return t;
    }
    resolveGetterCalls() {
        const getters = new Map();
        const add = (prop, obj, ts) => {
            obj = this.maybeWidened(obj);
            if (obj instanceof tokens_1.NativeObjectToken)
                return;
            const gs = [...ts].filter(t => t instanceof tokens_1.FunctionToken && t.fun.params.length === 0);
            if (gs.length === 0)
                return;
            (0, util_1.addAll)(gs, (0, util_1.mapGetSet)((0, util_1.mapGetMap)(getters, prop), obj));
        };
        for (const [v, ts] of this.tokens)
            if (v instanceof constraintvars_1.ObjectPropertyVar && v.accessor === "get")
                add(v.prop, v.obj, ts instanceof tokens_1.Token ? [ts] : ts);
        for (const v of this.redirections.keys())
            if (v instanceof constraintvars_1.ObjectPropertyVar && v.accessor === "get") {
                const [n, ts] = this.getTokensSize(this.getRepresentative(v));
                if (n > 0)
                    add(v.prop, v.obj, ts);
            }
        for (const { base, prop, node, enclosing } of this.propertyReads) {
            const gs = getters.get(prop);
            if (!gs)
                continue;
            const ts = new Set();
            for (const t of this.getTokens(this.getRepresentative(base)))
                if ((0, constraintvars_1.isObjectPropertyVarObj)(t)) {
                    ts.add(t);
                    (0, util_1.addAll)(this.getTokens(this.getRepresentative(this.varProducer.ancestorsVar(t))), ts);
                    if (t instanceof tokens_1.PackageObjectToken && t.kind === "Object")
                        for (const n of this.packageNeighbors.get(t.packageInfo) ?? [])
                            ts.add(this.a.canonicalizeToken(new tokens_1.PackageObjectToken(n, "Object")));
                }
            for (const t of ts) {
                const fts = gs.get(t);
                if (fts)
                    for (const ft of fts) {
                        this.registerCall(node, { accessor: true });
                        this.registerCallEdge(node, enclosing, this.a.functionInfos.get(ft.fun), { accessor: true });
                    }
            }
        }
        this.propertyReads.clear();
    }
}
exports.FragmentState = FragmentState;
//# sourceMappingURL=fragmentstate.js.map