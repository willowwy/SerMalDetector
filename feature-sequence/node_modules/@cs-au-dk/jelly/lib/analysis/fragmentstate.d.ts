import { ConstraintVar, ObjectPropertyVarObj } from "./constraintvars";
import { ArrayToken, ObjectToken, PackageObjectToken, Token } from "./tokens";
import { DummyModuleInfo, FunctionInfo, ModuleInfo, PackageInfo } from "./infos";
import { CallExpression, Function, Identifier, JSXIdentifier, NewExpression, Node, OptionalCallExpression, SourceLocation } from "@babel/types";
import { AccessPath, CallResultAccessPath, ComponentAccessPath, ModuleAccessPath, PropertyAccessPath } from "./accesspaths";
import { NodePath } from "@babel/traverse";
import { GlobalState } from "./globalstate";
import { ConstraintVarProducer } from "./constraintvarproducer";
import Solver from "./solver";
import { MaybeEmptyPropertyRead } from "../patching/patchdynamics";
export type ListenerID = bigint;
export type RepresentativeVar = ConstraintVar & {
    readonly __repr: unique symbol;
};
export type MergeRepresentativeVar = ConstraintVar & {
    readonly __repr: unique symbol;
};
export declare class FragmentState<RVT extends RepresentativeVar | MergeRepresentativeVar = RepresentativeVar> {
    readonly a: GlobalState;
    readonly varProducer: ConstraintVarProducer<RVT>;
    private readonly tokens;
    readonly vars: Set<RVT>;
    readonly redirections: Map<ConstraintVar, ConstraintVar>;
    numberOfTokens: number;
    numberOfSubsetEdges: number;
    readonly subsetEdges: Map<RVT, Set<RVT>>;
    readonly reverseSubsetEdges: Map<RVT, Set<RVT>>;
    readonly arrayEntries: Map<ArrayToken, Set<string>>;
    readonly objectProperties: Map<ObjectPropertyVarObj, Set<string>>;
    readonly tokenListeners: Map<RVT, Map<ListenerID, (t: Token) => void>>;
    readonly listenersProcessed: Map<ListenerID, Set<Token>>;
    readonly packageNeighborListeners: Map<PackageInfo, Map<ListenerID, (neighbor: PackageInfo) => void>>;
    readonly arrayEntriesListeners: Map<ArrayToken, Map<ListenerID, (prop: string) => void>>;
    objectPropertiesListeners: Map<ObjectPropertyVarObj, Map<ListenerID, (prop: string) => void>>;
    readonly packageNeighbors: Map<PackageInfo, Set<PackageInfo>>;
    readonly postponedListenerCalls: Array<[
        (t: Token) => void,
        Token
    ] | [
        (neighbor: PackageInfo) => void,
        PackageInfo
    ] | [
        (prop: string) => void,
        string
    ]>;
    readonly requireGraph: Map<FunctionInfo | ModuleInfo, Set<ModuleInfo>>;
    readonly functionToFunction: Map<FunctionInfo | ModuleInfo, Set<FunctionInfo>>;
    readonly callToFunction: Map<Node, Set<FunctionInfo>>;
    readonly callToFunctionOrModule: Map<Node, Set<FunctionInfo | ModuleInfo | DummyModuleInfo>>;
    readonly callToContainingFunction: Map<Node, ModuleInfo | FunctionInfo>;
    readonly callToModule: Map<Node, Set<ModuleInfo | DummyModuleInfo>>;
    numberOfFunctionToFunctionEdges: number;
    numberOfCallToFunctionEdges: number;
    readonly functionsWithArguments: Set<Function>;
    readonly functionsWithThis: Set<Function>;
    readonly artificialFunctions: Array<[ModuleInfo, SourceLocation]>;
    readonly callLocations: Set<Node>;
    readonly nativeCallLocations: Set<Node>;
    readonly externalCallLocations: Set<Node>;
    readonly callsWithUnusedResult: Set<Node>;
    readonly callsWithResultMaybeUsedAsPromise: Set<Node>;
    readonly functionParameters: Map<Function, Set<ConstraintVar>>;
    readonly invokedExpressions: Set<Node>;
    readonly maybeEscapingFromModule: Set<Token | ConstraintVar>;
    readonly widened: Set<ObjectToken>;
    readonly maybeEscapingToExternal: Map<ConstraintVar, Set<Node>>;
    readonly unhandledDynamicPropertyWrites: Map<Node, {
        src: ConstraintVar;
        source: string | undefined;
    }>;
    readonly unhandledDynamicPropertyReads: Set<Node>;
    errors: Map<Node | undefined, string | Set<string>>;
    warnings: Map<Node | undefined, string | Set<string>>;
    warningsUnsupported: Map<Node, string | Set<string>>;
    readonly moduleAccessPaths: Map<ModuleAccessPath, Set<Node>>;
    readonly propertyReadAccessPaths: Map<AccessPath, Map<string, Map<Node, {
        bp: PropertyAccessPath;
        sub: ConstraintVar;
    }>>>;
    readonly propertyWriteAccessPaths: Map<AccessPath, Map<string, Map<Node, {
        bp: PropertyAccessPath;
        sub: ConstraintVar;
    }>>>;
    readonly callResultAccessPaths: Map<AccessPath, Map<Node, {
        bp: CallResultAccessPath;
        sub: ConstraintVar;
    }>>;
    readonly componentAccessPaths: Map<AccessPath, Map<Node, {
        bp: ComponentAccessPath;
        sub: ConstraintVar;
    }>>;
    readonly importDeclRefs: Map<Identifier, Array<Identifier | JSXIdentifier>>;
    readonly propertyReads: Set<{
        base: ConstraintVar;
        prop: string;
        node: Node;
        enclosing: FunctionInfo | ModuleInfo;
    }>;
    maybeEmptyPropertyReads: Array<MaybeEmptyPropertyRead>;
    dynamicPropertyWrites: Set<ConstraintVar>;
    readonly maybeEmptyMethodCalls: Map<Node, {
        baseVar: ConstraintVar;
        prop: string;
        calleeVar: ConstraintVar;
    }>;
    constructor(s: Solver);
    registerCallEdge(call: Node, from: FunctionInfo | ModuleInfo, to: FunctionInfo, { native, accessor, external }?: {
        native?: boolean;
        accessor?: boolean;
        external?: boolean;
    }): void;
    registerCall(n: Node, { native, external, accessor }?: {
        native?: boolean;
        external?: boolean;
        accessor?: boolean;
    }): void;
    registerMethodCall(node: Node, baseVar: ConstraintVar | undefined, prop: string | undefined, calleeVar: ConstraintVar | undefined): void;
    registerRequireCall(node: Node, from: ModuleInfo | FunctionInfo, m: ModuleInfo | DummyModuleInfo): void;
    registerRequireEdge(from: FunctionInfo | ModuleInfo, to: ModuleInfo): void;
    registerCallWithUnusedResult(n: CallExpression | OptionalCallExpression | NewExpression): void;
    registerCallWithResultMaybeUsedAsPromise(n: CallExpression | OptionalCallExpression | NewExpression): void;
    registerFunctionParameter(v: ConstraintVar, fun: Function): void;
    registerEscapingFromModule(v: Token | ConstraintVar | undefined): void;
    registerEscapingFromModuleArguments(args: CallExpression["arguments"], path: NodePath<CallExpression | OptionalCallExpression | NewExpression>): void;
    registerEscapingToExternal(v: ConstraintVar | undefined, n: Node): void;
    registerInvokedExpression(n: Node): void;
    registerArtificialFunction(m: ModuleInfo, sl: Node["loc"]): void;
    registerUnhandledDynamicPropertyWrite(node: Node, src: ConstraintVar, source: string | undefined): void;
    registerUnhandledDynamicPropertyRead(node: Node): void;
    private makeMsg;
    error(msg: string, node?: Node): void;
    warn(msg: string, node?: Node): void;
    warnUnsupported(node: Node, msg?: string): void;
    reportUnhandledDynamicPropertyWrites(): void;
    reportUnhandledDynamicPropertyReads(): void;
    registerArguments(path: NodePath): Function | undefined;
    registerThis(path: NodePath): Function | undefined;
    getEnclosingFunction(path: NodePath): Function | undefined;
    getRepresentative(v: ConstraintVar): RVT;
    isRepresentative(v: ConstraintVar): v is RVT;
    getTokens(v: RVT | undefined): Iterable<Token>;
    getTokensSize(v: RVT | undefined): [number, Iterable<Token>];
    getAllVarsAndTokens(): Iterable<[RVT, Set<Token> | Array<Token>, number]>;
    getSizeAndHas(v: RVT | undefined): [number, (t: Token) => boolean];
    getNumberOfVarsWithTokens(): number;
    getLargestTokenSetSize(): number;
    getLargestSubsetEdgeOutDegree(): number;
    deleteVar(v: RVT): void;
    replaceTokens(v: RVT, ts: Set<Token>, old: number): void;
    addToken(t: Token, v: RVT): boolean;
    addTokens(ts: Iterable<Token>, v: RVT): Array<Token>;
    maybeWidened<T extends Token>(t: T): T | PackageObjectToken;
    resolveGetterCalls(): void;
}
