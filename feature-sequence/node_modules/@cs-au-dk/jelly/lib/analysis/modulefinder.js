"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.findModules = void 0;
const types_1 = require("@babel/types");
const util_1 = require("../misc/util");
const traverse_1 = __importDefault(require("@babel/traverse"));
const logger_1 = __importDefault(require("../misc/logger"));
const options_1 = require("../options");
const module_1 = __importDefault(require("module"));
const files_1 = require("../misc/files");
function findModules(ast, file, f, moduleInfo) {
    function requireModule(str, path) {
        if (!module_1.default.isBuiltin(str))
            try {
                const filepath = (0, files_1.requireResolve)(str, file, path.node, f);
                if (filepath)
                    f.a.reachedFile(filepath, moduleInfo);
            }
            catch {
                if (options_1.options.ignoreUnresolved || options_1.options.ignoreDependencies) {
                    if (logger_1.default.isVerboseEnabled())
                        logger_1.default.verbose(`Ignoring unresolved module '${str}' at ${(0, util_1.locationToStringWithFile)(path.node.loc)}`);
                }
                else
                    f.warn(`Unable to resolve module '${str}'`, path.node);
            }
    }
    (0, traverse_1.default)(ast, {
        CallExpression(path) {
            if ((((0, types_1.isIdentifier)(path.node.callee) &&
                path.node.callee.name === "require" &&
                !path.scope.getBinding(path.node.callee.name)) ||
                (0, types_1.isImport)(path.node.callee)) &&
                path.node.arguments.length >= 1) {
                const arg = path.node.arguments[0];
                if ((0, types_1.isStringLiteral)(arg))
                    requireModule(arg.value, path);
                else
                    f.warnUnsupported(path.node, "Unhandled 'require'");
            }
        },
        ImportDeclaration(path) {
            requireModule(path.node.source.value, path);
        },
        ExportAllDeclaration(path) {
            requireModule(path.node.source.value, path);
        },
        ExportNamedDeclaration(path) {
            if (path.node.source)
                requireModule(path.node.source.value, path);
        }
    });
}
exports.findModules = findModules;
//# sourceMappingURL=modulefinder.js.map