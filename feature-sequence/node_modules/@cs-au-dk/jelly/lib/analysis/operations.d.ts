import { Expression, Function, JSXIdentifier, JSXMemberExpression, JSXNamespacedName, LVal, Node, OptionalMemberExpression, ParenthesizedExpression } from "@babel/types";
import { NodePath } from "@babel/traverse";
import { AllocationSiteToken, ArrayToken, ClassToken, FunctionToken, NativeObjectToken, ObjectToken, PackageObjectToken, PrototypeToken, Token } from "./tokens";
import { AccessorType, ConstraintVar, ObjectPropertyVarObj, ReadResultVar } from "./constraintvars";
import Solver, { ListenerKey } from "./solver";
import { GlobalState } from "./globalstate";
import { DummyModuleInfo, FunctionInfo, ModuleInfo, PackageInfo } from "./infos";
import { FilePath } from "../misc/util";
import { CallNodePath, SpecialNativeObjects } from "../natives/nativebuilder";
export declare class Operations {
    readonly file: FilePath;
    readonly solver: Solver;
    readonly moduleSpecialNatives: SpecialNativeObjects;
    readonly globalSpecialNatives: SpecialNativeObjects;
    readonly a: GlobalState;
    readonly moduleInfo: ModuleInfo;
    readonly packageInfo: PackageInfo;
    readonly packageObjectToken: PackageObjectToken;
    readonly exportsObjectToken: NativeObjectToken;
    constructor(file: FilePath, solver: Solver, moduleSpecialNatives: SpecialNativeObjects);
    expVar(exp: Expression | JSXIdentifier | JSXMemberExpression | JSXNamespacedName, path: NodePath): ConstraintVar | undefined;
    callFunction(path: CallNodePath): void;
    callFunctionBound(base: ObjectPropertyVarObj | undefined, t: Token, calleeVar: ConstraintVar | undefined, argVars: Array<ConstraintVar | undefined>, resultVar: ConstraintVar | undefined, strings: Array<string>, path: CallNodePath): void;
    callFunctionTokenBound(t: FunctionToken, base: ConstraintVar | ObjectPropertyVarObj | undefined, caller: FunctionInfo | ModuleInfo, args: Array<Token | ConstraintVar | undefined>, resultVar: ConstraintVar | undefined, isNew: boolean, path: CallNodePath, kind?: {
        native?: boolean;
        accessor?: boolean;
        external?: boolean;
    }): void;
    invokeExternalCallback(at: Token, node: Node, caller: ModuleInfo | FunctionInfo): void;
    readProperty(base: ConstraintVar | undefined, prop: string | undefined, dst: ConstraintVar | undefined, node: Node, enclosing: FunctionInfo | ModuleInfo, extrakey?: string): void;
    readPropertyFromChain(base: ObjectPropertyVarObj, prop: string): ReadResultVar;
    readPropertyBound(t: ObjectPropertyVarObj, prop: string, dst: ConstraintVar, extrakey: Omit<ListenerKey, "l">, enclosing?: FunctionInfo | ModuleInfo, thist?: Token): void;
    writeProperty(src: ConstraintVar | undefined, lVar: ConstraintVar | undefined, base: Token, prop: string, node: Node, enclosing: FunctionInfo | ModuleInfo, escapeNode?: Node, ac?: AccessorType, invokeSetters?: boolean): void;
    requireModule(str: string, resultVar: ConstraintVar | undefined, path: NodePath): ModuleInfo | DummyModuleInfo | undefined;
    assign(src: ConstraintVar | undefined, dst: LVal | ParenthesizedExpression | OptionalMemberExpression, path: NodePath): void;
    readIteratorValue(src: ConstraintVar | undefined, dst: ConstraintVar, node: Node): void;
    newObjectToken(n: Node): ObjectToken | PackageObjectToken;
    newPrototypeToken(fun: Function): PrototypeToken;
    newArrayToken(n: Node): ArrayToken;
    newClassToken(n: Node): ClassToken;
    newFunctionToken(fun: Function): FunctionToken;
    newRegExpToken(): PackageObjectToken;
    newPromiseToken(n: Node): AllocationSiteToken;
    awaitPromise(arg: ConstraintVar | undefined, res: ConstraintVar | undefined, node: Node): void;
}
