"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Operations = void 0;
const types_1 = require("@babel/types");
const asthelpers_1 = require("../misc/asthelpers");
const tokens_1 = require("./tokens");
const constraintvars_1 = require("./constraintvars");
const accesspaths_1 = require("./accesspaths");
const infos_1 = require("./infos");
const logger_1 = __importDefault(require("../misc/logger"));
const files_1 = require("../misc/files");
const options_1 = require("../options");
const util_1 = require("../misc/util");
const assert_1 = __importDefault(require("assert"));
const ecmascript_1 = require("../natives/ecmascript");
const listeners_1 = require("./listeners");
const micromatch_1 = __importDefault(require("micromatch"));
const nativehelpers_1 = require("../natives/nativehelpers");
const module_1 = __importDefault(require("module"));
class Operations {
    file;
    solver;
    moduleSpecialNatives;
    globalSpecialNatives;
    a;
    moduleInfo;
    packageInfo;
    packageObjectToken;
    exportsObjectToken;
    constructor(file, solver, moduleSpecialNatives) {
        this.file = file;
        this.solver = solver;
        this.moduleSpecialNatives = moduleSpecialNatives;
        this.globalSpecialNatives = this.solver.globalState.globalSpecialNatives;
        this.a = this.solver.globalState;
        this.moduleInfo = this.a.getModuleInfo(file);
        this.packageInfo = this.moduleInfo.packageInfo;
        this.packageObjectToken = this.a.canonicalizeToken(new tokens_1.PackageObjectToken(this.packageInfo));
        this.exportsObjectToken = this.a.canonicalizeToken(new tokens_1.NativeObjectToken("exports", this.moduleInfo));
    }
    expVar(exp, path) {
        const v = this.solver.varProducer.expVar(exp, path);
        if (v instanceof constraintvars_1.NodeVar && (0, types_1.isIdentifier)(v.node) && v.node.loc.unbound) {
            this.solver.addSubsetConstraint(this.solver.varProducer.objPropVar(this.globalSpecialNatives.get("globalThis"), v.node.name), v);
            this.solver.addAccessPath(accesspaths_1.UnknownAccessPath.instance, v);
        }
        return v;
    }
    callFunction(path) {
        const f = this.solver.fragmentState;
        const vp = this.solver.varProducer;
        const caller = this.a.getEnclosingFunctionOrModule(path, this.moduleInfo);
        const pars = (0, asthelpers_1.getAdjustedCallNodePath)(path);
        f.registerCall(pars.node);
        if ((0, asthelpers_1.isParentExpressionStatement)(pars))
            f.registerCallWithUnusedResult(path.node);
        if ((0, asthelpers_1.isMaybeUsedAsPromise)(path))
            f.registerCallWithResultMaybeUsedAsPromise(path.node);
        f.registerInvokedExpression(path.node.callee);
        const resultVar = vp.nodeVar(path.node);
        const args = path.node.arguments;
        const argVars = args.map(arg => {
            if ((0, types_1.isExpression)(arg))
                return this.expVar(arg, path);
            else if ((0, types_1.isSpreadElement)(arg))
                f.warnUnsupported(arg, "SpreadElement in arguments");
            return undefined;
        });
        let p = path.get("callee");
        while (p.isParenthesizedExpression())
            p = p.get("expression");
        const calleeVar = (0, types_1.isExpression)(p.node) ? this.expVar(p.node, p) : undefined;
        const handleCall = (base, t) => {
            this.callFunctionBound(base, t, calleeVar, argVars, resultVar, strings, path);
        };
        this.solver.addForAllTokensConstraint(calleeVar, listeners_1.TokenListener.CALL_FUNCTION_CALLEE, path.node, (t) => handleCall(undefined, t));
        if (p.isMemberExpression() || p.isOptionalMemberExpression()) {
            const baseVar = this.expVar(p.node.object, p);
            const prop = (0, asthelpers_1.getProperty)(p.node);
            this.solver.collectPropertyRead("call", undefined, baseVar, this.packageObjectToken, prop, p.node, caller);
            f.registerMethodCall(path.node, baseVar, prop, calleeVar);
            if (prop === undefined) {
                this.solver.fragmentState.registerEscapingFromModule(baseVar);
                this.solver.addAccessPath(accesspaths_1.UnknownAccessPath.instance, calleeVar);
            }
            this.solver.addForAllTokensConstraint(baseVar, listeners_1.TokenListener.CALL_FUNCTION_BASE, path.node, (t) => {
                let callees;
                if (prop !== undefined) {
                    if ((0, constraintvars_1.isObjectPropertyVarObj)(t))
                        callees = this.readPropertyFromChain(t, prop);
                    else {
                        (0, assert_1.default)(t instanceof tokens_1.AccessPathToken);
                        this.solver.addAccessPath(new accesspaths_1.PropertyAccessPath(baseVar, prop), calleeVar, t.ap);
                    }
                }
                else if (t instanceof tokens_1.ArrayToken)
                    callees = this.solver.varProducer.arrayAllVar(t);
                else if (!(t instanceof tokens_1.AccessPathToken)) {
                }
                if (callees) {
                    (0, assert_1.default)((0, constraintvars_1.isObjectPropertyVarObj)(t));
                    this.solver.addForAllTokensConstraint(callees, listeners_1.TokenListener.CALL_FUNCTION_CALLEE, { n: path.node, t }, (ft) => handleCall(t, ft));
                }
            });
        }
        const strings = args.length >= 1 && (0, types_1.isStringLiteral)(args[0]) ? [args[0].value] : [];
        if (path.get("callee").isImport() && args.length >= 1) {
            const v = this.a.canonicalizeVar(new constraintvars_1.IntermediateVar(path.node, "import"));
            if (strings.length === 0)
                f.warnUnsupported(p.node, "Unhandled 'import'");
            for (const str of strings)
                this.requireModule(str, v, path);
            const promise = this.newPromiseToken(path.node);
            this.solver.addTokenConstraint(promise, this.expVar(path.node, path));
            this.solver.addSubsetConstraint(v, this.solver.varProducer.objPropVar(promise, ecmascript_1.PROMISE_FULFILLED_VALUES));
        }
    }
    callFunctionBound(base, t, calleeVar, argVars, resultVar, strings, path) {
        const f = this.solver.fragmentState;
        const caller = this.a.getEnclosingFunctionOrModule(path, this.moduleInfo);
        const pars = (0, asthelpers_1.getAdjustedCallNodePath)(path);
        const args = path.node.arguments;
        const isNew = path.isNewExpression();
        if (base)
            base = f.maybeWidened(base);
        if (t instanceof tokens_1.FunctionToken)
            this.callFunctionTokenBound(t, base, caller, argVars, resultVar, isNew, path);
        else if (t instanceof tokens_1.NativeObjectToken) {
            f.registerCall(pars.node, { native: true });
            if (t.invoke && (!isNew || t.constr))
                t.invoke({
                    base,
                    path,
                    solver: this.solver,
                    op: this,
                    moduleInfo: this.moduleInfo,
                    moduleSpecialNatives: this.moduleSpecialNatives,
                    globalSpecialNatives: this.globalSpecialNatives,
                });
            if (t.name === "require") {
                if (strings.length === 0)
                    f.warnUnsupported(path.node, "Unhandled 'require'");
                for (const str of strings)
                    this.requireModule(str, resultVar, path);
            }
        }
        else if (t instanceof tokens_1.AllocationSiteToken && (t.kind === "PromiseResolve" || t.kind === "PromiseReject") && !isNew) {
            (0, nativehelpers_1.callPromiseResolve)(t, path.node.arguments, path, this);
        }
        else if (t instanceof tokens_1.AccessPathToken) {
            f.registerCall(pars.node, { external: true });
            f.registerEscapingFromModuleArguments(args, path);
            (0, assert_1.default)(calleeVar);
            this.solver.addAccessPath(new accesspaths_1.CallResultAccessPath(calleeVar), resultVar, t.ap);
            for (let i = 0; i < argVars.length; i++) {
                const argVar = argVars[i];
                if (argVar) {
                    this.solver.addForAllTokensConstraint(argVar, listeners_1.TokenListener.CALL_FUNCTION_EXTERNAL, args[i], (at) => this.invokeExternalCallback(at, pars.node, caller));
                    f.registerEscapingToExternal(argVar, args[i]);
                }
                else if ((0, types_1.isSpreadElement)(args[i]))
                    f.warnUnsupported(args[i], "SpreadElement in arguments to external function");
            }
        }
        if (!options_1.options.oldobj) {
            if (isNew && t instanceof tokens_1.FunctionToken) {
                const q = this.newObjectToken(t.fun);
                this.solver.addTokenConstraint(q, resultVar);
                this.solver.addTokenConstraint(q, this.solver.varProducer.thisVar(t.fun));
                this.solver.addInherits(q, this.solver.varProducer.objPropVar(t, "prototype"));
            }
        }
        else {
            if (isNew && (t instanceof tokens_1.FunctionToken || t instanceof tokens_1.ClassToken)) {
                this.solver.addTokenConstraint(this.packageObjectToken, resultVar);
            }
        }
    }
    callFunctionTokenBound(t, base, caller, args, resultVar, isNew, path, kind = {}) {
        const addInclusionConstraint = (from, to) => {
            if (from instanceof tokens_1.Token)
                this.solver.addTokenConstraint(from, to);
            else
                this.solver.addSubsetConstraint(from, to);
        };
        const f = this.solver.fragmentState;
        const vp = f.varProducer;
        const pars = (0, asthelpers_1.getAdjustedCallNodePath)(path);
        f.registerCallEdge(pars.node, caller, this.a.functionInfos.get(t.fun), kind);
        if (t.fun.loc.module !== this.moduleInfo)
            for (const arg of args)
                f.registerEscapingFromModule(arg);
        const hasArguments = f.functionsWithArguments.has(t.fun);
        const argumentsToken = hasArguments ? this.a.canonicalizeToken(new tokens_1.ArrayToken(t.fun.body)) : undefined;
        for (const [i, arg] of args.entries()) {
            if (arg) {
                if (i < t.fun.params.length) {
                    const param = t.fun.params[i];
                    if ((0, types_1.isRestElement)(param)) {
                        const rest = args.slice(i);
                        const t = this.newArrayToken(param);
                        for (const [i, arg] of rest.entries())
                            if (arg)
                                addInclusionConstraint(arg, vp.objPropVar(t, String(i)));
                        this.solver.addTokenConstraint(t, vp.nodeVar(param));
                    }
                    else
                        addInclusionConstraint(arg, vp.nodeVar(param));
                }
                if (hasArguments)
                    addInclusionConstraint(arg, vp.objPropVar(argumentsToken, String(i)));
            }
        }
        if (!isNew && base && f.functionsWithThis.has(t.fun))
            addInclusionConstraint(base, vp.thisVar(t.fun));
        if (!(0, asthelpers_1.isParentExpressionStatement)(pars))
            this.solver.addSubsetConstraint(vp.returnVar(t.fun), resultVar);
    }
    invokeExternalCallback(at, node, caller) {
        if (at instanceof tokens_1.FunctionToken) {
            const f = this.solver.fragmentState;
            f.registerCall(node, { external: true });
            f.registerCallEdge(node, caller, this.a.functionInfos.get(at.fun), { external: true });
            for (let j = 0; j < at.fun.params.length; j++)
                if ((0, types_1.isIdentifier)(at.fun.params[j]))
                    this.solver.addAccessPath(accesspaths_1.UnknownAccessPath.instance, f.varProducer.nodeVar(at.fun.params[j]));
            if (f.functionsWithThis.has(at.fun))
                this.solver.addAccessPath(accesspaths_1.UnknownAccessPath.instance, f.varProducer.thisVar(at.fun));
        }
    }
    readProperty(base, prop, dst, node, enclosing, extrakey = "") {
        this.solver.collectPropertyRead("read", dst, base, this.packageObjectToken, prop, node, enclosing);
        const lopts = { n: node, s: extrakey };
        if (prop !== undefined) {
            this.solver.addForAllTokensConstraint(base, listeners_1.TokenListener.READ_PROPERTY_BASE, lopts, (t) => {
                if ((0, constraintvars_1.isObjectPropertyVarObj)(t)) {
                    this.solver.addSubsetConstraint(this.readPropertyFromChain(t, prop), dst);
                    if (options_1.options.oldobj) {
                        if ((t instanceof tokens_1.FunctionToken || t instanceof tokens_1.ClassToken) && prop === "prototype") {
                            if (dst)
                                this.solver.addTokenConstraint(this.packageObjectToken, dst);
                        }
                    }
                }
                else if (t instanceof tokens_1.AccessPathToken) {
                    this.solver.addAccessPath(new accesspaths_1.PropertyAccessPath(base, prop), this.solver.varProducer.nodeVar(node), t.ap);
                }
            });
        }
        else {
            this.solver.fragmentState.registerEscapingFromModule(base);
            this.solver.addAccessPath(accesspaths_1.UnknownAccessPath.instance, dst);
            if (dst)
                this.solver.addForAllTokensConstraint(base, listeners_1.TokenListener.READ_PROPERTY_BASE_DYNAMIC, lopts, (t) => {
                    if (t instanceof tokens_1.ArrayToken) {
                        this.solver.addSubsetConstraint(this.solver.varProducer.arrayAllVar(t), dst);
                    }
                    else if (!(t instanceof tokens_1.AccessPathToken)) {
                        if (logger_1.default.isInfoEnabled())
                            this.solver.fragmentState.registerUnhandledDynamicPropertyRead(node);
                    }
                });
        }
    }
    readPropertyFromChain(base, prop) {
        const dst = this.solver.varProducer.readResultVar(base, prop);
        this.solver.addForAllAncestorsConstraint(base, listeners_1.TokenListener.READ_ANCESTORS, { s: prop }, (t2) => {
            (0, assert_1.default)((0, constraintvars_1.isObjectPropertyVarObj)(t2));
            this.readPropertyBound(t2, prop, dst, { s: prop, t: base }, undefined, base);
        });
        return dst;
    }
    readPropertyBound(t, prop, dst, extrakey, enclosing, thist = t) {
        (0, assert_1.default)(!enclosing || extrakey.n);
        const readFromGetter = (t) => {
            if (t instanceof tokens_1.FunctionToken && t.fun.params.length === 0) {
                this.solver.addSubsetConstraint(this.solver.varProducer.returnVar(t.fun), dst);
                if (enclosing) {
                    const node = extrakey.n;
                    this.solver.fragmentState.registerCall(node, { accessor: true });
                    this.solver.fragmentState.registerCallEdge(node, enclosing, this.a.functionInfos.get(t.fun), { accessor: true });
                }
            }
        };
        const bindGetterThis = (baset, t) => {
            if (t instanceof tokens_1.FunctionToken && t.fun.params.length === 0)
                if (this.solver.fragmentState.functionsWithThis.has(t.fun))
                    this.solver.addTokenConstraint(this.solver.fragmentState.maybeWidened(baset), this.solver.varProducer.thisVar(t.fun));
        };
        if (dst)
            this.solver.addSubsetConstraint(this.solver.varProducer.objPropVar(t, prop), dst);
        if (!(t instanceof tokens_1.NativeObjectToken) && prop !== "prototype") {
            const getter = this.solver.varProducer.objPropVar(t, prop, "get");
            this.solver.addForAllTokensConstraint(getter, listeners_1.TokenListener.READ_PROPERTY_GETTER, extrakey, (t3) => readFromGetter(t3));
            this.solver.addForAllTokensConstraint(getter, listeners_1.TokenListener.READ_PROPERTY_GETTER_THIS, { t: thist }, (t3) => bindGetterThis(thist, t3));
        }
        if (t instanceof tokens_1.PackageObjectToken && t.kind === "Object") {
            if (options_1.options.readNeighbors)
                this.solver.addForAllPackageNeighborsConstraint(t.packageInfo, extrakey, (neighbor) => {
                    if (dst)
                        this.solver.addSubsetConstraint(this.solver.varProducer.packagePropVar(neighbor, prop), dst);
                    if (prop !== "prototype") {
                        const nt = this.a.canonicalizeToken(new tokens_1.PackageObjectToken(neighbor));
                        const getter = this.solver.varProducer.packagePropVar(neighbor, prop, "get");
                        this.solver.addForAllTokensConstraint(getter, listeners_1.TokenListener.READ_PROPERTY_GETTER2, extrakey, (t3) => readFromGetter(t3));
                        this.solver.addForAllTokensConstraint(getter, listeners_1.TokenListener.READ_PROPERTY_GETTER_THIS2, { t: nt }, (t3) => bindGetterThis(nt, t3));
                    }
                });
        }
        else if (t instanceof tokens_1.ArrayToken) {
            if ((0, util_1.isArrayIndex)(prop)) {
                this.solver.addSubsetConstraint(this.solver.varProducer.arrayUnknownVar(t), dst);
            }
        }
    }
    writeProperty(src, lVar, base, prop, node, enclosing, escapeNode = node, ac = "normal", invokeSetters = true) {
        const writeToSetter = (t) => {
            if (t instanceof tokens_1.FunctionToken && t.fun.params.length === 1) {
                this.solver.addSubsetConstraint(src, this.solver.varProducer.nodeVar(t.fun.params[0]));
                this.solver.fragmentState.registerCall(node, { accessor: true });
                this.solver.fragmentState.registerCallEdge(node, enclosing, this.a.functionInfos.get(t.fun), { accessor: true });
            }
        };
        const bindSetterThis = (t) => {
            if (t instanceof tokens_1.FunctionToken && t.fun.params.length === 1)
                if (this.solver.fragmentState.functionsWithThis.has(t.fun))
                    this.solver.addTokenConstraint(this.solver.fragmentState.maybeWidened(base), this.solver.varProducer.thisVar(t.fun));
        };
        if ((0, constraintvars_1.isObjectPropertyVarObj)(base)) {
            if (src)
                this.solver.addSubsetConstraint(src, this.solver.varProducer.objPropVar(base, prop, ac));
            if (invokeSetters)
                if (!(base instanceof tokens_1.NativeObjectToken) && prop !== "prototype") {
                    this.solver.addForAllAncestorsConstraint(base, listeners_1.TokenListener.ASSIGN_ANCESTORS, { n: node, s: prop }, (anc) => {
                        (0, assert_1.default)((0, constraintvars_1.isObjectPropertyVarObj)(anc));
                        const setter = this.solver.varProducer.objPropVar(anc, prop, "set");
                        this.solver.addForAllTokensConstraint(setter, listeners_1.TokenListener.ASSIGN_SETTER, { n: node, s: prop }, writeToSetter);
                        this.solver.addForAllTokensConstraint(setter, listeners_1.TokenListener.ASSIGN_SETTER_THIS, { t: base }, bindSetterThis);
                    });
                }
            if (base instanceof tokens_1.NativeObjectToken && (base.moduleInfo || base.name === "globalThis"))
                this.solver.fragmentState.registerEscapingToExternal(src, escapeNode);
            if (base instanceof tokens_1.NativeObjectToken && base.name === "module" && prop === "exports")
                this.solver.addSubsetConstraint(src, this.solver.varProducer.objPropVar(this.moduleSpecialNatives.get("exports"), "default", ac));
        }
        else if (lVar && base instanceof tokens_1.AccessPathToken) {
            this.solver.addAccessPath(new accesspaths_1.PropertyAccessPath(lVar, prop), this.solver.varProducer.nodeVar(escapeNode), base.ap);
            this.solver.fragmentState.registerEscapingToExternal(src, escapeNode);
        }
    }
    requireModule(str, resultVar, path) {
        const f = this.solver.fragmentState;
        const reexport = (0, types_1.isExportDeclaration)(path.node);
        let m;
        if (module_1.default.isBuiltin(str)) {
            if (!reexport) {
                this.solver.addAccessPath(accesspaths_1.UnknownAccessPath.instance, resultVar);
            }
            else
                f.warnUnsupported(path.node, `Ignoring re-export from built-in module '${str}'`);
        }
        else {
            try {
                const filepath = (0, files_1.requireResolve)(str, this.file, path.node, f);
                if (filepath) {
                    m = this.a.reachedFile(filepath, this.moduleInfo);
                    const fp = path.getFunctionParent()?.node;
                    const from = fp ? this.a.functionInfos.get(fp) : this.moduleInfo;
                    const to = this.a.moduleInfosByPath.get(filepath);
                    f.registerRequireEdge(from, to);
                    if (!reexport) {
                        this.solver.addSubsetConstraint(this.solver.varProducer.objPropVar(this.a.canonicalizeToken(new tokens_1.NativeObjectToken("module", m)), "exports"), resultVar);
                    }
                }
            }
            catch {
                if (options_1.options.ignoreUnresolved || options_1.options.ignoreDependencies) {
                    if (logger_1.default.isVerboseEnabled())
                        logger_1.default.verbose(`Ignoring unresolved module '${str}' at ${(0, util_1.locationToStringWithFile)(path.node.loc)}`);
                }
                else if ((0, asthelpers_1.isInTryBlockOrBranch)(path))
                    f.warn(`Unable to resolve conditionally loaded module '${str}'`, path.node);
                else
                    f.error(`Unable to resolve module '${str}'`, path.node);
                if (!"./#".includes(str[0]))
                    m = (0, util_1.getOrSet)(this.a.dummyModuleInfos, str, () => new infos_1.DummyModuleInfo(str));
            }
            if (m) {
                const analyzed = m instanceof infos_1.ModuleInfo && m.isIncluded;
                if (!analyzed || options_1.options.vulnerabilities) {
                    const s = (0, infos_1.normalizeModuleName)(str);
                    const tracked = options_1.options.trackedModules && options_1.options.trackedModules.find(e => micromatch_1.default.isMatch(m.getOfficialName(), e) || micromatch_1.default.isMatch(s, e));
                    this.solver.addAccessPath(tracked ? new accesspaths_1.ModuleAccessPath(m, s) : accesspaths_1.IgnoredAccessPath.instance, resultVar);
                }
                f.registerRequireCall(path.node, this.a.getEnclosingFunctionOrModule(path, this.moduleInfo), m);
            }
        }
        return m;
    }
    assign(src, dst, path) {
        const vp = this.solver.varProducer;
        while ((0, types_1.isParenthesizedExpression)(dst))
            dst = dst.expression;
        if ((0, types_1.isIdentifier)(dst)) {
            const lVar = vp.identVar(dst, path);
            this.solver.addSubsetConstraint(src, lVar);
            if (lVar instanceof constraintvars_1.NodeVar && lVar.node.loc.unbound) {
                this.solver.addSubsetConstraint(src, this.solver.varProducer.objPropVar(this.globalSpecialNatives.get("globalThis"), dst.name));
            }
        }
        else if ((0, types_1.isMemberExpression)(dst) || (0, types_1.isOptionalMemberExpression)(dst)) {
            const lVar = this.expVar(dst.object, path);
            const prop = (0, asthelpers_1.getProperty)(dst);
            const enclosing = this.a.getEnclosingFunctionOrModule(path, this.moduleInfo);
            const assignRequireExtensions = (t) => {
                if (t instanceof tokens_1.NativeObjectToken && t.name === "require.extensions")
                    this.solver.addForAllTokensConstraint(src, listeners_1.TokenListener.ASSIGN_REQUIRE_EXTENSIONS, path.node, (ft) => this.invokeExternalCallback(ft, path.node, enclosing));
            };
            if (prop !== undefined) {
                this.solver.addForAllTokensConstraint(lVar, listeners_1.TokenListener.ASSIGN_MEMBER_BASE, dst, (t) => {
                    this.writeProperty(src, lVar, t, prop, dst, enclosing, path.node);
                    assignRequireExtensions(t);
                });
            }
            else {
                this.solver.collectDynamicPropertyWrite(lVar);
                this.solver.fragmentState.registerEscapingFromModule(src);
                if (src)
                    this.solver.addForAllTokensConstraint(lVar, listeners_1.TokenListener.ASSIGN_DYNAMIC_BASE, dst, (t) => {
                        if (t instanceof tokens_1.ArrayToken) {
                            this.solver.addSubsetConstraint(src, this.solver.varProducer.arrayUnknownVar(t));
                        }
                        else if (!(t instanceof tokens_1.AccessPathToken)) {
                            if (logger_1.default.isInfoEnabled())
                                this.solver.fragmentState.registerUnhandledDynamicPropertyWrite(path.node, src, options_1.options.warningsUnsupported && logger_1.default.isVerboseEnabled() ? path.getSource() : undefined);
                        }
                        assignRequireExtensions(t);
                    });
            }
        }
        else if ((0, types_1.isAssignmentPattern)(dst))
            this.assign(src, dst.left, path);
        else if ((0, types_1.isObjectPattern)(dst)) {
            const matched = new Set();
            for (const p of dst.properties)
                if ((0, types_1.isRestElement)(p)) {
                    const t = this.newObjectToken(p);
                    this.solver.addForAllTokensConstraint(src, listeners_1.TokenListener.ASSIGN_OBJECT_PATTERN_REST, p, (t2) => {
                        if (t2 instanceof tokens_1.AllocationSiteToken || t2 instanceof tokens_1.FunctionToken || t2 instanceof tokens_1.NativeObjectToken || t2 instanceof tokens_1.PackageObjectToken) {
                            this.solver.addForAllObjectPropertiesConstraint(t2, listeners_1.TokenListener.ASSIGN_OBJECT_PATTERN_REST_PROPERTIES, p, (prop) => {
                                if (!matched.has(prop))
                                    this.solver.addSubsetConstraint(this.solver.varProducer.objPropVar(t2, prop), this.solver.varProducer.objPropVar(t, prop));
                            });
                        }
                    });
                    this.solver.addTokenConstraint(t, vp.nodeVar(p));
                    this.assign(vp.nodeVar(p), p.argument, path);
                }
                else {
                    const prop = (0, asthelpers_1.getKey)(p);
                    if (prop) {
                        matched.add(prop);
                        this.readProperty(src, prop, vp.nodeVar(p), p, this.a.getEnclosingFunctionOrModule(path, this.moduleInfo));
                        if (!(0, types_1.isLVal)(p.value))
                            assert_1.default.fail(`Unexpected expression ${p.value.type}, expected LVal at ${(0, util_1.locationToStringWithFile)(p.value.loc)}`);
                        this.assign(vp.nodeVar(p), p.value, path);
                    }
                }
        }
        else if ((0, types_1.isArrayPattern)(dst)) {
            for (const [i, p] of dst.elements.entries())
                if (p)
                    if ((0, types_1.isRestElement)(p)) {
                        const t = this.newArrayToken(p);
                        this.solver.addForAllTokensConstraint(src, listeners_1.TokenListener.ASSIGN_ARRAY_PATTERN_REST, p, (t2) => {
                            if (t2 instanceof tokens_1.ArrayToken) {
                                this.solver.addForAllArrayEntriesConstraint(t2, listeners_1.TokenListener.ASSIGN_ARRAY_PATTERN_REST_ARRAY, p, (prop) => {
                                    const newprop = parseInt(prop) - i;
                                    if (newprop >= 0)
                                        this.solver.addSubsetConstraint(this.solver.varProducer.objPropVar(t2, prop), this.solver.varProducer.objPropVar(t, String(newprop)));
                                });
                                this.solver.addSubsetConstraint(this.solver.varProducer.arrayUnknownVar(t2), this.solver.varProducer.arrayUnknownVar(t));
                            }
                        });
                        this.solver.addTokenConstraint(t, vp.nodeVar(p));
                        this.assign(vp.nodeVar(p), p.argument, path);
                    }
                    else {
                        this.readProperty(src, String(i), vp.nodeVar(p), p, this.a.getEnclosingFunctionOrModule(path, this.moduleInfo));
                        this.assign(vp.nodeVar(p), p, path);
                    }
        }
        else if ((0, types_1.isTSParameterProperty)(dst))
            this.assign(src, dst.parameter, path);
        else {
            if (!(0, types_1.isRestElement)(dst))
                assert_1.default.fail(`Unexpected LVal type ${dst.type} at ${(0, util_1.locationToStringWithFile)(dst.loc)}`);
            this.assign(vp.nodeVar(dst), dst.argument, path);
        }
    }
    readIteratorValue(src, dst, node) {
        this.solver.addForAllTokensConstraint(src, listeners_1.TokenListener.READ_ITERATOR_VALUE, node, (t) => {
            const vp = this.solver.varProducer;
            if (t instanceof tokens_1.AllocationSiteToken)
                switch (t.kind) {
                    case "Array":
                        this.solver.addSubsetConstraint(vp.arrayAllVar(t), dst);
                        break;
                    case "Set":
                        this.solver.addSubsetConstraint(vp.objPropVar(t, ecmascript_1.SET_VALUES), dst);
                        break;
                    case "Map":
                        const pair = this.newArrayToken(node);
                        this.solver.addTokenConstraint(pair, dst);
                        this.solver.addSubsetConstraint(vp.objPropVar(t, ecmascript_1.MAP_KEYS), vp.objPropVar(pair, "0"));
                        this.solver.addSubsetConstraint(vp.objPropVar(t, ecmascript_1.MAP_VALUES), vp.objPropVar(pair, "1"));
                        break;
                    case "Iterator":
                        this.solver.addSubsetConstraint(vp.objPropVar(t, "value"), dst);
                        break;
                }
        });
    }
    newObjectToken(n) {
        if (options_1.options.alloc) {
            const t = this.a.canonicalizeToken(new tokens_1.ObjectToken(n));
            if (!this.solver.fragmentState.widened.has(t)) {
                this.solver.addInherits(t, this.globalSpecialNatives.get(ecmascript_1.OBJECT_PROTOTYPE));
                return t;
            }
        }
        return this.packageObjectToken;
    }
    newPrototypeToken(fun) {
        const t = this.a.canonicalizeToken(new tokens_1.PrototypeToken(fun));
        this.solver.addInherits(t, this.globalSpecialNatives.get(ecmascript_1.FUNCTION_PROTOTYPE));
        return t;
    }
    newArrayToken(n) {
        const t = this.a.canonicalizeToken(new tokens_1.ArrayToken(n));
        this.solver.addInherits(t, this.globalSpecialNatives.get(ecmascript_1.ARRAY_PROTOTYPE));
        return t;
    }
    newClassToken(n) {
        const t = this.a.canonicalizeToken(new tokens_1.ClassToken(n));
        this.solver.addInherits(t, this.globalSpecialNatives.get(ecmascript_1.FUNCTION_PROTOTYPE));
        return t;
    }
    newFunctionToken(fun) {
        const t = this.a.canonicalizeToken(new tokens_1.FunctionToken(fun));
        this.solver.addInherits(t, this.globalSpecialNatives.get(ecmascript_1.FUNCTION_PROTOTYPE));
        return t;
    }
    newRegExpToken() {
        const t = this.a.canonicalizeToken(new tokens_1.PackageObjectToken(this.packageInfo, "RegExp"));
        this.solver.addInherits(t, this.globalSpecialNatives.get(ecmascript_1.REGEXP_PROTOTYPE));
        return t;
    }
    newPromiseToken(n) {
        const t = this.a.canonicalizeToken(new tokens_1.AllocationSiteToken("Promise", n));
        this.solver.addInherits(t, this.globalSpecialNatives.get(ecmascript_1.PROMISE_PROTOTYPE));
        return t;
    }
    awaitPromise(arg, res, node) {
        if (!arg || !res)
            return;
        this.solver.addForAllTokensConstraint(arg, listeners_1.TokenListener.AWAIT, node, (t) => {
            if (t instanceof tokens_1.AllocationSiteToken && t.kind === "Promise")
                this.solver.addSubsetConstraint(this.solver.varProducer.objPropVar(t, ecmascript_1.PROMISE_FULFILLED_VALUES), res);
            else
                this.solver.addTokenConstraint(t, res);
        });
    }
}
exports.Operations = Operations;
//# sourceMappingURL=operations.js.map