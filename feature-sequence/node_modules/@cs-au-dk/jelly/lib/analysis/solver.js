"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AbortedException = void 0;
const constraintvars_1 = require("./constraintvars");
const logger_1 = __importStar(require("../misc/logger"));
const tokens_1 = require("./tokens");
const globalstate_1 = require("./globalstate");
const util_1 = require("../misc/util");
const assert_1 = __importDefault(require("assert"));
const accesspaths_1 = require("./accesspaths");
const types_1 = require("@babel/types");
const fragmentstate_1 = require("./fragmentstate");
const listeners_1 = require("./listeners");
const scc_1 = require("../misc/scc");
const options_1 = require("../options");
const timer_1 = __importDefault(require("../misc/timer"));
const promises_1 = require("timers/promises");
const memory_1 = require("../misc/memory");
const extras_1 = require("../parsing/extras");
const diagnostics_1 = __importDefault(require("./diagnostics"));
const ecmascript_1 = require("../natives/ecmascript");
class AbortedException extends Error {
}
exports.AbortedException = AbortedException;
class Solver {
    globalState = new globalstate_1.GlobalState;
    fragmentState = new fragmentstate_1.FragmentState(this);
    get varProducer() {
        return this.fragmentState.varProducer;
    }
    unprocessedTokens = new Map;
    nodesWithNewEdges = new Set;
    restored = new Set;
    listeners = new Map;
    diagnostics = new diagnostics_1.default;
    abort;
    fixpointIterationsThrottled = 0;
    constructor(abort) {
        this.abort = abort;
    }
    updateDiagnostics() {
        const a = this.globalState;
        const f = this.fragmentState;
        const d = this.diagnostics;
        d.functions = a.functionInfos.size;
        d.vars = f.getNumberOfVarsWithTokens();
        d.listeners = [
            f.tokenListeners, f.packageNeighborListeners,
            f.arrayEntriesListeners, f.objectPropertiesListeners,
        ].reduce((acc, l) => acc + (0, util_1.mapMapSize)(l), 0);
        d.tokens = f.numberOfTokens;
        d.subsetEdges = f.numberOfSubsetEdges;
        d.functionToFunctionEdges = f.numberOfFunctionToFunctionEdges;
        d.callToFunctionEdges = f.numberOfCallToFunctionEdges;
        d.uniqueTokens = a.canonicalTokens.size;
        d.maxMemoryUsage = Math.max(d.maxMemoryUsage, (0, memory_1.getMemoryUsage)());
        d.unhandledDynamicPropertyWrites = f.unhandledDynamicPropertyWrites.size;
        d.unhandledDynamicPropertyReads = f.unhandledDynamicPropertyReads.size;
    }
    addTokenConstraint(t, to) {
        if (to === undefined)
            return;
        if (logger_1.default.isDebugEnabled())
            logger_1.default.debug(`Adding constraint ${t} \u2208 ${to}`);
        this.addToken(t, this.fragmentState.getRepresentative(to));
    }
    enqueueListenerCall(la) {
        this.fragmentState.postponedListenerCalls.push(la);
    }
    addToken(t, toRep) {
        const f = this.fragmentState;
        if (f.addToken(t, toRep)) {
            if (logger_1.default.isVerboseEnabled())
                (0, assert_1.default)(!f.redirections.has(toRep));
            f.vars.add(toRep);
            this.tokenAdded(toRep, t);
            return true;
        }
        return false;
    }
    addTokens(ts, toRep, propagate = true) {
        const f = this.fragmentState;
        f.vars.add(toRep);
        let ws = undefined;
        for (const t of f.addTokens(ts, toRep)) {
            if (propagate)
                ws = this.tokenAdded(toRep, t, ws);
        }
    }
    replaceTokens(m) {
        const f = this.fragmentState;
        for (const [v, ts, size] of f.getAllVarsAndTokens()) {
            const r = new Set();
            let any = false;
            let ws = undefined;
            for (const t of ts) {
                const q = t instanceof tokens_1.ObjectToken && m.get(t);
                if (q) {
                    if (!(Array.isArray(ts) ? ts.includes(q) : ts.has(q)) && !r.has(q))
                        ws = this.tokenAdded(v, q, ws);
                    r.add(q);
                    any = true;
                }
                else
                    r.add(t);
            }
            if (any)
                f.replaceTokens(v, r, size);
        }
    }
    tokenAdded(toRep, t, ws) {
        if (logger_1.default.isDebugEnabled())
            logger_1.default.debug(`Added token ${t} to ${toRep}`);
        (ws ??= (0, util_1.mapGetArray)(this.unprocessedTokens, toRep)).push(t);
        this.diagnostics.unprocessedTokensSize++;
        if (this.diagnostics.unprocessedTokensSize % 100 === 0)
            this.printDiagnostics();
        return ws;
    }
    addAccessPath(ap, to, subap) {
        if (!to)
            return;
        const abstractProp = ap instanceof accesspaths_1.PropertyAccessPath && !(subap instanceof accesspaths_1.ModuleAccessPath && ap.prop === "default") && options_1.patternProperties && !options_1.patternProperties.has(ap.prop);
        const ap2 = this.globalState.canonicalizeAccessPath(subap instanceof accesspaths_1.IgnoredAccessPath || (subap instanceof accesspaths_1.UnknownAccessPath && (ap instanceof accesspaths_1.CallResultAccessPath || ap instanceof accesspaths_1.ComponentAccessPath || abstractProp)) ? subap :
            abstractProp ? new accesspaths_1.PropertyAccessPath(ap.base, "?") : ap);
        if (logger_1.default.isDebugEnabled())
            logger_1.default.debug(`Adding access path ${ap2}${ap2 !== ap ? ` (${ap})` : ""} at ${to}${subap ? ` (sub-expression access path: ${subap})` : ""}`);
        const f = this.fragmentState;
        const asn = to instanceof constraintvars_1.NodeVar && (0, types_1.isAssignmentExpression)(to.node);
        if (!asn)
            this.addToken(f.a.canonicalizeToken(new tokens_1.AccessPathToken(ap2)), f.getRepresentative(to));
        const t = to instanceof constraintvars_1.IntermediateVar && to.label === "import" ? to.node : to instanceof constraintvars_1.NodeVar ? to.node : undefined;
        if (t !== undefined) {
            if (ap2 instanceof accesspaths_1.ModuleAccessPath)
                (0, util_1.mapGetSet)(f.moduleAccessPaths, ap2).add(t);
            else if (ap2 instanceof accesspaths_1.PropertyAccessPath)
                (0, util_1.mapGetMap)((0, util_1.mapGetMap)(asn ? f.propertyWriteAccessPaths : f.propertyReadAccessPaths, subap), ap2.prop).set(t, { bp: ap2, sub: ap2.base });
            else if (ap2 instanceof accesspaths_1.CallResultAccessPath)
                (0, util_1.mapGetMap)(f.callResultAccessPaths, subap).set(t, { bp: ap2, sub: ap2.caller });
            else if (ap2 instanceof accesspaths_1.ComponentAccessPath)
                (0, util_1.mapGetMap)(f.componentAccessPaths, subap).set(t, { bp: ap2, sub: ap2.component });
            else if (!(ap2 instanceof accesspaths_1.UnknownAccessPath || ap2 instanceof accesspaths_1.IgnoredAccessPath))
                assert_1.default.fail("Unexpected AccessPath");
        }
    }
    printDiagnostics() {
        if (options_1.options.printProgress && options_1.options.tty && logger_1.isTTY && !options_1.options.logfile && logger_1.default.level === "info") {
            const d = new Date().getTime();
            if (d > this.diagnostics.lastPrintDiagnosticsTime + 100) {
                this.diagnostics.lastPrintDiagnosticsTime = d;
                const a = this.globalState;
                const f = this.fragmentState;
                (0, logger_1.writeStdOut)(`Packages: ${a.packageInfos.size}, modules: ${a.moduleInfos.size}, call edges: ${f.numberOfFunctionToFunctionEdges}, ` +
                    (options_1.options.diagnostics ? `vars: ${f.getNumberOfVarsWithTokens()}, tokens: ${f.numberOfTokens}, subsets: ${f.numberOfSubsetEdges}, round: ${this.diagnostics.fixpointRound}, ` : "") +
                    `iterations: ${this.diagnostics.iterations}, worklist: ${this.diagnostics.unprocessedTokensSize}` +
                    (options_1.options.diagnostics ? `, listeners: ${f.postponedListenerCalls.length}` : ""));
                f.a.timeoutTimer.checkTimeout();
            }
        }
    }
    addSubsetConstraint(from, to) {
        if (from === undefined || to === undefined)
            return;
        if (logger_1.default.isDebugEnabled())
            logger_1.default.debug(`Adding constraint ${from} \u2286 ${to}`);
        const f = this.fragmentState;
        this.addSubsetEdge(f.getRepresentative(from), f.getRepresentative(to));
    }
    addSubsetEdge(fromRep, toRep, propagate = true) {
        if (fromRep !== toRep) {
            const f = this.fragmentState;
            const s = (0, util_1.mapGetSet)(f.subsetEdges, fromRep);
            if (!s.has(toRep)) {
                s.add(toRep);
                f.numberOfSubsetEdges++;
                (0, util_1.mapGetSet)(f.reverseSubsetEdges, toRep).add(fromRep);
                if (logger_1.default.isVerboseEnabled())
                    (0, assert_1.default)(!f.redirections.has(fromRep) && !f.redirections.has(toRep));
                f.vars.add(fromRep);
                f.vars.add(toRep);
                if (propagate) {
                    const [size, ts] = this.fragmentState.getTokensSize(fromRep);
                    if (size > 0) {
                        if (logger_1.default.isDebugEnabled())
                            logger_1.default.debug(`Worklist size: ${this.diagnostics.unprocessedTokensSize}, propagating ${size} token${size !== 1 ? "s" : ""} from ${fromRep}`);
                        this.addTokens(ts, toRep);
                        this.incrementIterations();
                    }
                    this.nodesWithNewEdges.add(fromRep);
                }
            }
        }
    }
    getNodeHash(n) {
        const nid = n[extras_1.JELLY_NODE_ID];
        (0, assert_1.default)(nid !== undefined);
        let id = (BigInt(nid) << 32n);
        const h = n.loc && n.loc.module?.hash;
        if (h)
            id += BigInt(h);
        return id;
    }
    checkListenerIDCollision(id, key) {
        const x = this.listeners.get(id);
        if (x) {
            if (x.l !== key.l || x.n !== key.n || x.t !== key.t || x.s !== key.s) {
                const format = (x) => `${listeners_1.TokenListener[x.l]} ${x.t ?? ""} ${x.s || ""} ${x.n ? `at ${(0, util_1.locationToStringWithFileAndEnd)(x.n.loc)}` : ""}`;
                logger_1.default.error(`Error: Hash collision in getListenerID: ${format(x)} != ${format(key)}`);
            }
        }
        else
            this.listeners.set(id, key);
    }
    getListenerID(key) {
        let id = 0n;
        if (key.t) {
            (0, assert_1.default)(key.t.hash !== undefined);
            id += BigInt(key.t.hash);
        }
        if (key.n)
            id += this.getNodeHash(key.n);
        if (key.s)
            id ^= BigInt((0, util_1.strHash)(key.s));
        id = (id << 16n) | BigInt(key.l);
        this.checkListenerIDCollision(id, key);
        return id;
    }
    addForAllTokensConstraint(v, key, opts, listener) {
        if (v === undefined)
            return;
        const f = this.fragmentState;
        const vRep = f.getRepresentative(v);
        const lkey = { l: key, ...((0, types_1.isNode)(opts) ? { n: opts } : opts) };
        if (logger_1.default.isDebugEnabled())
            logger_1.default.debug(`Adding universally quantified constraint #${listeners_1.TokenListener[key]} to ${vRep} at ${lkey.n ? (0, util_1.locationToStringWithFileAndEnd)(lkey.n.loc) : lkey.t}`);
        this.addForAllTokensConstraintPrivate(vRep, this.getListenerID(lkey), listener);
    }
    addForAllTokensConstraintPrivate(vRep, id, listener) {
        const f = this.fragmentState;
        const m = (0, util_1.mapGetMap)(f.tokenListeners, vRep);
        if (!m.has(id)) {
            for (const t of f.getTokens(vRep))
                this.callTokenListener(id, listener, t);
            m.set(id, listener);
        }
        f.vars.add(vRep);
    }
    callTokenListener(id, listener, t) {
        const s = (0, util_1.mapGetSet)(this.fragmentState.listenersProcessed, id);
        if (!s.has(t)) {
            s.add(t);
            this.enqueueListenerCall([listener, t]);
            this.diagnostics.tokenListenerNotifications++;
        }
    }
    addForAllPackageNeighborsConstraint(k, opts, listener) {
        if (logger_1.default.isDebugEnabled())
            logger_1.default.debug(`Adding package neighbor constraint to ${k}`);
        const id = this.getListenerID({ l: listeners_1.TokenListener.PACKAGE_NEIGHBORS, ...opts });
        const m = this.runPackageNeighborsListener(k, id, listener);
        if (m) {
            m.set(id, listener);
        }
    }
    runPackageNeighborsListener(k, id, listener) {
        const f = this.fragmentState;
        const m = (0, util_1.mapGetMap)(f.packageNeighborListeners, k);
        if (!m.has(id)) {
            const qs = f.packageNeighbors.get(k);
            if (qs)
                for (const q of qs) {
                    this.enqueueListenerCall([listener, q]);
                    this.diagnostics.packageNeighborListenerNotifications++;
                }
            return m;
        }
        else
            return false;
    }
    addPackageNeighbor(k1, k2, propagate = true) {
        if (options_1.options.readNeighbors) {
            this.addPackageNeighborPrivate(k1, k2, propagate);
            this.addPackageNeighborPrivate(k2, k1, propagate);
        }
    }
    addPackageNeighborPrivate(k, neighbor, propagate = true) {
        const f = this.fragmentState;
        const s = (0, util_1.mapGetSet)(f.packageNeighbors, k);
        if (!s.has(neighbor)) {
            s.add(neighbor);
            if (propagate) {
                const ts = f.packageNeighborListeners.get(k);
                if (ts)
                    for (const listener of ts.values()) {
                        this.enqueueListenerCall([listener, neighbor]);
                        this.diagnostics.packageNeighborListenerNotifications++;
                    }
            }
        }
    }
    addForAllAncestorsConstraint(t, key, opts, listener) {
        if (logger_1.default.isDebugEnabled())
            logger_1.default.debug(`Adding ancestors constraint to ${t} ${opts.n ? `at ${(0, util_1.nodeToString)(opts.n)}` : `${listeners_1.TokenListener[key]} ${opts.s}`}`);
        const id = this.getListenerID({ ...opts, l: key, t });
        this.callTokenListener(id, listener, t);
        this.addForAllTokensConstraintPrivate(this.fragmentState.getRepresentative(this.varProducer.ancestorsVar(t)), id, listener);
    }
    addInherits(child, parent) {
        if (child === parent)
            return;
        const f = this.fragmentState;
        if (logger_1.default.isDebugEnabled())
            logger_1.default.debug(`Adding inheritance relation ${child} -> ${parent}`);
        const dst = f.getRepresentative(f.varProducer.objPropVar(child, (0, ecmascript_1.INTERNAL_PROTOTYPE)()));
        if (parent instanceof tokens_1.Token)
            this.addToken(parent, dst);
        else
            this.addSubsetEdge(f.getRepresentative(parent), dst);
    }
    addForAllArrayEntriesConstraint(t, key, n, listener) {
        if (logger_1.default.isDebugEnabled())
            logger_1.default.debug(`Adding array entries constraint #${listeners_1.TokenListener[key]} to ${t} at ${(0, util_1.locationToStringWithFileAndEnd)(n.loc)}`);
        const id = this.getListenerID({ l: key, n });
        const m = this.runArrayEntriesListener(t, id, listener);
        if (m) {
            m.set(id, listener);
        }
    }
    runArrayEntriesListener(t, id, listener) {
        const f = this.fragmentState;
        const m = (0, util_1.mapGetMap)(f.arrayEntriesListeners, t);
        if (!m.has(id)) {
            const ps = f.arrayEntries.get(t);
            if (ps)
                for (const p of ps) {
                    this.enqueueListenerCall([listener, p]);
                    this.diagnostics.arrayEntriesListenerNotifications++;
                }
            return m;
        }
        else
            return false;
    }
    addArrayEntry(a, prop, propagate = true) {
        if (!(0, util_1.isArrayIndex)(prop))
            return;
        const f = this.fragmentState;
        const ps = (0, util_1.mapGetSet)(f.arrayEntries, a);
        if (!ps.has(prop)) {
            if (logger_1.default.isDebugEnabled())
                logger_1.default.debug(`Adding array entry ${a}[${prop}]`);
            ps.add(prop);
            if (propagate) {
                const ts = f.arrayEntriesListeners.get(a);
                if (ts)
                    for (const listener of ts.values()) {
                        this.enqueueListenerCall([listener, prop]);
                        this.diagnostics.arrayEntriesListenerNotifications++;
                    }
            }
            this.addSubsetEdge(f.getRepresentative(f.varProducer.objPropVar(a, prop)), f.getRepresentative(f.varProducer.arrayAllVar(a)), propagate);
        }
    }
    addForAllObjectPropertiesConstraint(t, key, n, listener) {
        if (logger_1.default.isDebugEnabled())
            logger_1.default.debug(`Adding object properties constraint #${listeners_1.TokenListener[key]} to ${t} at ${(0, util_1.locationToStringWithFileAndEnd)(n.loc)}`);
        const id = this.getListenerID({ l: key, n });
        const m = this.runObjectPropertiesListener(t, id, listener);
        if (m) {
            m.set(id, listener);
        }
    }
    runObjectPropertiesListener(t, id, listener) {
        const f = this.fragmentState;
        const m = (0, util_1.mapGetMap)(f.objectPropertiesListeners, t);
        if (!m.has(id)) {
            const ps = f.objectProperties.get(t);
            if (ps)
                for (const p of ps)
                    if (!(0, ecmascript_1.isInternalProperty)(p)) {
                        this.enqueueListenerCall([listener, p]);
                        this.diagnostics.objectPropertiesListenerNotifications++;
                    }
            return m;
        }
        else
            return false;
    }
    addObjectProperty(a, prop, propagate = true) {
        const f = this.fragmentState;
        const ps = (0, util_1.mapGetSet)(f.objectProperties, a);
        if (!ps.has(prop)) {
            if (logger_1.default.isDebugEnabled())
                logger_1.default.debug(`Adding object property ${a}.${prop}`);
            ps.add(prop);
            if (propagate && !(0, ecmascript_1.isInternalProperty)(prop)) {
                const ts = f.objectPropertiesListeners.get(a);
                if (ts)
                    for (const listener of ts.values()) {
                        this.enqueueListenerCall([listener, prop]);
                        this.diagnostics.objectPropertiesListenerNotifications++;
                    }
            }
            if (a instanceof tokens_1.ArrayToken && prop === ecmascript_1.ARRAY_UNKNOWN)
                this.addSubsetEdge(f.getRepresentative(f.varProducer.arrayUnknownVar(a)), f.getRepresentative(f.varProducer.arrayAllVar(a)), propagate);
            if (prop === (0, ecmascript_1.INTERNAL_PROTOTYPE)()) {
                this.addForAllTokensConstraint(f.varProducer.objPropVar(a, prop), listeners_1.TokenListener.ANCESTORS, { t: a }, (b) => {
                    if ((0, constraintvars_1.isObjectPropertyVarObj)(b)) {
                        const aVar = this.varProducer.ancestorsVar(a);
                        this.addTokenConstraint(b, aVar);
                        this.addSubsetConstraint(this.varProducer.ancestorsVar(b), aVar);
                    }
                });
            }
        }
    }
    collectPropertyRead(typ, result, base, pck, prop, node, enclosing) {
        if (typ === "read" && result && base)
            this.fragmentState.maybeEmptyPropertyReads.push({ typ, result, base, pck, prop });
        else if (typ === "call" && base && prop)
            this.fragmentState.maybeEmptyPropertyReads.push({ typ, base, prop });
        if (base && prop && prop !== "prototype")
            this.fragmentState.propertyReads.add({ base, prop, node, enclosing });
    }
    collectDynamicPropertyWrite(base) {
        if (base)
            this.fragmentState.dynamicPropertyWrites.add(base);
    }
    redirect(v, rep) {
        const f = this.fragmentState;
        (0, assert_1.default)(f.vars.has(v) && f.vars.has(rep));
        if (v === rep)
            return;
        (0, assert_1.default)(f.isRepresentative(v) && f.isRepresentative(rep));
        (0, assert_1.default)(f.getRepresentative(v) === v && f.getRepresentative(rep) === rep);
        if (logger_1.default.isDebugEnabled())
            logger_1.default.debug(`Redirecting ${v} to ${rep}`);
        f.redirections.set(v, rep);
        this.nodesWithNewEdges.delete(v);
        this.processTokens(v);
        const [size, has] = this.fragmentState.getSizeAndHas(v);
        this.fragmentState.deleteVar(v);
        f.numberOfTokens -= size;
        const rts = new Set;
        for (const t of f.getTokens(rep))
            if (!has(t))
                rts.add(t);
        const repOut = (0, util_1.mapGetSet)(f.subsetEdges, rep);
        const repIn = (0, util_1.mapGetSet)(f.reverseSubsetEdges, rep);
        const vOut = f.subsetEdges.get(v);
        if (vOut) {
            for (const w of vOut) {
                if (w !== rep) {
                    const qs = f.reverseSubsetEdges.get(w);
                    (0, assert_1.default)(qs, "Subset edges empty");
                    qs.delete(v);
                    if (!repOut.has(w)) {
                        repOut.add(w);
                        qs.add(rep);
                        f.numberOfSubsetEdges++;
                    }
                    this.addTokens(rts, w);
                }
            }
            f.numberOfSubsetEdges -= vOut.size;
            f.subsetEdges.delete(v);
        }
        const vIn = f.reverseSubsetEdges.get(v);
        if (vIn) {
            for (const w of vIn)
                if (w !== rep) {
                    const qs = f.subsetEdges.get(w);
                    (0, assert_1.default)(qs, "Subset edges empty");
                    qs.delete(v);
                    if (!repIn.has(w)) {
                        repIn.add(w);
                        qs.add(rep);
                        f.numberOfSubsetEdges++;
                    }
                }
            f.numberOfSubsetEdges -= vIn.size;
            f.reverseSubsetEdges.delete(v);
        }
        repOut.delete(v);
        repIn.delete(v);
        if (repOut.size === 0)
            f.subsetEdges.delete(rep);
        if (repIn.size === 0)
            f.reverseSubsetEdges.delete(rep);
        const tr = f.tokenListeners.get(v);
        if (tr) {
            const qr = (0, util_1.mapGetMap)(f.tokenListeners, rep);
            for (const [k, listener] of tr)
                if (!qr.has(k)) {
                    qr.set(k, listener);
                    for (const t of rts)
                        this.callTokenListener(k, listener, t);
                }
            f.tokenListeners.delete(v);
        }
        (0, assert_1.default)(!this.unprocessedTokens.has(v));
        f.vars.delete(v);
    }
    processTokens(v) {
        const ts = this.unprocessedTokens.get(v);
        if (ts) {
            if (logger_1.default.isDebugEnabled())
                logger_1.default.debug(`Worklist size: ${this.diagnostics.unprocessedTokensSize}, propagating ${ts.length} token${ts.length !== 1 ? "s" : ""} from ${v}`);
            this.unprocessedTokens.delete(v);
            this.diagnostics.unprocessedTokensSize -= ts.length;
            const f = this.fragmentState;
            (0, assert_1.default)(f.vars.has(v));
            const s = f.subsetEdges.get(v);
            if (s) {
                for (const to of s)
                    this.addTokens(ts, to);
                this.incrementIterations();
            }
            const tr = f.tokenListeners.get(v);
            if (tr)
                for (const t of ts)
                    for (const [id, listener] of tr)
                        this.callTokenListener(id, listener, t);
        }
    }
    incrementIterations() {
        this.diagnostics.iterations++;
        if (this.diagnostics.iterations % 100 === 0) {
            this.globalState.timeoutTimer.checkTimeout();
            this.printDiagnostics();
        }
    }
    async propagate() {
        if (logger_1.default.isDebugEnabled())
            logger_1.default.debug("Processing constraints until fixpoint...");
        const f = this.fragmentState;
        f.a.timeoutTimer.checkTimeout();
        await this.checkAbort();
        if (logger_1.default.isVerboseEnabled())
            logger_1.default.verbose(`Propagating (${this.unprocessedTokens.size}, ${this.nodesWithNewEdges.size}, ${this.restored.size}, ${f.postponedListenerCalls.length})`);
        let round = 0;
        while (this.unprocessedTokens.size > 0 || this.nodesWithNewEdges.size > 0 || this.restored.size > 0 || f.postponedListenerCalls.length > 0) {
            round++;
            this.diagnostics.fixpointRound = round;
            if (logger_1.default.isVerboseEnabled())
                logger_1.default.verbose(`Fixpoint round: ${round} (call edges: ${f.numberOfFunctionToFunctionEdges}, vars: ${f.getNumberOfVarsWithTokens()}, tokens: ${f.numberOfTokens}, subsets: ${f.numberOfSubsetEdges})`);
            if (options_1.options.maxRounds !== undefined && round > options_1.options.maxRounds) {
                f.warn("Fixpoint round limit reached, aborting propagation");
                this.diagnostics.roundLimitReached++;
                this.diagnostics.unprocessedTokensSize = 0;
                this.unprocessedTokens.clear();
                this.nodesWithNewEdges.clear();
                this.restored.clear();
                f.postponedListenerCalls.length = 0;
                break;
            }
            if (this.unprocessedTokens.size > 0 || this.nodesWithNewEdges.size > 0 || this.restored.size > 0) {
                if (options_1.options.cycleElimination) {
                    const nodes = new Set();
                    for (const v of [...this.nodesWithNewEdges, ...this.restored])
                        nodes.add(f.getRepresentative(v));
                    if (nodes.size > 0) {
                        const timer1 = new timer_1.default();
                        const [reps, repmap] = (0, scc_1.nuutila)(nodes, (v) => f.subsetEdges.get(v));
                        if (logger_1.default.isVerboseEnabled())
                            logger_1.default.verbose(`Cycle detection nodes: ${f.vars.size}, roots: ${nodes.size}, components: ${reps.length}`);
                        for (const [v, rep] of repmap)
                            this.redirect(v, rep);
                        this.diagnostics.totalCycleEliminationTime += timer1.elapsedCPU();
                        this.diagnostics.totalCycleEliminationRuns++;
                        const timer2 = new timer_1.default();
                        if (logger_1.default.isVerboseEnabled())
                            logger_1.default.verbose(`Processing ${this.diagnostics.unprocessedTokensSize} new token${this.diagnostics.unprocessedTokensSize !== 1 ? "s" : ""}`);
                        for (let i = reps.length - 1; i >= 0; i--) {
                            const v = reps[i];
                            this.processTokens(v);
                            await this.checkAbort(true);
                        }
                        this.diagnostics.totalPropagationTime += timer2.elapsedCPU();
                        this.nodesWithNewEdges.clear();
                        this.restored.clear();
                    }
                    const timer3 = new timer_1.default();
                    for (const v of this.unprocessedTokens.keys())
                        this.processTokens(v);
                    this.diagnostics.totalPropagationTime += timer3.elapsedCPU();
                }
                else {
                    if (logger_1.default.isVerboseEnabled())
                        logger_1.default.verbose(`Processing ${this.diagnostics.unprocessedTokensSize} new token${this.diagnostics.unprocessedTokensSize !== 1 ? "s" : ""}`);
                    const timer = new timer_1.default();
                    this.nodesWithNewEdges.clear();
                    this.restored.clear();
                    for (const v of this.unprocessedTokens.keys()) {
                        this.processTokens(v);
                        await this.checkAbort(true);
                    }
                    this.diagnostics.totalPropagationTime += timer.elapsedCPU();
                }
            }
            if (this.unprocessedTokens.size !== 0 || this.diagnostics.unprocessedTokensSize !== 0 || this.nodesWithNewEdges.size !== 0 || this.restored.size !== 0)
                assert_1.default.fail(`worklist non-empty: unprocessedTokens.size: ${this.unprocessedTokens.size}, unprocessedTokensSize: ${this.diagnostics.unprocessedTokensSize}, nodesWithNewEdges.size: ${this.nodesWithNewEdges.size}, restored.size: ${this.restored.size}`);
            if (logger_1.default.isVerboseEnabled())
                logger_1.default.verbose(`Processing listener calls: ${f.postponedListenerCalls.length}`);
            if (f.postponedListenerCalls.length > 0) {
                const timer = new timer_1.default();
                this.diagnostics.listenerNotificationRounds++;
                const calls = Array.from(f.postponedListenerCalls);
                f.postponedListenerCalls.length = 0;
                let count = 0;
                for (const [fun, arg] of calls) {
                    fun(arg);
                    if (++count % 100 === 0) {
                        f.a.timeoutTimer.checkTimeout();
                        this.printDiagnostics();
                    }
                }
                this.diagnostics.totalListenerCallTime += timer.elapsedCPU();
            }
        }
        if (this.diagnostics.unprocessedTokensSize !== 0)
            assert_1.default.fail(`unprocessedTokensSize non-zero after propagate: ${this.diagnostics.unprocessedTokensSize}`);
    }
    async checkAbort(throttle = false) {
        if (this.abort) {
            if (throttle) {
                if (this.diagnostics.iterations < this.fixpointIterationsThrottled + 1000)
                    return;
                this.fixpointIterationsThrottled = this.diagnostics.iterations;
            }
            await (0, promises_1.setImmediate)();
            if (this.abort()) {
                logger_1.default.verbose("Abort signal received");
                throw new AbortedException();
            }
        }
    }
    prepare() {
        this.fragmentState = new fragmentstate_1.FragmentState(this);
    }
    merge(_s, propagate) {
        const s = _s;
        const f = this.fragmentState;
        (0, util_1.mapSetAddAll)(s.listenersProcessed, f.listenersProcessed);
        for (const [v, rep] of s.redirections) {
            const fRep = f.getRepresentative(v);
            const repRep = f.getRepresentative(rep);
            this.addSubsetEdge(fRep, repRep);
            this.redirect(fRep, repRep);
        }
        for (const [t, m] of s.arrayEntriesListeners)
            for (const [id, listener] of m)
                this.runArrayEntriesListener(t, id, listener);
        for (const [t, m] of s.objectPropertiesListeners)
            for (const [id, listener] of m)
                this.runObjectPropertiesListener(t, id, listener);
        for (const [k, m] of s.packageNeighborListeners)
            for (const [n, listener] of m)
                this.runPackageNeighborsListener(k, n, listener);
        for (const v of s.vars) {
            const vRep = f.getRepresentative(v);
            f.vars.add(vRep);
            const ntr = s.tokenListeners.get(v);
            const svs = s.subsetEdges.get(v);
            if (propagate) {
                if (ntr)
                    for (const t of f.getTokens(vRep))
                        for (const [id, listener] of ntr)
                            this.callTokenListener(id, listener, t);
                if (svs)
                    for (const v2 of svs)
                        this.addTokens(f.getTokens(vRep), f.getRepresentative(v2));
            }
            this.addTokens(s.getTokens(v), vRep, propagate);
            if (ntr)
                for (const [id, listener] of ntr)
                    (0, util_1.mapGetMap)(f.tokenListeners, vRep).set(id, listener);
            if (svs) {
                const fvs = (0, util_1.mapGetSet)(f.subsetEdges, vRep);
                for (const v2 of svs) {
                    const v2Rep = f.getRepresentative(v2);
                    if (!fvs.has(v2Rep) && vRep !== v2Rep) {
                        fvs.add(v2Rep);
                        f.numberOfSubsetEdges++;
                        (0, util_1.mapGetSet)(f.reverseSubsetEdges, v2Rep).add(vRep);
                        this.restored.add(v2Rep);
                    }
                }
            }
        }
        for (const [t, props] of s.objectProperties)
            for (const prop of props)
                this.addObjectProperty(t, prop, propagate);
        for (const [t, entries] of s.arrayEntries)
            for (const entry of entries)
                this.addArrayEntry(t, entry, propagate);
        (0, util_1.mapMapSetAll)(s.arrayEntriesListeners, f.arrayEntriesListeners);
        (0, util_1.mapMapSetAll)(s.objectPropertiesListeners, f.objectPropertiesListeners);
        for (const [k, ns] of s.packageNeighbors)
            for (const n of ns)
                this.addPackageNeighbor(k, n, propagate);
        (0, util_1.mapMapSetAll)(s.packageNeighborListeners, f.packageNeighborListeners);
        (0, util_1.mapSetAddAll)(s.requireGraph, f.requireGraph);
        (0, util_1.mapSetAddAll)(s.functionToFunction, f.functionToFunction);
        (0, util_1.mapSetAddAll)(s.callToFunction, f.callToFunction);
        (0, util_1.mapSetAddAll)(s.callToFunctionOrModule, f.callToFunctionOrModule);
        (0, util_1.setAll)(s.callToContainingFunction, f.callToContainingFunction);
        (0, util_1.mapSetAddAll)(s.callToModule, f.callToModule);
        f.numberOfFunctionToFunctionEdges += s.numberOfFunctionToFunctionEdges;
        f.numberOfCallToFunctionEdges += s.numberOfCallToFunctionEdges;
        (0, util_1.addAll)(s.functionsWithArguments, f.functionsWithArguments);
        (0, util_1.addAll)(s.functionsWithThis, f.functionsWithThis);
        f.artificialFunctions.push(...s.artificialFunctions);
        (0, util_1.addAll)(s.callLocations, f.callLocations);
        (0, util_1.setAll)(s.maybeEmptyMethodCalls, f.maybeEmptyMethodCalls);
        (0, util_1.addAll)(s.nativeCallLocations, f.nativeCallLocations);
        (0, util_1.addAll)(s.externalCallLocations, f.externalCallLocations);
        (0, util_1.addAll)(s.callsWithUnusedResult, f.callsWithUnusedResult);
        (0, util_1.addAll)(s.callsWithResultMaybeUsedAsPromise, f.callsWithResultMaybeUsedAsPromise);
        (0, util_1.mapSetAddAll)(s.functionParameters, f.functionParameters);
        (0, util_1.addAll)(s.invokedExpressions, f.invokedExpressions);
        (0, util_1.addAll)(s.maybeEscapingFromModule, f.maybeEscapingFromModule);
        (0, util_1.addAll)(s.widened, f.widened);
        (0, util_1.mapSetAddAll)(s.maybeEscapingToExternal, f.maybeEscapingToExternal);
        (0, util_1.setAll)(s.unhandledDynamicPropertyWrites, f.unhandledDynamicPropertyWrites);
        (0, util_1.addAll)(s.unhandledDynamicPropertyReads, f.unhandledDynamicPropertyReads);
        (0, util_1.addAllMapHybridSet)(s.errors, f.errors);
        (0, util_1.addAllMapHybridSet)(s.warnings, f.warnings);
        (0, util_1.addAllMapHybridSet)(s.warningsUnsupported, f.warningsUnsupported);
        (0, util_1.mapSetAddAll)(s.moduleAccessPaths, f.moduleAccessPaths);
        (0, util_1.mapMapMapSetAll)(s.propertyReadAccessPaths, f.propertyReadAccessPaths);
        (0, util_1.mapMapMapSetAll)(s.propertyWriteAccessPaths, f.propertyWriteAccessPaths);
        (0, util_1.mapMapSetAll)(s.callResultAccessPaths, f.callResultAccessPaths);
        (0, util_1.mapMapSetAll)(s.componentAccessPaths, f.componentAccessPaths);
        (0, util_1.mapArrayPushAll)(s.importDeclRefs, f.importDeclRefs);
        (0, util_1.addAll)(s.propertyReads, f.propertyReads);
        f.maybeEmptyPropertyReads.push(...s.maybeEmptyPropertyReads);
        (0, util_1.addAll)(s.dynamicPropertyWrites, f.dynamicPropertyWrites);
        this.printDiagnostics();
    }
}
exports.default = Solver;
//# sourceMappingURL=solver.js.map