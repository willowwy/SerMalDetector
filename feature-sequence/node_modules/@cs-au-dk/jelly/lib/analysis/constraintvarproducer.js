"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ConstraintVarProducer = void 0;
const types_1 = require("@babel/types");
const constraintvars_1 = require("./constraintvars");
const tokens_1 = require("./tokens");
const infos_1 = require("./infos");
const assert_1 = __importDefault(require("assert"));
const ecmascript_1 = require("../natives/ecmascript");
class ConstraintVarProducer {
    s;
    f;
    a;
    constructor(s, f) {
        this.s = s;
        this.f = f;
        this.a = f.a;
    }
    expVar(exp, path) {
        while ((0, types_1.isParenthesizedExpression)(exp))
            exp = exp.expression;
        if ((0, types_1.isIdentifier)(exp) || (0, types_1.isJSXIdentifier)(exp)) {
            const id = this.identVar(exp, path);
            if (id instanceof constraintvars_1.NodeVar && exp.name === "undefined" && id.node?.loc?.native === "%ecmascript")
                return undefined;
            return id;
        }
        else if ((0, types_1.isNumericLiteral)(exp) || (0, types_1.isBigIntLiteral)(exp) || (0, types_1.isNullLiteral)(exp) || (0, types_1.isBooleanLiteral)(exp) ||
            (0, types_1.isStringLiteral)(exp) ||
            (0, types_1.isUnaryExpression)(exp) || (0, types_1.isBinaryExpression)(exp) || (0, types_1.isUpdateExpression)(exp))
            return undefined;
        return this.nodeVar(exp);
    }
    identVar(id, path) {
        const binding = path.scope.getBinding(id.name);
        let d;
        if (binding) {
            d = binding.identifier;
        }
        else {
            if (id.name === "arguments") {
                const fun = this.f.registerArguments(path);
                return fun ? this.argumentsVar(fun) : this.nodeVar(id);
            }
            else {
                const ps = path.scope.getProgramParent();
                d = ps.getBinding(id.name)?.identifier;
                if (!d)
                    assert_1.default.fail(`No binding for identifier ${id.name}, should be set by preprocessAst`);
            }
        }
        return this.nodeVar(d);
    }
    objPropVar(obj, prop, accessor = "normal") {
        if (obj instanceof tokens_1.ObjectToken && this.f.widened.has(obj))
            return this.packagePropVar(obj.getPackageInfo(), prop, accessor);
        return this.a.canonicalizeVar(constraintvars_1.ObjectPropertyVar.make(this.s, obj, prop, accessor));
    }
    arrayUnknownVar(arr) {
        return this.objPropVar(arr, ecmascript_1.ARRAY_UNKNOWN);
    }
    arrayAllVar(arr) {
        return this.objPropVar(arr, ecmascript_1.ARRAY_ALL);
    }
    packagePropVar(pck, prop, accessor = "normal") {
        return this.objPropVar(this.a.canonicalizeToken(new tokens_1.PackageObjectToken(pck instanceof infos_1.PackageInfo ? pck : this.a.getModuleInfo(pck).packageInfo)), prop, accessor);
    }
    returnVar(fun) {
        return this.a.canonicalizeVar(new constraintvars_1.FunctionReturnVar(fun));
    }
    thisVar(fun) {
        return this.a.canonicalizeVar(new constraintvars_1.ThisVar(fun));
    }
    argumentsVar(fun) {
        return this.a.canonicalizeVar(new constraintvars_1.ArgumentsVar(fun));
    }
    intermediateVar(n, label) {
        return this.a.canonicalizeVar(new constraintvars_1.IntermediateVar(n, label));
    }
    nodeVar(n) {
        return n !== undefined ? this.a.canonicalizeVar(new constraintvars_1.NodeVar(n)) : undefined;
    }
    ancestorsVar(t) {
        if (t instanceof tokens_1.ObjectToken && this.f.widened.has(t))
            t = this.a.canonicalizeToken(new tokens_1.PackageObjectToken(t.getPackageInfo()));
        return this.a.canonicalizeVar(new constraintvars_1.AncestorsVar(t));
    }
    readResultVar(t, prop) {
        if (t instanceof tokens_1.ObjectToken && this.f.widened.has(t))
            t = this.a.canonicalizeToken(new tokens_1.PackageObjectToken(t.getPackageInfo()));
        return this.a.canonicalizeVar(new constraintvars_1.ReadResultVar(t, prop));
    }
}
exports.ConstraintVarProducer = ConstraintVarProducer;
//# sourceMappingURL=constraintvarproducer.js.map