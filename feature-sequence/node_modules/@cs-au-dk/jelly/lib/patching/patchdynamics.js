"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.patchDynamics = void 0;
const options_1 = require("../options");
const tokens_1 = require("../analysis/tokens");
const util_1 = require("../misc/util");
const logger_1 = __importDefault(require("../misc/logger"));
const accesspaths_1 = require("../analysis/accesspaths");
const constraintvars_1 = require("../analysis/constraintvars");
const assert_1 = __importDefault(require("assert"));
function patchDynamics(solver) {
    if (!options_1.options.patchDynamics)
        return false;
    const f = solver.fragmentState;
    const dyns = new Set();
    for (const v of f.dynamicPropertyWrites)
        (0, util_1.addAll)(f.getTokens(f.getRepresentative(v)), dyns);
    const toPatch = [];
    f.maybeEmptyPropertyReads = f.maybeEmptyPropertyReads.filter(e => {
        const { typ, base } = e;
        const bs = f.getTokens(f.getRepresentative(base));
        if (![...bs].some(t => dyns.has(t)))
            return true;
        if (typ === "read") {
            const [size] = f.getTokensSize(f.getRepresentative(e.result));
            if (size > 0)
                return false;
        }
        else {
            typ;
            for (const t of bs)
                if ((0, constraintvars_1.isObjectPropertyVarObj)(t)) {
                    const callees = f.varProducer.readResultVar(t, e.prop);
                    const [size] = f.getTokensSize(f.getRepresentative(callees));
                    if (size > 0)
                        return false;
                }
                else {
                    (0, assert_1.default)(t instanceof tokens_1.AccessPathToken);
                    return false;
                }
        }
        toPatch.push(e);
        return false;
    });
    for (const e of toPatch) {
        const { typ, base } = e;
        if (logger_1.default.isDebugEnabled())
            logger_1.default.debug(`Empty ${typ === "read" ? "object property read" : "method set"} with dynamic write to base object in ${base}`);
        solver.addAccessPath(accesspaths_1.UnknownAccessPath.instance, base);
        if (typ === "read")
            solver.addTokenConstraint(e.pck, e.result);
    }
    const count = toPatch.length;
    if (count > 0) {
        if (logger_1.default.isVerboseEnabled())
            logger_1.default.verbose(`${count} empty object property read${count === 1 ? "" : "s"} patched`);
        return true;
    }
    else
        return false;
}
exports.patchDynamics = patchDynamics;
//# sourceMappingURL=patchdynamics.js.map