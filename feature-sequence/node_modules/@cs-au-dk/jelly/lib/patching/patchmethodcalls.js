"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.patchMethodCalls = void 0;
const options_1 = require("../options");
const logger_1 = __importDefault(require("../misc/logger"));
const util_1 = require("../misc/util");
const constraintvars_1 = require("../analysis/constraintvars");
const tokens_1 = require("../analysis/tokens");
const IGNORED = new Set([
    "charAt", "charCodeAt", "codePointAt", "concat", "endsWith", "includes", "indexOf", "lastIndexOf",
    "localeCompare", "match", "matchAll", "normalize", "padEnd", "padStart", "repeat", "replace", "replaceAll",
    "search", "slice", "split", "startsWith", "substr", "substring", "toLocaleLowerCase", "toLocaleUpperCase", "toLowerCase",
    "toString", "toUpperCase", "trim", "trimEnd", "trimStart", "valueOf", "test", "exec",
    "toExponential", "toFixed", "toLocaleString", "toPrecision",
    "write",
]);
const PATCH_LIMIT = 25;
function patchMethodCalls(solver) {
    if (!options_1.options.patchMethodCalls)
        return false;
    const f = solver.fragmentState;
    const m = new Map();
    for (const v of [...f.vars, ...f.redirections.keys()])
        if (v instanceof constraintvars_1.ObjectPropertyVar &&
            v.accessor === "normal" &&
            !(v.obj instanceof tokens_1.NativeObjectToken) &&
            !(v.obj instanceof tokens_1.PackageObjectToken && !["Object", "Array", "Prototype"].includes(v.obj.kind)) &&
            !IGNORED.has(v.prop))
            (0, util_1.mapGetArray)(m, v.prop).push(v);
    let patched = 0, failed = 0;
    const cache = new Map();
    for (const [node, { prop, baseVar, calleeVar }] of f.maybeEmptyMethodCalls) {
        if (IGNORED.has(prop))
            continue;
        const ts = f.getTokens(f.getRepresentative(baseVar));
        let empty = true;
        for (const t of ts)
            if (!(t instanceof tokens_1.AccessPathToken)) {
                empty = false;
                break;
            }
        if (empty) {
            let any = false;
            const vs = m.get(prop);
            if (vs) {
                const pck = node.loc?.module?.packageInfo;
                if (pck) {
                    const tokens = (0, util_1.getOrSet)(cache, prop, () => {
                        const ts = new Map();
                        build: for (const v of vs)
                            for (const t of f.getTokens(f.getRepresentative(v))) {
                                if ((t instanceof tokens_1.FunctionToken || t instanceof tokens_1.AccessPathToken) && !ts.has(t)) {
                                    if (ts.size === PATCH_LIMIT) {
                                        ts.clear();
                                        break build;
                                    }
                                    ts.set(t, v);
                                }
                            }
                        return ts;
                    });
                    if (tokens.size) {
                        log(() => `Call to method named '${prop}' with empty base at ${(0, util_1.locationToStringWithFileAndEnd)(node.loc)}`);
                        any = true;
                        for (const [t, v] of tokens) {
                            log(() => `  Adding ${t} from ${v}`);
                            solver.addTokenConstraint(t, calleeVar);
                        }
                    }
                }
            }
            if (any)
                patched++;
            else {
                failed++;
                log(() => `Unable to patch call to method named '${prop}' with empty base at ${(0, util_1.locationToStringWithFileAndEnd)(node.loc)}`);
            }
        }
    }
    log(() => `Patched method calls with empty base: ${patched}, not patched: ${failed}`);
    f.maybeEmptyMethodCalls.clear();
    return patched > 0;
}
exports.patchMethodCalls = patchMethodCalls;
function log(s) {
    if (logger_1.default.isVerboseEnabled())
        logger_1.default.verbose(s());
}
//# sourceMappingURL=patchmethodcalls.js.map