"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.preprocessAst = exports.JELLY_NODE_ID = exports.isDummyConstructor = exports.replaceTypeScriptImportExportAssignmentsAndAddConstructors = void 0;
const types_1 = require("@babel/types");
const traverse_1 = __importDefault(require("@babel/traverse"));
const logger_1 = __importDefault(require("../misc/logger"));
const asthelpers_1 = require("../misc/asthelpers");
const assert_1 = __importDefault(require("assert"));
function replaceTypeScriptImportExportAssignmentsAndAddConstructors({ template }) {
    const moduleExportsDeclaration = template("module.exports = ASSIGNMENT;");
    const moduleImportsDeclaration = template("var ID = require(MODULE);");
    return {
        visitor: {
            TSExportAssignment(path) {
                path.replaceWith(moduleExportsDeclaration({
                    ASSIGNMENT: path.node.expression
                }));
            },
            TSImportEqualsDeclaration(path) {
                if (!path.node.isExport && path.node.importKind === "value" && (0, types_1.isTSExternalModuleReference)(path.node.moduleReference)) {
                    path.replaceWith(moduleImportsDeclaration({
                        ID: path.node.id,
                        MODULE: path.node.moduleReference.expression
                    }));
                    path.scope.registerDeclaration(path);
                }
            },
            Class(path) {
                for (const b of path.node.body.body)
                    if (((0, types_1.isClassMethod)(b) || (0, types_1.isClassPrivateMethod)(b)) && b.kind === "constructor")
                        return;
                let params, body;
                if (path.node.superClass) {
                    params = [
                        (0, types_1.identifier)("p1"),
                        (0, types_1.identifier)("p2"),
                        (0, types_1.identifier)("p3"),
                        (0, types_1.identifier)("p4"),
                        (0, types_1.identifier)("p5"),
                        (0, types_1.restElement)((0, types_1.identifier)("rest"))
                    ];
                    body = (0, types_1.blockStatement)([(0, types_1.expressionStatement)((0, types_1.callExpression)((0, types_1.super)(), [
                            (0, types_1.identifier)("p1"),
                            (0, types_1.identifier)("p2"),
                            (0, types_1.identifier)("p3"),
                            (0, types_1.identifier)("p4"),
                            (0, types_1.identifier)("p5"),
                            (0, types_1.spreadElement)((0, types_1.identifier)("rest"))
                        ]))]);
                }
                else {
                    params = [];
                    body = (0, types_1.blockStatement)([]);
                }
                const c = (0, types_1.classMethod)("constructor", (0, types_1.identifier)("constructor"), params, body);
                (0, types_1.addComment)(body, "leading", "JELLY_DEFAULT");
                path.get("body").unshiftContainer("body", c);
            }
        }
    };
}
exports.replaceTypeScriptImportExportAssignmentsAndAddConstructors = replaceTypeScriptImportExportAssignmentsAndAddConstructors;
function isDummyConstructor(c) {
    return (0, types_1.isClassMethod)(c) && c.kind === "constructor" && c.body.leadingComments?.[0].value == "JELLY_DEFAULT";
}
exports.isDummyConstructor = isDummyConstructor;
exports.JELLY_NODE_ID = Symbol("JELLY_NODE_ID");
function preprocessAst(ast, file, module, globals, globalsHidden) {
    let nextNodeID = 0;
    function register(n) {
        n[exports.JELLY_NODE_ID] = nextNodeID++;
    }
    for (const n of [...globals, ...globalsHidden])
        register(n);
    (0, traverse_1.default)(ast, {
        Program(path) {
            const decls = globals.filter(d => path.scope.getBinding(d.name) === undefined)
                .map(id => {
                const d = (0, types_1.variableDeclarator)(id);
                d.loc = id.loc;
                return d;
            });
            const d = (0, types_1.variableDeclaration)("var", decls);
            d.loc = { start: { line: 0, column: 0 }, end: { line: 0, column: 0 }, native: "%ecmascript" };
            path.scope.registerDeclaration(path.unshiftContainer("body", d)[0]);
            path.stop();
        }
    });
    (0, traverse_1.default)(ast, {
        enter(path) {
            const n = path.node;
            if (n[exports.JELLY_NODE_ID] === undefined)
                register(n);
            if (!n.loc) {
                let p = path;
                while (!p.node.loc) {
                    (0, assert_1.default)(p.parentPath);
                    p = p.parentPath;
                }
                n.loc = { start: p?.node.loc?.start, end: p?.node.loc?.end, nodeIndex: n[exports.JELLY_NODE_ID] };
            }
            if (n.loc.module === undefined && n.loc.native === undefined)
                n.loc.module = module;
            if ((((0, types_1.isClassMethod)(n) || (0, types_1.isClassPrivateMethod)(n)) && n.kind === "constructor") ||
                ((0, types_1.isCallExpression)(n) && (0, types_1.isSuper)(n.callee) && isDummyConstructor(path.findParent(p => (0, types_1.isClassMethod)(p.node))?.node))) {
                const cls = (0, asthelpers_1.getClass)(path);
                (0, assert_1.default)(cls);
                n.loc = cls.loc;
            }
            else if (((0, types_1.isClassMethod)(n) || (0, types_1.isClassPrivateMethod)(n) || (0, types_1.isClassPrivateProperty)(n)) && n.static) {
                (0, assert_1.default)(n.loc && n.key.loc);
                n.loc.start = n.key.loc.start;
            }
            if (((0, types_1.isIdentifier)(n) || (0, types_1.isJSXIdentifier)(n)) &&
                n.name !== "arguments" && !path.scope.getBinding(n.name) &&
                !(((0, types_1.isMemberExpression)(path.parent) || (0, types_1.isOptionalMemberExpression)(path.parent) || (0, types_1.isJSXMemberExpression)(path.parent)) &&
                    path.parent.property === path.node) &&
                !((0, types_1.isObjectProperty)(path.parent) && path.parent.key === n) &&
                !((0, types_1.isObjectMethod)(path.parent) && path.parent.key === n) &&
                !((0, types_1.isClassProperty)(path.parent) && path.parent.key === n) &&
                !((0, types_1.isClassMethod)(path.parent) && path.parent.key === n) &&
                !(0, types_1.isImportSpecifier)(path.parent) &&
                !(0, types_1.isJSXAttribute)(path.parent)) {
                const ps = path.scope.getProgramParent();
                if (!ps.getBinding(n.name)?.identifier) {
                    const d = (0, types_1.identifier)(n.name);
                    d.loc = { start: { line: 0, column: 0 }, end: { line: 0, column: 0 }, module, unbound: true };
                    register(d);
                    ps.push({ id: d });
                    if (logger_1.default.isDebugEnabled())
                        logger_1.default.debug(`No binding for identifier ${n.name} (parent: ${path.parent.type}), creating one in program scope`);
                }
            }
        }
    });
}
exports.preprocessAst = preprocessAst;
//# sourceMappingURL=extras.js.map