"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.buildNatives = void 0;
const types_1 = require("@babel/types");
const tokens_1 = require("../analysis/tokens");
const ecmascript_1 = require("./ecmascript");
const nodejs_1 = require("./nodejs");
const options_1 = require("../options");
const logger_1 = __importDefault(require("../misc/logger"));
function buildNatives(solver, moduleInfo) {
    const globals = [];
    const globalsHidden = [];
    const moduleSpecialNatives = new Map;
    const globalSpecialNatives = new Map;
    const f = solver.fragmentState;
    const a = solver.globalState;
    const models = [ecmascript_1.ecmascriptModels, nodejs_1.nodejsModels];
    for (const m of models) {
        const moduleLoc = { start: { line: 0, column: 0 }, end: { line: 0, column: 0 }, module: moduleInfo, native: `%${m.name}` };
        const globalLoc = { start: { line: 0, column: 0 }, end: { line: 0, column: 0 }, native: `%${m.name}` };
        function defineGlobal(name, moduleSpecific = false, invoke, constr = false, hidden = false, init) {
            if (options_1.options.natives || m.name === "ecmascript" || (m.name === "nodejs" && ["exports", "module"].includes(name))) {
                let id = solver.globalState.canonicalGlobals.get(name);
                if (!id) {
                    id = (0, types_1.identifier)(name);
                    id.loc = (moduleSpecific ? moduleLoc : globalLoc);
                    if (!moduleSpecific)
                        solver.globalState.canonicalGlobals.set(name, id);
                }
                (hidden ? globalsHidden : globals).push(id);
                const t = init
                    ? init({ solver, moduleInfo, moduleSpecialNatives, globalSpecialNatives })
                    : a.canonicalizeToken(new tokens_1.NativeObjectToken(name, moduleSpecific ? moduleInfo : undefined, invoke, constr));
                solver.addTokenConstraint(t, f.varProducer.nodeVar(id));
                (moduleSpecific ? moduleSpecialNatives : globalSpecialNatives).set(name, t);
            }
        }
        function defineGlobalFunction(name, invoke, constr = false, hidden = false) {
            defineGlobal(name, undefined, invoke, constr, hidden);
        }
        function definePrototypeObject(name) {
            const t = a.canonicalizeToken(new tokens_1.NativeObjectToken(`${name}.prototype`));
            if (m.name === "ecmascript")
                globalSpecialNatives.set(t.name, t);
            if (options_1.options.natives || m.name === "ecmascript")
                solver.addTokenConstraint(t, f.varProducer.objPropVar(globalSpecialNatives.get(name), "prototype"));
            return t;
        }
        function defineField(x, nf) {
        }
        function defineStaticMethod(x, nf) {
            if (options_1.options.natives) {
                const t = a.canonicalizeToken(new tokens_1.NativeObjectToken(`${x.name}.${nf.name}`, undefined, nf.invoke));
                if (m.name === "ecmascript")
                    globalSpecialNatives.set(t.name, t);
                solver.addTokenConstraint(t, f.varProducer.objPropVar(globalSpecialNatives.get(x.name), nf.name));
            }
        }
        function defineMethod(x, nf, pro) {
            if (options_1.options.natives) {
                const t = a.canonicalizeToken(new tokens_1.NativeObjectToken(`${x.name}.prototype.${nf.name}`, undefined, nf.invoke));
                if (m.name === "ecmascript")
                    globalSpecialNatives.set(t.name, t);
                solver.addTokenConstraint(t, f.varProducer.objPropVar(pro, nf.name));
            }
        }
        if (logger_1.default.isVerboseEnabled())
            logger_1.default.verbose(`Adding ${m.name}`);
        if (m.params)
            for (const v of m.params)
                defineGlobal(v.name, true, undefined, undefined, undefined, v.init);
        if (m.variables)
            for (const v of m.variables)
                defineGlobal(v.name, undefined, undefined, undefined, undefined, v.init);
        for (const f of m.functions)
            defineGlobalFunction(f.name, f.invoke);
        for (const x of m.classes) {
            defineGlobalFunction(x.name, x.invoke, true, x.hidden);
            const pro = definePrototypeObject(x.name);
            if (x.fields)
                for (const v of x.fields)
                    defineField(x, v);
            if (x.staticMethods)
                for (const f of x.staticMethods)
                    defineStaticMethod(x, f);
            if (x.methods)
                for (const f of x.methods)
                    defineMethod(x, f, pro);
        }
    }
    for (const m of models)
        if (m.init) {
            if (logger_1.default.isVerboseEnabled())
                logger_1.default.verbose(`Running initialization for ${m.name}`);
            m.init({ solver, moduleInfo, moduleSpecialNatives, globalSpecialNatives });
        }
    if (logger_1.default.isVerboseEnabled())
        logger_1.default.verbose("Adding natives completed");
    return { globals, globalsHidden, moduleSpecialNatives, globalSpecialNatives };
}
exports.buildNatives = buildNatives;
//# sourceMappingURL=nativebuilder.js.map