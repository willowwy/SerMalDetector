"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.defineProperties = exports.prepareDefineProperties = exports.prepareDefineProperty = exports.assignProperties = exports.setPrototypeOf = exports.returnPrototypeOf = exports.returnPromiseIterator = exports.returnResolvedPromise = exports.callPromiseResolve = exports.callPromiseExecutor = exports.assignBaseArrayArrayValueToArray = exports.assignBaseArrayValueToArray = exports.assignIteratorMapValuePairs = exports.assignIteratorValuesToArrayValue = exports.assignIteratorValuesToProperty = exports.functionBind = exports.invokeCallApplyBound = exports.invokeCallApply = exports.invokeCallbackBound = exports.invokeCallback = exports.returnIterator = exports.returnUnknown = exports.returnToken = exports.newArray = exports.newPackageObject = exports.newObject = exports.returnArgument = exports.widenArgument = exports.returnPackageObject = exports.warnNativeUsed = exports.returnShuffledInplace = exports.returnShuffledArray = exports.returnArrayValue = exports.returnThisInPromise = exports.returnThis = exports.returnThisProperty = exports.assignParameterToArrayValue = exports.assignParameterToThisArrayValue = exports.assignParameterToThisProperty = void 0;
const types_1 = require("@babel/types");
const tokens_1 = require("../analysis/tokens");
const asthelpers_1 = require("../misc/asthelpers");
const ecmascript_1 = require("./ecmascript");
const listeners_1 = require("../analysis/listeners");
const assert_1 = __importDefault(require("assert"));
const constraintvars_1 = require("../analysis/constraintvars");
const accesspaths_1 = require("../analysis/accesspaths");
function assignParameterToThisProperty(param, prop, p) {
    if (p.path.node.arguments.length > param && p.base) {
        const arg = p.path.node.arguments[param];
        const argVar = (0, types_1.isExpression)(arg) ? p.solver.varProducer.expVar(arg, p.path) : undefined;
        if (argVar)
            p.solver.addSubsetConstraint(argVar, p.solver.varProducer.objPropVar(p.base, prop));
    }
}
exports.assignParameterToThisProperty = assignParameterToThisProperty;
function assignExpressionToArrayValue(from, t, p) {
    const argVar = p.solver.varProducer.expVar(from, p.path);
    if (argVar)
        p.solver.addSubsetConstraint(argVar, p.solver.varProducer.arrayUnknownVar(t));
}
function assignParameterToThisArrayValue(param, p) {
    if (p.path.node.arguments.length > param && p.base instanceof tokens_1.ArrayToken) {
        const arg = p.path.node.arguments[param];
        if ((0, types_1.isExpression)(arg))
            assignExpressionToArrayValue(arg, p.base, p);
    }
}
exports.assignParameterToThisArrayValue = assignParameterToThisArrayValue;
function assignParameterToArrayValue(param, t, p) {
    if (p.path.node.arguments.length > param) {
        const arg = p.path.node.arguments[param];
        if ((0, types_1.isExpression)(arg))
            assignExpressionToArrayValue(arg, t, p);
    }
}
exports.assignParameterToArrayValue = assignParameterToArrayValue;
function returnThisProperty(prop, p) {
    if (!(0, asthelpers_1.isParentExpressionStatement)(p.path) && p.base)
        p.solver.addSubsetConstraint(p.solver.varProducer.objPropVar(p.base, prop), p.solver.varProducer.nodeVar(p.path.node));
}
exports.returnThisProperty = returnThisProperty;
function returnThis(p) {
    if (!(0, asthelpers_1.isParentExpressionStatement)(p.path) && p.base)
        p.solver.addTokenConstraint(p.base, p.solver.varProducer.nodeVar(p.path.node));
}
exports.returnThis = returnThis;
function returnThisInPromise(p) {
    if (!(0, asthelpers_1.isParentExpressionStatement)(p.path) && p.base) {
        const promise = newObject("Promise", p.globalSpecialNatives.get(ecmascript_1.PROMISE_PROTOTYPE), p);
        p.solver.addTokenConstraint(p.base, p.solver.varProducer.objPropVar(promise, ecmascript_1.PROMISE_FULFILLED_VALUES));
        p.solver.addTokenConstraint(promise, p.solver.varProducer.nodeVar(p.path.node));
    }
}
exports.returnThisInPromise = returnThisInPromise;
function returnArrayValue(p) {
    const vp = p.solver.varProducer;
    if (!(0, asthelpers_1.isParentExpressionStatement)(p.path) && p.base instanceof tokens_1.ArrayToken)
        p.solver.addSubsetConstraint(vp.arrayAllVar(p.base), vp.nodeVar(p.path.node));
}
exports.returnArrayValue = returnArrayValue;
function returnShuffledArray(p) {
    if (!(0, asthelpers_1.isParentExpressionStatement)(p.path) && p.base) {
        const res = newArray(p);
        returnToken(res, p);
        if (p.base instanceof tokens_1.ArrayToken) {
            const resVar = p.solver.varProducer.arrayUnknownVar(res);
            p.solver.addSubsetConstraint(p.solver.varProducer.arrayAllVar(p.base), resVar);
        }
        return res;
    }
    else
        return undefined;
}
exports.returnShuffledArray = returnShuffledArray;
function returnShuffledInplace(p) {
    if (!(0, asthelpers_1.isParentExpressionStatement)(p.path) && p.base) {
        if (p.base instanceof tokens_1.ArrayToken)
            p.solver.addSubsetConstraint(p.solver.varProducer.arrayAllVar(p.base), p.solver.varProducer.arrayUnknownVar(p.base));
        p.solver.addTokenConstraint(p.base, p.solver.varProducer.nodeVar(p.path.node));
    }
}
exports.returnShuffledInplace = returnShuffledInplace;
function warnNativeUsed(name, p, extra) {
    p.solver.fragmentState.warnUnsupported(p.path.node, `Call to '${name}'${extra ? ` ${extra}` : ""}`);
}
exports.warnNativeUsed = warnNativeUsed;
function returnPackageObject(p, kind = "Object") {
    p.solver.addTokenConstraint(p.solver.globalState.canonicalizeToken(new tokens_1.PackageObjectToken(p.moduleInfo.packageInfo, kind)), p.solver.varProducer.expVar(p.path.node, p.path));
}
exports.returnPackageObject = returnPackageObject;
function widenArgument(arg, p) {
    if ((0, types_1.isExpression)(arg))
        p.solver.fragmentState.registerEscapingFromModule(p.solver.varProducer.expVar(arg, p.path));
}
exports.widenArgument = widenArgument;
function returnArgument(arg, p) {
    if ((0, types_1.isExpression)(arg))
        p.solver.addSubsetConstraint(p.solver.varProducer.expVar(arg, p.path), p.solver.varProducer.expVar(p.path.node, p.path));
}
exports.returnArgument = returnArgument;
function newObject(kind, proto, p) {
    const t = p.solver.globalState.canonicalizeToken(kind === "Object" ? new tokens_1.ObjectToken(p.path.node) :
        kind === "Array" ? new tokens_1.ArrayToken(p.path.node) :
            new tokens_1.AllocationSiteToken(kind, p.path.node));
    if (proto instanceof tokens_1.Token)
        p.solver.addInherits(t, proto);
    else {
        const pv = p.op.expVar(proto, p.path);
        if (pv !== undefined)
            p.solver.addInherits(t, pv);
    }
    return t;
}
exports.newObject = newObject;
function newPackageObject(kind, proto, p) {
    const t = p.solver.globalState.canonicalizeToken(new tokens_1.PackageObjectToken(p.moduleInfo.packageInfo, kind));
    p.solver.addInherits(t, proto);
    return t;
}
exports.newPackageObject = newPackageObject;
function newArray(p) {
    const a = p.solver.globalState;
    const t = a.canonicalizeToken(new tokens_1.ArrayToken(p.path.node));
    p.solver.addInherits(t, p.globalSpecialNatives.get(ecmascript_1.ARRAY_PROTOTYPE));
    return t;
}
exports.newArray = newArray;
function returnToken(t, p) {
    p.solver.addTokenConstraint(t, p.solver.varProducer.expVar(p.path.node, p.path));
}
exports.returnToken = returnToken;
function returnUnknown(p) {
    p.solver.addAccessPath(accesspaths_1.UnknownAccessPath.instance, p.solver.varProducer.expVar(p.path.node, p.path));
}
exports.returnUnknown = returnUnknown;
function returnIterator(kind, p) {
    if (!(0, asthelpers_1.isParentExpressionStatement)(p.path) && p.base) {
        const a = p.solver.globalState;
        const t = p.base;
        const vp = p.solver.varProducer;
        if (t instanceof tokens_1.AllocationSiteToken) {
            const iter = a.canonicalizeToken(new tokens_1.AllocationSiteToken("Iterator", t.allocSite));
            p.solver.addTokenConstraint(iter, vp.expVar(p.path.node, p.path));
            const iterNext = vp.objPropVar(iter, "next");
            p.solver.addTokenConstraint(p.globalSpecialNatives.get(ecmascript_1.GENERATOR_PROTOTYPE_NEXT), iterNext);
            const iterValue = vp.objPropVar(iter, "value");
            switch (kind) {
                case "ArrayKeys": {
                    if (t.kind !== "Array")
                        break;
                    break;
                }
                case "ArrayValues": {
                    if (t.kind !== "Array")
                        break;
                    p.solver.addSubsetConstraint(vp.arrayAllVar(t), iterValue);
                    break;
                }
                case "ArrayEntries": {
                    if (t.kind !== "Array")
                        break;
                    const pair = a.canonicalizeToken(new tokens_1.ArrayToken(p.path.node));
                    p.solver.addInherits(t, p.globalSpecialNatives.get(ecmascript_1.ARRAY_PROTOTYPE));
                    p.solver.addTokenConstraint(pair, iterValue);
                    const oneVar = vp.objPropVar(pair, "1");
                    p.solver.addSubsetConstraint(vp.arrayAllVar(t), oneVar);
                    break;
                }
                case "SetValues": {
                    if (t.kind !== "Set")
                        break;
                    p.solver.addSubsetConstraint(vp.objPropVar(t, ecmascript_1.SET_VALUES), iterValue);
                    break;
                }
                case "SetEntries": {
                    if (t.kind !== "Set")
                        break;
                    const pair = a.canonicalizeToken(new tokens_1.ArrayToken(p.path.node));
                    p.solver.addInherits(t, p.globalSpecialNatives.get(ecmascript_1.ARRAY_PROTOTYPE));
                    p.solver.addTokenConstraint(pair, iterValue);
                    p.solver.addSubsetConstraint(vp.objPropVar(t, ecmascript_1.SET_VALUES), vp.objPropVar(pair, "0"));
                    p.solver.addSubsetConstraint(vp.objPropVar(t, ecmascript_1.SET_VALUES), vp.objPropVar(pair, "1"));
                    break;
                }
                case "MapKeys": {
                    if (t.kind !== "Map")
                        break;
                    p.solver.addSubsetConstraint(vp.objPropVar(t, ecmascript_1.MAP_KEYS), iterValue);
                    break;
                }
                case "MapValues": {
                    if (t.kind !== "Map")
                        break;
                    p.solver.addSubsetConstraint(vp.objPropVar(t, ecmascript_1.MAP_VALUES), iterValue);
                    break;
                }
                case "MapEntries": {
                    if (t.kind !== "Map")
                        break;
                    const pair = a.canonicalizeToken(new tokens_1.ArrayToken(p.path.node));
                    p.solver.addInherits(t, p.globalSpecialNatives.get(ecmascript_1.ARRAY_PROTOTYPE));
                    p.solver.addTokenConstraint(pair, iterValue);
                    p.solver.addSubsetConstraint(vp.objPropVar(t, ecmascript_1.MAP_KEYS), vp.objPropVar(pair, "0"));
                    p.solver.addSubsetConstraint(vp.objPropVar(t, ecmascript_1.MAP_VALUES), vp.objPropVar(pair, "1"));
                    break;
                }
            }
        }
    }
}
exports.returnIterator = returnIterator;
function invokeCallback(kind, p, arg = 0, key = listeners_1.TokenListener.NATIVE_INVOKE_CALLBACK) {
    const args = p.path.node.arguments;
    if (args.length > arg) {
        const funarg = args[arg];
        const bt = p.base;
        if ((0, types_1.isExpression)(funarg) &&
            (bt instanceof tokens_1.AllocationSiteToken || bt instanceof tokens_1.PackageObjectToken)) {
            const funVar = p.solver.varProducer.expVar(funarg, p.path);
            p.solver.addForAllTokensConstraint(funVar, key, { n: funarg, t: bt, s: kind }, (ft) => {
                if (!(ft instanceof tokens_1.FunctionToken || ft instanceof tokens_1.AccessPathToken))
                    return;
                invokeCallbackBound(kind, p, bt, ft);
                if (ft instanceof tokens_1.AccessPathToken) {
                    p.solver.fragmentState.registerEscapingToExternal(funVar, funarg);
                }
            });
        }
    }
}
exports.invokeCallback = invokeCallback;
function invokeCallbackBound(kind, p, bt, ft) {
    const solver = p.solver;
    const f = solver.fragmentState;
    const vp = f.varProducer;
    const a = solver.globalState;
    const args = p.path.node.arguments;
    const arg1Var = (0, types_1.isExpression)(args[1]) ? vp.expVar(args[1], p.path) : undefined;
    const pResultVar = vp.expVar(p.path.node, p.path);
    const caller = a.getEnclosingFunctionOrModule(p.path, p.moduleInfo);
    const modelCall = (args, baseVar, resultVar) => {
        (0, assert_1.default)(ft instanceof tokens_1.FunctionToken);
        p.op.callFunctionTokenBound(ft, baseVar, caller, args, resultVar, false, p.path, { native: true });
    };
    const iVarKey = `NativeCallback(${kind},${bt},${ft})`;
    const iVar = (label) => vp.intermediateVar(p.path.node, `${iVarKey}: ${label}`);
    switch (kind) {
        case "Array.prototype.forEach":
        case "Array.prototype.every":
        case "Array.prototype.filter":
        case "Array.prototype.find":
        case "Array.prototype.findIndex":
        case "Array.prototype.flatMap":
        case "Array.prototype.map":
        case "Array.prototype.some": {
            let resultVar;
            switch (kind) {
                case "Array.prototype.map": {
                    const t = newArray(p);
                    resultVar = vp.arrayUnknownVar(t);
                    returnToken(t, p);
                    break;
                }
                case "Array.prototype.flatMap":
                    warnNativeUsed(kind, p, "(return value ignored)");
                    break;
            }
            if (ft instanceof tokens_1.FunctionToken)
                modelCall([bt instanceof tokens_1.ArrayToken ? vp.arrayAllVar(bt) : undefined, undefined, bt], arg1Var, resultVar);
            break;
        }
        case "Array.prototype.reduce":
        case "Array.prototype.reduceRight":
            if (ft instanceof tokens_1.FunctionToken) {
                const accVar = iVar("accumulator");
                if (args.length > 1) {
                    solver.addSubsetConstraint(arg1Var, accVar);
                    solver.addSubsetConstraint(arg1Var, pResultVar);
                }
                else if (args.length === 1 && bt instanceof tokens_1.ArrayToken) {
                    solver.addSubsetConstraint(vp.arrayUnknownVar(bt), accVar);
                    solver.addSubsetConstraint(vp.arrayUnknownVar(bt), pResultVar);
                    if (kind === "Array.prototype.reduce")
                        solver.addSubsetConstraint(vp.objPropVar(bt, "0"), accVar);
                    else
                        solver.addSubsetConstraint(vp.arrayAllVar(bt), accVar);
                    solver.addSubsetConstraint(vp.objPropVar(bt, "0"), pResultVar);
                }
                const retVar = vp.returnVar(ft.fun);
                solver.addSubsetConstraint(retVar, accVar);
                modelCall([accVar, bt instanceof tokens_1.ArrayToken ? vp.arrayAllVar(bt) : undefined, undefined, bt], undefined, pResultVar);
            }
            break;
        case "Array.prototype.sort":
            if (bt instanceof tokens_1.ArrayToken && ft instanceof tokens_1.FunctionToken) {
                const btVar = vp.arrayAllVar(bt);
                p.solver.addSubsetConstraint(btVar, vp.arrayUnknownVar(bt));
                modelCall([btVar, btVar]);
            }
            solver.addTokenConstraint(bt, pResultVar);
            break;
        case "Map.prototype.forEach":
            if (bt.kind === "Map" && ft instanceof tokens_1.FunctionToken)
                modelCall([vp.objPropVar(bt, ecmascript_1.MAP_VALUES), vp.objPropVar(bt, ecmascript_1.MAP_KEYS), bt], arg1Var);
            break;
        case "Set.prototype.forEach":
            if (bt.kind === "Set" && ft instanceof tokens_1.FunctionToken)
                modelCall([vp.objPropVar(bt, ecmascript_1.SET_VALUES), vp.objPropVar(bt, ecmascript_1.SET_VALUES), bt], arg1Var);
            break;
        case "Promise.prototype.then$onFulfilled":
        case "Promise.prototype.then$onRejected":
        case "Promise.prototype.catch$onRejected":
        case "Promise.prototype.finally$onFinally": {
            if (bt.kind !== "Promise")
                break;
            let prop, key;
            switch (kind) {
                case "Promise.prototype.then$onFulfilled":
                    prop = ecmascript_1.PROMISE_FULFILLED_VALUES;
                    key = listeners_1.TokenListener.CALL_PROMISE_ONFULFILLED;
                    break;
                case "Promise.prototype.then$onRejected":
                case "Promise.prototype.catch$onRejected":
                    prop = ecmascript_1.PROMISE_REJECTED_VALUES;
                    key = listeners_1.TokenListener.CALL_PROMISE_ONREJECTED;
                    break;
                case "Promise.prototype.finally$onFinally":
                    prop = undefined;
                    key = listeners_1.TokenListener.CALL_PROMISE_ONFINALLY;
                    break;
            }
            const thenPromise = newObject("Promise", p.globalSpecialNatives.get(ecmascript_1.PROMISE_PROTOTYPE), p);
            if (ft instanceof tokens_1.FunctionToken) {
                modelCall([prop !== undefined ? vp.objPropVar(bt, prop) : undefined]);
                solver.addForAllTokensConstraint(vp.returnVar(ft.fun), key, p.path.node, (t) => {
                    if (t instanceof tokens_1.AllocationSiteToken && t.kind === "Promise") {
                        if (kind !== "Promise.prototype.finally$onFinally")
                            solver.addSubsetConstraint(solver.varProducer.objPropVar(t, ecmascript_1.PROMISE_FULFILLED_VALUES), solver.varProducer.objPropVar(thenPromise, ecmascript_1.PROMISE_FULFILLED_VALUES));
                        solver.addSubsetConstraint(solver.varProducer.objPropVar(t, ecmascript_1.PROMISE_REJECTED_VALUES), solver.varProducer.objPropVar(thenPromise, ecmascript_1.PROMISE_REJECTED_VALUES));
                    }
                    else if (kind !== "Promise.prototype.finally$onFinally") {
                        solver.addTokenConstraint(t, solver.varProducer.objPropVar(thenPromise, ecmascript_1.PROMISE_FULFILLED_VALUES));
                    }
                });
            }
            if (kind === "Promise.prototype.catch$onRejected")
                solver.addSubsetConstraint(vp.objPropVar(bt, ecmascript_1.PROMISE_FULFILLED_VALUES), vp.objPropVar(thenPromise, ecmascript_1.PROMISE_FULFILLED_VALUES));
            else if (kind === "Promise.prototype.finally$onFinally") {
                solver.addSubsetConstraint(vp.objPropVar(bt, ecmascript_1.PROMISE_FULFILLED_VALUES), vp.objPropVar(thenPromise, ecmascript_1.PROMISE_FULFILLED_VALUES));
                solver.addSubsetConstraint(vp.objPropVar(bt, ecmascript_1.PROMISE_REJECTED_VALUES), vp.objPropVar(thenPromise, ecmascript_1.PROMISE_REJECTED_VALUES));
            }
            returnToken(thenPromise, p);
            break;
        }
        default:
            kind;
    }
}
exports.invokeCallbackBound = invokeCallbackBound;
function invokeCallApply(kind, p) {
    if (p.base instanceof tokens_1.FunctionToken || p.base instanceof tokens_1.NativeObjectToken)
        invokeCallApplyBound(kind, p, p.base);
}
exports.invokeCallApply = invokeCallApply;
function invokeCallApplyBound(kind, p, ft) {
    if (ft instanceof tokens_1.NativeObjectToken) {
        if (ft.invoke)
            warnNativeUsed(`${kind} with native function`, p);
        return;
    }
    const a = p.solver.globalState;
    const vp = p.solver.varProducer;
    const args = p.path.node.arguments;
    const basearg = args[0];
    const caller = a.getEnclosingFunctionOrModule(p.path, p.moduleInfo);
    let argVars = [];
    switch (kind) {
        case "Function.prototype.call":
            argVars = args.slice(1).map(arg => (0, types_1.isExpression)(arg) ? vp.expVar(arg, p.path) : undefined);
            break;
        case "Function.prototype.apply": {
            if (args.length >= 2 && (0, types_1.isExpression)(args[1])) {
                const escapes = ft.fun.loc.module !== p.moduleInfo;
                const argVar = vp.expVar(args[1], p.path);
                p.solver.addForAllTokensConstraint(argVar, listeners_1.TokenListener.NATIVE_INVOKE_CALL_APPLY2, ft.fun, (t) => {
                    if (t instanceof tokens_1.ArrayToken) {
                        p.solver.addForAllArrayEntriesConstraint(t, listeners_1.TokenListener.NATIVE_INVOKE_CALL_APPLY3, ft.fun, (prop) => {
                            const param = parseInt(prop);
                            if (param >= 0 && param < ft.fun.params.length && (0, types_1.isIdentifier)(ft.fun.params[param])) {
                                const opv = p.solver.varProducer.objPropVar(t, prop);
                                const paramVar = p.solver.varProducer.nodeVar(ft.fun.params[param]);
                                p.solver.addSubsetConstraint(opv, paramVar);
                            }
                            if (escapes) {
                                const opv = p.solver.varProducer.objPropVar(t, prop);
                                p.solver.fragmentState.registerEscapingFromModule(opv);
                            }
                        });
                        if (escapes) {
                            const unk = p.solver.varProducer.arrayUnknownVar(t);
                            p.solver.fragmentState.registerEscapingFromModule(unk);
                        }
                        for (const param of ft.fun.params)
                            if ((0, types_1.isIdentifier)(param)) {
                                const unk = p.solver.varProducer.arrayUnknownVar(t);
                                p.solver.addSubsetConstraint(unk, p.solver.varProducer.nodeVar(param));
                            }
                    }
                });
            }
            break;
        }
    }
    const baseVar = (0, types_1.isExpression)(basearg) ? vp.expVar(basearg, p.path) : undefined;
    const resultVar = vp.expVar(p.path.node, p.path);
    p.op.callFunctionTokenBound(ft, baseVar, caller, argVars, resultVar, false, p.path, { native: true });
}
exports.invokeCallApplyBound = invokeCallApplyBound;
function functionBind(p) {
    const args = p.path.node.arguments;
    const basearg = args[0];
    if (p.base instanceof tokens_1.FunctionToken) {
        if ((0, types_1.isExpression)(basearg)) {
            const baseVar = p.solver.varProducer.expVar(basearg, p.path);
            p.solver.addSubsetConstraint(baseVar, p.solver.varProducer.thisVar(p.base.fun));
        }
        p.solver.addTokenConstraint(p.base, p.solver.varProducer.expVar(p.path.node, p.path));
    }
    if (!args.every(arg => (0, types_1.isExpression)(arg)))
        warnNativeUsed("Function.prototype.bind", p, "with SpreadElement");
    if (args.length > 1)
        warnNativeUsed("Function.prototype.bind", p, "with multiple arguments");
}
exports.functionBind = functionBind;
function assignIteratorValuesToProperty(param, t, prop, p) {
    const arg = p.path.node.arguments[param];
    if ((0, types_1.isExpression)(arg)) {
        const src = p.op.expVar(arg, p.path);
        const dst = p.solver.varProducer.objPropVar(t, prop);
        p.op.readIteratorValue(src, dst, p.path.node);
    }
}
exports.assignIteratorValuesToProperty = assignIteratorValuesToProperty;
function assignIteratorValuesToArrayValue(param, t, p) {
    const arg = p.path.node.arguments[param];
    if ((0, types_1.isExpression)(arg)) {
        const src = p.op.expVar(arg, p.path);
        const dst = p.solver.varProducer.arrayUnknownVar(t);
        p.op.readIteratorValue(src, dst, p.path.node);
    }
}
exports.assignIteratorValuesToArrayValue = assignIteratorValuesToArrayValue;
function assignIteratorMapValuePairs(param, t, keys, values, p) {
    const arg = p.path.node.arguments[param];
    if ((0, types_1.isExpression)(arg)) {
        const src = p.op.expVar(arg, p.path);
        const dst = p.solver.varProducer.intermediateVar(p.path.node, "assignIteratorValuePairsToProperties");
        p.op.readIteratorValue(src, dst, p.path.node);
        p.solver.addForAllTokensConstraint(dst, listeners_1.TokenListener.NATIVE_8, p.path.node.arguments[param], (t2) => {
            if (t2 instanceof tokens_1.ArrayToken) {
                if (keys)
                    p.solver.addSubsetConstraint(p.solver.varProducer.objPropVar(t2, "0"), p.solver.varProducer.objPropVar(t, keys));
                p.solver.addSubsetConstraint(p.solver.varProducer.objPropVar(t2, "1"), p.solver.varProducer.objPropVar(t, values));
            }
        });
    }
}
exports.assignIteratorMapValuePairs = assignIteratorMapValuePairs;
function assignBaseArrayValueToArray(t, p) {
    if (p.base instanceof tokens_1.ArrayToken) {
        const dst = p.solver.varProducer.arrayUnknownVar(t);
        p.solver.addSubsetConstraint(p.solver.varProducer.arrayAllVar(p.base), dst);
    }
}
exports.assignBaseArrayValueToArray = assignBaseArrayValueToArray;
function assignBaseArrayArrayValueToArray(t, p) {
    if (p.base instanceof tokens_1.ArrayToken) {
        p.solver.addForAllTokensConstraint(p.solver.varProducer.arrayAllVar(p.base), listeners_1.TokenListener.NATIVE_11, { n: p.path.node, t }, (t2) => {
            if (t2 instanceof tokens_1.ArrayToken) {
                const dst = p.solver.varProducer.arrayUnknownVar(t);
                p.solver.addSubsetConstraint(p.solver.varProducer.arrayAllVar(t2), dst);
            }
        });
    }
}
exports.assignBaseArrayArrayValueToArray = assignBaseArrayArrayValueToArray;
function callPromiseExecutor(p) {
    const args = p.path.node.arguments;
    if (args.length >= 1 && (0, types_1.isExpression)(args[0])) {
        const funVar = p.solver.varProducer.expVar(args[0], p.path);
        const caller = p.solver.globalState.getEnclosingFunctionOrModule(p.path, p.moduleInfo);
        p.solver.addForAllTokensConstraint(funVar, listeners_1.TokenListener.CALL_PROMISE_EXECUTOR, p.path.node, (t) => {
            if (t instanceof tokens_1.FunctionToken)
                p.op.callFunctionTokenBound(t, undefined, caller, [
                    newObject("PromiseResolve", p.globalSpecialNatives.get(ecmascript_1.FUNCTION_PROTOTYPE), p),
                    newObject("PromiseReject", p.globalSpecialNatives.get(ecmascript_1.FUNCTION_PROTOTYPE), p),
                ], undefined, false, p.path, { native: true });
        });
    }
}
exports.callPromiseExecutor = callPromiseExecutor;
function callPromiseResolve(t, args, path, op) {
    if (args.length >= 1 && (0, types_1.isExpression)(args[0])) {
        const arg = op.expVar(args[0], path);
        if (arg) {
            const promise = op.a.canonicalizeToken(new tokens_1.AllocationSiteToken("Promise", t.allocSite));
            switch (t.kind) {
                case "PromiseResolve":
                    op.solver.addForAllTokensConstraint(arg, listeners_1.TokenListener.CALL_PROMISE_RESOLVE, { n: path.node, t: promise }, (vt) => {
                        const vp = op.solver.varProducer;
                        if (vt instanceof tokens_1.AllocationSiteToken && vt.kind === "Promise") {
                            op.solver.addSubsetConstraint(vp.objPropVar(vt, ecmascript_1.PROMISE_FULFILLED_VALUES), vp.objPropVar(promise, ecmascript_1.PROMISE_FULFILLED_VALUES));
                            op.solver.addSubsetConstraint(vp.objPropVar(vt, ecmascript_1.PROMISE_REJECTED_VALUES), vp.objPropVar(promise, ecmascript_1.PROMISE_REJECTED_VALUES));
                        }
                        else {
                            op.solver.addTokenConstraint(vt, vp.objPropVar(promise, ecmascript_1.PROMISE_FULFILLED_VALUES));
                        }
                    });
                    break;
                case "PromiseReject":
                    op.solver.addSubsetConstraint(arg, op.solver.varProducer.objPropVar(promise, ecmascript_1.PROMISE_REJECTED_VALUES));
                    break;
                default:
                    assert_1.default.fail();
            }
        }
    }
}
exports.callPromiseResolve = callPromiseResolve;
function returnResolvedPromise(kind, p) {
    const args = p.path.node.arguments;
    const promise = newObject("Promise", p.globalSpecialNatives.get(ecmascript_1.PROMISE_PROTOTYPE), p);
    p.solver.addTokenConstraint(promise, p.solver.varProducer.expVar(p.path.node, p.path));
    if (args.length >= 1 && (0, types_1.isExpression)(args[0])) {
        const arg = p.op.expVar(args[0], p.path);
        if (arg) {
            let prop, key;
            switch (kind) {
                case "resolve":
                    prop = ecmascript_1.PROMISE_FULFILLED_VALUES;
                    key = listeners_1.TokenListener.MAKE_PROMISE_RESOLVE;
                    break;
                case "reject":
                    prop = ecmascript_1.PROMISE_REJECTED_VALUES;
                    key = listeners_1.TokenListener.MAKE_PROMISE_REJECT;
                    break;
            }
            p.solver.addForAllTokensConstraint(arg, key, p.path.node, (vt) => {
                if (vt instanceof tokens_1.AllocationSiteToken && vt.kind === "Promise") {
                    p.solver.addTokenConstraint(vt, p.solver.varProducer.expVar(p.path.node, p.path));
                }
                else {
                    p.solver.addTokenConstraint(vt, p.solver.varProducer.objPropVar(promise, prop));
                }
            });
        }
    }
}
exports.returnResolvedPromise = returnResolvedPromise;
function returnPromiseIterator(kind, p) {
    const args = p.path.node.arguments;
    if (args.length >= 1 && (0, types_1.isExpression)(args[0])) {
        const arg = p.op.expVar(args[0], p.path);
        if (arg) {
            const promise = newObject("Promise", p.globalSpecialNatives.get(ecmascript_1.PROMISE_PROTOTYPE), p);
            p.solver.addTokenConstraint(promise, p.solver.varProducer.expVar(p.path.node, p.path));
            let array;
            if (kind === "all" || kind === "allSettled") {
                array = newArray(p);
                p.solver.addTokenConstraint(array, p.solver.varProducer.objPropVar(promise, ecmascript_1.PROMISE_FULFILLED_VALUES));
            }
            let allSettledObjects;
            if (kind === "allSettled") {
                allSettledObjects = newObject("Object", p.globalSpecialNatives.get(ecmascript_1.OBJECT_PROTOTYPE), p);
                p.solver.addTokenConstraint(allSettledObjects, p.solver.varProducer.arrayUnknownVar(array));
            }
            const tmp = p.solver.varProducer.intermediateVar(p.path.node, "returnPromiseIterator");
            p.op.readIteratorValue(arg, tmp, p.path.node);
            let key;
            switch (kind) {
                case "all":
                    key = listeners_1.TokenListener.MAKE_PROMISE_ALL;
                    break;
                case "allSettled":
                    key = listeners_1.TokenListener.MAKE_PROMISE_ALLSETTLED;
                    break;
                case "any":
                    key = listeners_1.TokenListener.MAKE_PROMISE_ANY;
                    break;
                case "race":
                    key = listeners_1.TokenListener.MAKE_PROMISE_RACE;
                    break;
            }
            p.solver.addForAllTokensConstraint(tmp, key, p.path.node, (t) => {
                const vp = p.solver.varProducer;
                switch (kind) {
                    case "all":
                        if (t instanceof tokens_1.AllocationSiteToken && t.kind === "Promise") {
                            p.solver.addSubsetConstraint(vp.objPropVar(t, ecmascript_1.PROMISE_FULFILLED_VALUES), vp.arrayUnknownVar(array));
                            p.solver.addSubsetConstraint(vp.objPropVar(t, ecmascript_1.PROMISE_REJECTED_VALUES), vp.objPropVar(promise, ecmascript_1.PROMISE_REJECTED_VALUES));
                        }
                        else
                            p.solver.addTokenConstraint(t, vp.arrayUnknownVar(array));
                        break;
                    case "allSettled":
                        if (t instanceof tokens_1.AllocationSiteToken && t.kind === "Promise") {
                            p.solver.addSubsetConstraint(vp.objPropVar(t, ecmascript_1.PROMISE_FULFILLED_VALUES), vp.objPropVar(allSettledObjects, "value"));
                            p.solver.addSubsetConstraint(vp.objPropVar(t, ecmascript_1.PROMISE_REJECTED_VALUES), vp.objPropVar(allSettledObjects, "reason"));
                        }
                        else
                            p.solver.addTokenConstraint(t, vp.objPropVar(allSettledObjects, "value"));
                        break;
                    case "any":
                        if (t instanceof tokens_1.AllocationSiteToken && t.kind === "Promise") {
                            p.solver.addSubsetConstraint(vp.objPropVar(t, ecmascript_1.PROMISE_FULFILLED_VALUES), vp.objPropVar(promise, ecmascript_1.PROMISE_FULFILLED_VALUES));
                        }
                        else
                            p.solver.addTokenConstraint(t, vp.objPropVar(promise, ecmascript_1.PROMISE_FULFILLED_VALUES));
                        break;
                    case "race":
                        if (t instanceof tokens_1.AllocationSiteToken && t.kind === "Promise") {
                            p.solver.addSubsetConstraint(vp.objPropVar(t, ecmascript_1.PROMISE_FULFILLED_VALUES), vp.objPropVar(promise, ecmascript_1.PROMISE_FULFILLED_VALUES));
                            p.solver.addSubsetConstraint(vp.objPropVar(t, ecmascript_1.PROMISE_REJECTED_VALUES), vp.objPropVar(promise, ecmascript_1.PROMISE_REJECTED_VALUES));
                        }
                        else
                            p.solver.addTokenConstraint(t, vp.objPropVar(promise, ecmascript_1.PROMISE_FULFILLED_VALUES));
                        break;
                }
            });
        }
    }
}
exports.returnPromiseIterator = returnPromiseIterator;
function returnPrototypeOf(p) {
    const arg = p.path.node.arguments[0], dst = p.solver.varProducer.expVar(p.path.node, p.path);
    if ((0, types_1.isExpression)(arg) && !(0, asthelpers_1.isParentExpressionStatement)(p.path) && dst !== undefined)
        p.solver.addForAllTokensConstraint(p.solver.varProducer.expVar(arg, p.path), listeners_1.TokenListener.NATIVE_12, p.path.node, (t) => {
            if ((0, constraintvars_1.isObjectPropertyVarObj)(t))
                p.solver.addSubsetConstraint(p.solver.varProducer.objPropVar(t, (0, ecmascript_1.INTERNAL_PROTOTYPE)()), dst);
        });
}
exports.returnPrototypeOf = returnPrototypeOf;
function setPrototypeOf(p) {
    const [obj, prototype] = p.path.node.arguments;
    if ((0, types_1.isExpression)(obj) && (0, types_1.isExpression)(prototype)) {
        const pvar = p.op.solver.varProducer.expVar(prototype, p.path);
        if (pvar)
            p.solver.addForAllTokensConstraint(p.solver.varProducer.expVar(obj, p.path), listeners_1.TokenListener.NATIVE_14, p.path.node, (t) => {
                if ((0, constraintvars_1.isObjectPropertyVarObj)(t))
                    p.solver.addInherits(t, pvar);
            });
    }
}
exports.setPrototypeOf = setPrototypeOf;
function assignProperties(target, sources, p) {
    const tVar = p.op.expVar(target, p.path);
    if (!tVar)
        return;
    const sVars = [];
    for (const src of sources) {
        if ((0, types_1.isExpression)(src)) {
            const sVar = p.op.expVar(src, p.path);
            if (sVar)
                sVars.push(sVar);
        }
        else
            warnNativeUsed("Object.assign", p, "with non-expression source");
    }
    if (sVars.length === 0)
        return;
    let sVar = sVars[0];
    if (sVars.length > 1) {
        sVar = p.solver.varProducer.intermediateVar(p.path.node, "Object.assign");
        for (const sVar2 of sVars)
            p.solver.addSubsetConstraint(sVar2, sVar);
    }
    const node = p.path.node;
    const enclosing = p.solver.globalState.getEnclosingFunctionOrModule(p.path, p.moduleInfo);
    p.solver.addForAllTokensConstraint(sVar, listeners_1.TokenListener.NATIVE_ASSIGN_PROPERTIES, node, (s) => {
        if ((0, constraintvars_1.isObjectPropertyVarObj)(s))
            p.solver.addForAllObjectPropertiesConstraint(s, listeners_1.TokenListener.NATIVE_ASSIGN_PROPERTIES2, node, (prop) => {
                const iVar = p.solver.varProducer.intermediateVar(node, `Object.assign:${prop}`);
                p.op.readPropertyBound(s, prop, iVar, { n: node, s: prop }, enclosing);
                p.solver.addForAllTokensConstraint(tVar, listeners_1.TokenListener.NATIVE_ASSIGN_PROPERTIES3, { n: node, s: prop }, (t) => {
                    p.op.writeProperty(iVar, tVar, t, prop, node, enclosing);
                });
            });
    });
}
exports.assignProperties = assignProperties;
function prepareDefineProperty(name, prop, descriptor, p) {
    if (!descriptor)
        return [];
    const enclosing = p.solver.globalState.getEnclosingFunctionOrModule(p.path, p.moduleInfo);
    return ["value", "get", "set"].map(descriptorProp => {
        const ivar = p.solver.varProducer.intermediateVar(p.path.node, `${name} (${prop}.${descriptorProp})`);
        p.op.readProperty(descriptor, descriptorProp, ivar, p.path.node, enclosing, ivar.label);
        return { prop, ac: descriptorProp === "value" ? "normal" : descriptorProp, ivar };
    });
}
exports.prepareDefineProperty = prepareDefineProperty;
function prepareDefineProperties(name, props, p) {
    if (!(0, types_1.isObjectExpression)(props)) {
        warnNativeUsed(name, p, "with non-object expression");
        return [];
    }
    const pobj = p.op.newObjectToken(props);
    return props.properties.flatMap((oprop) => {
        if (!(0, types_1.isObjectProperty)(oprop)) {
            warnNativeUsed(name, p, `with property kind: '${oprop.type}'`);
            return [];
        }
        const key = (0, asthelpers_1.getKey)(oprop);
        if (!key) {
            warnNativeUsed(name, p, "with dynamic property name");
            return [];
        }
        const dvar = p.solver.varProducer.objPropVar(pobj, key);
        return prepareDefineProperty(name, key, dvar, p);
    });
}
exports.prepareDefineProperties = prepareDefineProperties;
function defineProperties(obj, key, ivars, p) {
    if (ivars.length === 0)
        return;
    const enclosing = p.solver.globalState.getEnclosingFunctionOrModule(p.path, p.moduleInfo);
    function write(t, lVar) {
        for (const { prop, ac, ivar } of ivars)
            p.op.writeProperty(ivar, lVar, t, prop, p.path.node, enclosing, undefined, ac, false);
    }
    if (obj instanceof tokens_1.Token)
        write(obj);
    else {
        const lVar = p.op.expVar(obj, p.path);
        p.solver.addForAllTokensConstraint(lVar, key, p.path.node, (t) => write(t, lVar));
    }
}
exports.defineProperties = defineProperties;
//# sourceMappingURL=nativehelpers.js.map