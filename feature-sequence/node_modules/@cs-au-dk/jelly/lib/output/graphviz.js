"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.toDot = void 0;
const infos_1 = require("../analysis/infos");
const logger_1 = __importDefault(require("../misc/logger"));
const options_1 = require("../options");
const fs_1 = require("fs");
const util_1 = require("../misc/util");
function toDot(f, fd = process.stdout.fd) {
    const ids = new Map();
    let next = 1;
    function id(x) {
        let t = ids.get(x);
        if (!t) {
            t = next++;
            ids.set(x, t);
            if (logger_1.default.isDebugEnabled())
                logger_1.default.debug(`Assigning ID ${t} to ${x}`);
        }
        return t;
    }
    function esc(s) {
        return s.replace("\\", "\\\\").replace("\"", "\\\"");
    }
    function ind(i) {
        return " ".repeat(i);
    }
    function writeFunction(f, i, moduleId) {
        if (options_1.options.graphvizElideFunctions || options_1.options.dependenciesOnly)
            ids.set(f, moduleId);
        else
            (0, fs_1.writeSync)(fd, `${ind(i)}subgraph cluster${id(f)} {\n` +
                `${ind(i)} label=\"${f.name ?? "<anon>"}@${(0, util_1.locationToString)(f.node.loc)}\";\n` +
                `${ind(i)} bgcolor=\"#ffffff\";\n` +
                `${ind(i)}node${id(f)}[style=invis,shape=point];\n`);
        for (const fs of f.functions)
            writeFunction(fs, i + 1, moduleId);
        if (!options_1.options.graphvizElideFunctions && !options_1.options.dependenciesOnly)
            (0, fs_1.writeSync)(fd, `${ind(i)}}\n`);
    }
    function writeModule(km, m, i) {
        (0, fs_1.writeSync)(fd, `${ind(i)}subgraph cluster${id(m)} {\n` +
            `${ind(i)} label=\"${esc(km)}\";\n` +
            `${ind(i)} bgcolor=\"#ffffff\";\n` +
            `${ind(i)}node${id(m)}[style=invis,shape=point];\n`);
        for (const f of m.functions)
            writeFunction(f, i + 1, id(m));
        (0, fs_1.writeSync)(fd, `${ind(i)}}\n`);
    }
    function isPackageIncluded(p) {
        return !options_1.options.graphvizPackages || options_1.options.graphvizPackages.indexOf(p.name) !== -1;
    }
    (0, fs_1.writeSync)(fd, "digraph G {\n" +
        " graph [ranksep=1];\n" +
        " compound=true;\n" +
        " node [shape=box,fillcolor=\"#ffffff\",style=filled]\n");
    for (const [kp, p] of f.a.packageInfos)
        if (isPackageIncluded(p)) {
            (0, fs_1.writeSync)(fd, ` subgraph cluster${id(p)} {\n` +
                `  label=\"${esc(kp)}\";\n` +
                "  bgcolor=\"#f0f0f0\";\n");
            for (const [km, m] of p.modules)
                writeModule(km, m, 2);
            (0, fs_1.writeSync)(fd, " }\n");
        }
    (0, fs_1.writeSync)(fd, ` edge ${options_1.options?.dependenciesOnly ? "[color=\"#000000\",style=solid]" : "[color=\"#888888\",style=dashed]"};\n`);
    for (const [from, tos] of f.requireGraph)
        if (isPackageIncluded(from.packageInfo))
            for (const to of tos)
                if (isPackageIncluded(to.packageInfo))
                    (0, fs_1.writeSync)(fd, ` node${id(from)}->node${id(to)} [lhead=cluster${id(to)}];\n`);
    if (!options_1.options?.dependenciesOnly) {
        (0, fs_1.writeSync)(fd, ` edge [color=\"#000000\",style=solid];\n`);
        const es = new Set();
        for (const [from, tos] of f.functionToFunction)
            if (isPackageIncluded(from.packageInfo))
                for (const to of tos)
                    if (isPackageIncluded(to.packageInfo)) {
                        const m = from instanceof infos_1.FunctionInfo ? from.moduleInfo : from;
                        const str = ` node${id(from)}->node${id(to)}${m !== to.moduleInfo ? ` [lhead=cluster${id(to)}]` : ""};\n`;
                        if (options_1.options.graphvizElideFunctions)
                            if (es.has(str))
                                continue;
                            else
                                es.add(str);
                        (0, fs_1.writeSync)(fd, str);
                    }
    }
    (0, fs_1.writeSync)(fd, "}\n");
}
exports.toDot = toDot;
//# sourceMappingURL=graphviz.js.map