"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AnalysisStateReporter = void 0;
const logger_1 = __importDefault(require("../misc/logger"));
const util_1 = require("../misc/util");
const tokens_1 = require("../analysis/tokens");
const fs_1 = __importDefault(require("fs"));
const constraintvars_1 = require("../analysis/constraintvars");
const path_1 = require("path");
const options_1 = require("../options");
const infos_1 = require("../analysis/infos");
const types_1 = require("@babel/types");
const assert_1 = __importDefault(require("assert"));
class AnalysisStateReporter {
    f;
    a;
    constructor(f) {
        this.f = f;
        this.a = f.a;
    }
    saveTokens(outfile) {
        const varIndex = new Map();
        const fd = fs_1.default.openSync(outfile, "w");
        fs_1.default.writeSync(fd, "[");
        let firstvar = true;
        for (const [v, ts] of this.f.getAllVarsAndTokens()) {
            varIndex.set(v, varIndex.size);
            if (firstvar)
                firstvar = false;
            else
                fs_1.default.writeSync(fd, ",");
            fs_1.default.writeSync(fd, `\n { "var": ${JSON.stringify(v.toString())}, "tokens": [`);
            let firsttoken = true;
            for (const t of ts) {
                if (firsttoken)
                    firsttoken = false;
                else
                    fs_1.default.writeSync(fd, ",");
                fs_1.default.writeSync(fd, `\n  ${JSON.stringify(t.toString())}`);
            }
            fs_1.default.writeSync(fd, "\n ] }");
        }
        for (const v of this.f.redirections.keys()) {
            const repi = varIndex.get(this.f.getRepresentative(v));
            if (repi !== undefined) {
                (0, assert_1.default)(!firstvar);
                fs_1.default.writeSync(fd, `,\n { "var": ${JSON.stringify(v.toString())}, "rep": ${repi} }`);
            }
        }
        fs_1.default.writeSync(fd, "\n]");
        fs_1.default.closeSync(fd);
        logger_1.default.info(`Analysis tokens written to ${outfile}`);
    }
    makeLocStr(fileIndex, loc) {
        return `${fileIndex}:${loc ? `${loc.start.line}:${loc.start.column + 1}:${loc.end.line}:${loc.end.column + 1}` : "?:?:?:?"}`;
    }
    saveCallGraph(outfile, files) {
        const fd = fs_1.default.openSync(outfile, "w");
        fs_1.default.writeSync(fd, `{\n "time": "${new Date().toUTCString()}",\n`);
        fs_1.default.writeSync(fd, ` "entries": [`);
        let first = true;
        for (const file of files) {
            fs_1.default.writeSync(fd, `${first ? "" : ","}\n  ${JSON.stringify((0, path_1.relative)(options_1.options.basedir, (0, path_1.resolve)(options_1.options.basedir, file)))}`);
            first = false;
        }
        fs_1.default.writeSync(fd, `\n ],\n`);
        if (options_1.options.ignoreDependencies)
            fs_1.default.writeSync(fd, ` "ignoreDependencies": true,\n`);
        if (options_1.options.includePackages) {
            fs_1.default.writeSync(fd, ` "included": [`);
            first = true;
            for (const name of options_1.options.includePackages) {
                fs_1.default.writeSync(fd, `${first ? "" : ","}\n  ${JSON.stringify(name)}`);
                first = false;
            }
            fs_1.default.writeSync(fd, `\n ],\n`);
        }
        if (options_1.options.excludePackages) {
            fs_1.default.writeSync(fd, ` "excluded": [`);
            first = true;
            for (const name of options_1.options.excludePackages) {
                fs_1.default.writeSync(fd, `${first ? "" : ","}\n  ${JSON.stringify(name)}`);
                first = false;
            }
            fs_1.default.writeSync(fd, `\n ],\n`);
        }
        fs_1.default.writeSync(fd, ` "files": [`);
        const fileIndices = new Map();
        first = true;
        for (const m of this.a.moduleInfos.values())
            if (m.node) {
                fileIndices.set(m, fileIndices.size);
                fs_1.default.writeSync(fd, `${first ? "" : ","}\n  ${JSON.stringify((0, path_1.relative)(options_1.options.basedir, m.getPath()))}`);
                first = false;
            }
        fs_1.default.writeSync(fd, `\n ],\n "functions": {`);
        const functionIndices = new Map();
        first = true;
        for (const fun of [...this.a.functionInfos.values(), ...this.a.moduleInfos.values()])
            if (fun.node) {
                const funIndex = functionIndices.size;
                functionIndices.set(fun, funIndex);
                const fileIndex = fileIndices.get(fun instanceof infos_1.ModuleInfo ? fun : fun.moduleInfo);
                if (fileIndex === undefined)
                    assert_1.default.fail(`File index not found for ${fun}`);
                fs_1.default.writeSync(fd, `${first ? "" : ","}\n  "${funIndex}": ${JSON.stringify(this.makeLocStr(fileIndex, fun.node?.loc))}`);
                first = false;
            }
        fs_1.default.writeSync(fd, `\n },\n "calls": {`);
        const callIndices = new Map();
        first = true;
        for (const call of this.f.callLocations) {
            const m = call.loc.module;
            (0, assert_1.default)(m);
            const callIndex = callIndices.size + functionIndices.size;
            callIndices.set(call, callIndex);
            const fileIndex = fileIndices.get(m);
            if (fileIndex === undefined)
                assert_1.default.fail(`File index not found for ${m}`);
            fs_1.default.writeSync(fd, `${first ? "" : ","}\n  "${callIndex}": ${JSON.stringify(this.makeLocStr(fileIndex, call.loc))}`);
            first = false;
        }
        fs_1.default.writeSync(fd, `\n },\n "fun2fun": [`);
        first = true;
        for (const [caller, callees] of [...this.f.functionToFunction, ...(options_1.options.callgraphRequire ? this.f.requireGraph : [])])
            if (caller.node)
                for (const callee of callees)
                    if (callee.node) {
                        const callerIndex = functionIndices.get(caller);
                        if (callerIndex === undefined)
                            assert_1.default.fail(`Function index not found for ${caller}`);
                        const calleeIndex = functionIndices.get(callee);
                        if (calleeIndex === undefined)
                            assert_1.default.fail(`Function index not found for ${callee}`);
                        fs_1.default.writeSync(fd, `${first ? "\n  " : ", "}[${callerIndex}, ${calleeIndex}]`);
                        first = false;
                    }
        fs_1.default.writeSync(fd, `${first ? "" : "\n "}],\n "call2fun": [`);
        first = true;
        for (const [call, callIndex] of callIndices) {
            const funs = this.f.callToFunction.get(call) || [];
            const mods = this.f.callToModule.get(call) || [];
            for (const callee of [...funs, ...mods])
                if (!(callee instanceof infos_1.DummyModuleInfo) && callee.node) {
                    const calleeIndex = functionIndices.get(callee);
                    if (calleeIndex === undefined)
                        assert_1.default.fail(`Function index not found for ${callee}`);
                    fs_1.default.writeSync(fd, `${first ? "\n  " : ", "}[${callIndex}, ${calleeIndex}]`);
                    first = false;
                }
        }
        fs_1.default.writeSync(fd, `${first ? "" : "\n "}],\n "ignore": [`);
        first = true;
        for (const [m, loc] of this.f.artificialFunctions) {
            const fileIndex = fileIndices.get(m);
            if (fileIndex === undefined)
                assert_1.default.fail(`File index not found for ${m}`);
            fs_1.default.writeSync(fd, `${first ? "" : ","}\n  ${JSON.stringify(this.makeLocStr(fileIndex, loc))}`);
            first = false;
        }
        fs_1.default.writeSync(fd, `${first ? "" : "\n "}]\n}\n`);
        fs_1.default.closeSync(fd);
        logger_1.default.info(`Call graph written to ${outfile}`);
    }
    callGraphToJSON(ifiles) {
        const files = [], functions = [], calls = [], fun2fun = [], call2fun = [];
        const fileIndices = new Map();
        for (const m of this.a.moduleInfos.values())
            if (m.node) {
                fileIndices.set(m, fileIndices.size);
                files.push((0, path_1.relative)(options_1.options.basedir, m.getPath()));
            }
        const functionIndices = new Map();
        for (const fun of [...this.a.functionInfos.values(), ...this.a.moduleInfos.values()])
            if (fun.node) {
                const funIndex = functions.length;
                functionIndices.set(fun, funIndex);
                const fileIndex = fileIndices.get(fun instanceof infos_1.ModuleInfo ? fun : fun.moduleInfo);
                if (fileIndex === undefined)
                    assert_1.default.fail(`File index not found for ${fun}`);
                functions.push(this.makeLocStr(fileIndex, fun.node?.loc));
            }
        const callIndices = new Map();
        for (const call of this.f.callLocations) {
            const m = call.loc.module;
            (0, assert_1.default)(m);
            const fileIndex = fileIndices.get(m);
            if (fileIndex === undefined)
                assert_1.default.fail(`File index not found for ${m}`);
            const callIndex = calls.length;
            callIndices.set(call, callIndex);
            calls.push(this.makeLocStr(fileIndex, call.loc));
        }
        for (const [caller, callees] of [...this.f.functionToFunction, ...(options_1.options.callgraphRequire ? this.f.requireGraph : [])])
            if (caller.node)
                for (const callee of callees)
                    if (callee.node) {
                        const callerIndex = functionIndices.get(caller);
                        if (callerIndex === undefined)
                            assert_1.default.fail(`Function index not found for ${caller}`);
                        const calleeIndex = functionIndices.get(callee);
                        if (calleeIndex === undefined)
                            assert_1.default.fail(`Function index not found for ${callee}`);
                        fun2fun.push([callerIndex, calleeIndex]);
                    }
        for (const [call, callIndex] of callIndices) {
            const funs = this.f.callToFunction.get(call) || [];
            const mods = this.f.callToModule.get(call) || [];
            for (const callee of [...funs, ...mods])
                if (!(callee instanceof infos_1.DummyModuleInfo) && callee.node) {
                    const calleeIndex = functionIndices.get(callee);
                    if (calleeIndex === undefined)
                        assert_1.default.fail(`Function index not found for ${callee}`);
                    call2fun.push([callIndex, calleeIndex]);
                }
        }
        return {
            time: new Date().toUTCString(),
            entries: ifiles.map(file => (0, path_1.relative)(options_1.options.basedir, (0, path_1.resolve)(options_1.options.basedir, file))),
            ignoreDependencies: options_1.options.ignoreDependencies,
            includePackages: options_1.options.includePackages,
            excludePackages: options_1.options.excludePackages,
            files,
            functions,
            calls,
            fun2fun,
            call2fun,
            ignore: this.f.artificialFunctions.map(([m, loc]) => {
                const fileIndex = fileIndices.get(m);
                if (fileIndex === undefined)
                    assert_1.default.fail(`File index not found for ${m}`);
                return this.makeLocStr(fileIndex, loc);
            }),
        };
    }
    reportCallGraph() {
        logger_1.default.info("Call graph:");
        for (const [src, dsts] of this.f.callToFunctionOrModule)
            for (const dst of dsts)
                if (dst instanceof infos_1.FunctionInfo)
                    logger_1.default.info(`  ${(0, util_1.locationToStringWithFileAndEnd)(src.loc)} -> ${(0, util_1.locationToStringWithFile)(dst.node.loc)}`);
    }
    reportTokens() {
        logger_1.default.info("Tokens:");
        const redir = new Map();
        for (const [v, w] of this.f.redirections)
            (0, util_1.mapGetArray)(redir, this.f.getRepresentative(w)).push(v);
        for (const [v, ts, size] of this.f.getAllVarsAndTokens()) {
            if (size === 0)
                continue;
            if (size === 1) {
                let any = false;
                for (const w of [v, ...redir.get(v) ?? []])
                    if (!((w instanceof constraintvars_1.ObjectPropertyVar && w.obj instanceof tokens_1.NativeObjectToken) ||
                        (w instanceof constraintvars_1.NodeVar && (0, types_1.isIdentifier)(w.node) && w.node.loc?.start.line === 0))) {
                        any = true;
                        break;
                    }
                if (!any)
                    continue;
            }
            logger_1.default.info(`  ${v}: (size ${size})`);
            for (const w of redir.get(v) ?? [])
                logger_1.default.info(`  ${w} (redirected)`);
            for (const t of ts)
                logger_1.default.info(`    ${t}`);
        }
    }
    getZeroCalleeCalls() {
        const calls = new Set();
        for (const c of this.f.callLocations) {
            if (!this.f.nativeCallLocations.has(c) && !this.f.externalCallLocations.has(c)) {
                const cs = this.f.callToFunction.get(c);
                if (!cs || cs.size === 0)
                    calls.add(c);
            }
        }
        return calls;
    }
    reportZeroCalleeCalls(calls) {
        for (const c of calls)
            logger_1.default.info(`Call with zero callees at ${(0, util_1.locationToStringWithFileAndEnd)(c.loc)}`);
    }
    getZeroButNativeCalleeCalls() {
        let r = 0;
        for (const c of this.f.callLocations) {
            if (this.f.nativeCallLocations.has(c) && !this.f.externalCallLocations.has(c)) {
                const cs = this.f.callToFunction.get(c);
                if (!cs || cs.size === 0) {
                    r++;
                    if (logger_1.default.isDebugEnabled())
                        logger_1.default.debug(`Call with native-only callees at ${(0, util_1.locationToStringWithFile)(c.loc)}`);
                }
            }
        }
        return r;
    }
    getZeroButExternalCalleeCalls() {
        let r = 0;
        for (const c of this.f.callLocations) {
            if (this.f.externalCallLocations.has(c) && !this.f.nativeCallLocations.has(c)) {
                const cs = this.f.callToFunction.get(c);
                if (!cs || cs.size === 0) {
                    r++;
                    if (logger_1.default.isDebugEnabled())
                        logger_1.default.debug(`Call with external-only callees at ${(0, util_1.locationToStringWithFile)(c.loc)}`);
                }
            }
        }
        return r;
    }
    getZeroButNativeOrExternalCalleeCalls() {
        let r = 0;
        for (const c of this.f.callLocations) {
            if (this.f.nativeCallLocations.has(c) && this.f.externalCallLocations.has(c)) {
                const cs = this.f.callToFunction.get(c);
                if (!cs || cs.size === 0) {
                    r++;
                    if (logger_1.default.isDebugEnabled())
                        logger_1.default.debug(`Call with native-or-external-only callees at ${(0, util_1.locationToStringWithFile)(c.loc)}`);
                }
            }
        }
        return r;
    }
    getOneCalleeCalls() {
        let r = 0;
        for (const c of this.f.callLocations) {
            const cs = this.f.callToFunction.get(c);
            if (cs)
                if (cs.size === 1)
                    r++;
        }
        return r;
    }
    getMultipleCalleeCalls() {
        let r = 0;
        for (const c of this.f.callLocations) {
            const cs = this.f.callToFunction.get(c);
            if (cs) {
                if (cs.size > 1) {
                    r++;
                    if (logger_1.default.isDebugEnabled())
                        logger_1.default.debug(`Call with multiple callees at ${(0, util_1.locationToStringWithFile)(c.loc)}: ${cs.size}`);
                }
            }
        }
        return r;
    }
    getZeroCallerFunctions() {
        const funs = new Set(this.a.functionInfos.values());
        for (const fs of this.f.functionToFunction.values())
            (0, util_1.deleteAll)(fs.values(), funs);
        return funs;
    }
    reportZeroCallerFunctions(funs) {
        for (const f of funs)
            logger_1.default.info(`Function with zero callers at ${f}`);
    }
    getEntryModules() {
        return new Set(Array.from(this.a.moduleInfos.values()).filter(m => m.isEntry));
    }
    getReachableModulesAndFunctions(entries) {
        const res = new Set(entries);
        const w = Array.from(entries);
        while (w.length > 0) {
            const f = w.pop();
            for (const g of [...this.f.functionToFunction.get(f) ?? [], ...this.f.requireGraph.get(f) ?? []]) {
                if (!res.has(g)) {
                    res.add(g);
                    w.push(g);
                    if (logger_1.default.isVerboseEnabled())
                        logger_1.default.verbose(`${g instanceof infos_1.FunctionInfo ? "Function" : "Module"} ${g} is reachable`);
                }
            }
        }
        return res;
    }
    saveDiagnostics(stats, file) {
        const fd = fs_1.default.openSync(file, "w");
        fs_1.default.writeSync(fd, JSON.stringify(stats, undefined, 2));
        fs_1.default.closeSync(fd);
        logger_1.default.info(`Analysis diagnostics written to ${file}`);
    }
    reportReachablePackagesAndModules() {
        logger_1.default.info("Packages and modules:");
        for (const p of this.a.packageInfos.values()) {
            logger_1.default.info(`${p} (${p.dir})`);
            for (const m of p.modules.values())
                logger_1.default.info(`  ${m.getOfficialName()} (${m.relativePath})`);
        }
    }
    reportLargestTokenSets() {
        const a = [];
        for (const [v, ts, size] of this.f.getAllVarsAndTokens())
            a.push({ v, ts, size });
        a.sort((x, y) => y.size - x.size);
        logger_1.default.info("Largest token sets:");
        for (let i = 0; i < 10 && i < a.length; i++) {
            logger_1.default.info(`  ${a[i].v}: ${a[i].size}`);
            if (logger_1.default.isVerboseEnabled())
                for (const t of a[i].ts)
                    logger_1.default.info(`    ${t}`);
        }
    }
    reportLargestSubsetEdges() {
        const a = [];
        for (const [v, vs] of this.f.subsetEdges)
            a.push({ v, vs });
        a.sort((x, y) => y.vs.size - x.vs.size);
        logger_1.default.info("Largest subset outs:");
        for (let i = 0; i < 10 && i < a.length; i++) {
            logger_1.default.info(`  ${a[i].v}: ${a[i].vs.size}`);
            if (logger_1.default.isVerboseEnabled())
                for (const v of a[i].vs)
                    logger_1.default.info(`    ${v}`);
        }
    }
    reportHigherOrderFunctions() {
        const funargs = new Map();
        for (const [f, vs] of this.f.functionParameters) {
            for (const v of vs)
                for (const t of this.f.getTokens(this.f.getRepresentative(v)))
                    if (t instanceof tokens_1.FunctionToken)
                        funargs.set(f, (funargs.get(f) || 0) + 1);
        }
        const funreturns = new Map();
        for (const f of this.a.functionInfos.keys()) {
            const v = this.f.varProducer.returnVar(f);
            for (const t of this.f.getTokens(this.f.getRepresentative(v)))
                if (t instanceof tokens_1.FunctionToken)
                    funreturns.set(f, (funreturns.get(f) || 0) + 1);
        }
        logger_1.default.info("Higher-order functions (function arguments + function return values):");
        const a = [];
        for (const f of [...funargs.keys(), ...funreturns.keys()])
            a.push(`${(0, util_1.locationToStringWithFileAndEnd)(f.loc)} (${funargs.get(f) ?? 0}+${funreturns.get(f) ?? 0})`);
        a.sort();
        for (const f of a)
            logger_1.default.info(f);
    }
    reportVariableKinds() {
        const varsWithListeners = this.f.tokenListeners;
        const counts = new Map();
        const withListenersCounts = new Map();
        const srcCounts = new Map();
        const dstCounts = new Map();
        for (const v of this.f.vars) {
            const k = v.getKind();
            counts.set(k, (0, util_1.getOrSet)(counts, k, () => 0) + 1);
            if (varsWithListeners.has(v))
                withListenersCounts.set(k, (0, util_1.getOrSet)(withListenersCounts, k, () => 0) + 1);
            if (this.f.subsetEdges.has(v))
                srcCounts.set(k, (0, util_1.getOrSet)(srcCounts, k, () => 0) + 1);
            if (this.f.reverseSubsetEdges.has(v))
                dstCounts.set(k, (0, util_1.getOrSet)(dstCounts, k, () => 0) + 1);
        }
        logger_1.default.info("Constraint variable kinds (with listeners, sources, targets):");
        for (const [k, n] of Array.from(counts.entries()).sort(([, n1], [, n2]) => n2 - n1))
            logger_1.default.info(`${k}: ${n} (${withListenersCounts.get(k) ?? 0}, ${srcCounts.get(k) ?? 0}, ${dstCounts.get(k) ?? 0})`);
        logger_1.default.info(`Total: ${this.f.vars.size} (${varsWithListeners.size})`);
    }
}
exports.AnalysisStateReporter = AnalysisStateReporter;
//# sourceMappingURL=analysisstatereporter.js.map