"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.compareCallGraphs = void 0;
const fs_1 = require("fs");
const util_1 = require("../misc/util");
const logger_1 = __importDefault(require("../misc/logger"));
const assert_1 = __importDefault(require("assert"));
class FileFilter {
    files;
    ignoreDependencies;
    incl;
    excl;
    constructor(cg1, cg2) {
        const intersect = (a, b) => {
            for (const x of a)
                if (!b.has(x))
                    a.delete(x);
        };
        this.files = new Set(cg1.files);
        if (cg2?.files)
            intersect(this.files, new Set(cg2.files));
        if (cg1.includePackages) {
            this.incl = new Set(cg1.includePackages);
            if (cg2?.includePackages)
                intersect(this.incl, new Set(cg2.includePackages));
        }
        else if (cg2?.includePackages)
            this.incl = new Set(cg2.includePackages);
        this.excl = new Set(cg1.excludePackages ?? []);
        (0, util_1.addAll)(cg2?.excludePackages, this.excl);
        this.ignoreDependencies = cg1.ignoreDependencies || cg2?.ignoreDependencies || false;
    }
    static fileInPackages(file, pcks) {
        for (const pck of pcks)
            if (file.includes(`node_modules/${pck}/`))
                return true;
        return false;
    }
    isIncluded(file, msg) {
        if (this.ignoreDependencies && !this.files.has(file)) {
            if (msg)
                logger_1.default.info(`Ignoring file ${file} (ignoring dependencies)`);
            return false;
        }
        if (!file.includes("node_modules/"))
            return true;
        if (this.incl && !FileFilter.fileInPackages(file, this.incl)) {
            if (msg)
                logger_1.default.info(`Ignoring file ${file} (not in included package)`);
            return false;
        }
        if (this.excl.size && FileFilter.fileInPackages(file, this.excl)) {
            if (msg)
                logger_1.default.info(`Ignoring file ${file} (in excluded package)`);
            return false;
        }
        return true;
    }
}
function compareFileArrays(as1, cg2, file1, file2) {
    const filter = new FileFilter(cg2);
    for (const e of as1)
        if (!filter.files.has(e) && filter.isIncluded(e, true))
            logger_1.default.warn(`File ${e} found in ${file1}, missing in ${file2}`);
    return filter;
}
function compareEntryArrays(as1, as2, file1, file2) {
    const s = new Set(as2);
    for (const e of as1)
        if (!s.has(e))
            logger_1.default.warn(`Entry ${e} found in ${file1}, missing in ${file2}`);
}
function loc(str, cg) {
    const parsed = new util_1.SourceLocationsToJSON(cg.files).parseLocationJSON(str);
    let start = "?:?", end = "?:?";
    if (parsed.loc) {
        start = `${parsed.loc.start.line}:${parsed.loc.start.column + 1}`;
        end = `${parsed.loc.end.line}:${parsed.loc.end.column + 1}`;
    }
    return { start: `${parsed.file}:${start}`, end: `${parsed.file}:${end}`, file: parsed.file };
}
function matchLocationObjects(cg1, cg2, prop, ignores) {
    const starts = new Map();
    const ends = new Map();
    for (const [i, rawloc] of Object.entries(cg1[prop])) {
        const { start, end } = loc(rawloc, cg1);
        if (prop === "functions" && ignores.has(start)) {
            logger_1.default.debug(`Ignoring ${start}`);
            continue;
        }
        (0, util_1.mapArrayAdd)(start, Number(i), starts);
        (0, util_1.mapArrayAdd)(end, Number(i), ends);
    }
    const aToB = new Map();
    const bToA = new Map();
    for (const [j, rawloc] of Object.entries(cg2[prop])) {
        const { start, end } = loc(rawloc, cg2);
        if (prop === "functions" && ignores.has(start)) {
            logger_1.default.debug(`Ignoring ${start}`);
            continue;
        }
        const is = new Set([...starts.get(start) ?? [], ...ends.get(end) ?? []]);
        if (!is.size)
            continue;
        const jn = Number(j);
        bToA.set(jn, is);
        for (const i of is)
            (0, util_1.mapGetSet)(aToB, i).add(jn);
    }
    return [aToB, bToA];
}
function compareLocationObjects(match, cg, file1, file2, kind, ignores, filter) {
    for (const [i, rawloc] of Object.entries(kind === "Function" ? cg.functions : cg.calls)) {
        const { start: q, file: f } = loc(rawloc, cg);
        if (!match.has(Number(i)) && (kind !== "Function" || !ignores.has(q))) {
            const extra = !filter.files.has(f) ? ` (file ${f} missing)` : "";
            logger_1.default.warn(`${kind} ${q} found in ${file1}, missing in ${file2}${extra}`);
        }
    }
}
function compareEdges(file1, file2, cg1, cg2, kind, matchCalls, matchFuns, ignores, filter) {
    const sourceProp = kind === "Function" ? "functions" : "calls";
    const edgesProp = kind === "Function" ? "fun2fun" : "call2fun";
    const s = new Set();
    for (const [i, j] of cg2[edgesProp]) {
        if (!cg2[sourceProp][i])
            assert_1.default.fail(`cg2.${sourceProp}[${i}] is undefined`);
        if (!cg2.functions[j])
            assert_1.default.fail(`cg2.functions[${j}] is undefined`);
        s.add(`${i} -> ${j}`);
    }
    let found = 0, missed = 0, ignored = 0;
    for (const [i, j] of cg1[edgesProp]) {
        if (!cg1[sourceProp][i])
            assert_1.default.fail(`cg1.${sourceProp}[${i}] is undefined`);
        if (!cg1.functions[j])
            assert_1.default.fail(`cg1.functions[${j}] is undefined`);
        const { start: fstart, end: from, file: ff } = loc(cg1[sourceProp][i], cg1);
        const { start: tstart, end: to, file: ft } = loc(cg1.functions[j], cg1);
        if (kind === "Function" && ignores.has(fstart) || ignores.has(tstart)) {
            logger_1.default.debug(`Ignoring ${from} -> ${to}`);
            continue;
        }
        const i2s = Array.from(matchCalls.get(i) ?? []), j2s = Array.from(matchFuns.get(j) ?? []);
        if (!i2s.flatMap(i2 => j2s.map(j2 => `${i2} -> ${j2}`)).some(e => s.has(e))) {
            if (filter.isIncluded(ff, false) &&
                filter.isIncluded(ft, false)) {
                const extra = !filter.files.has(ff) ? ` (file ${ff} missing)` : !filter.files.has(ft) ? ` (file ${ft} missing)` : "";
                logger_1.default.info(`${kind}->function edge ${fstart} -> ${tstart} found in ${file1}, missing in ${file2}${extra}`);
                missed++;
            }
            else
                ignored++;
        }
        else
            found++;
    }
    return [found, found + missed, ignored];
}
function compareCallSiteEdges(cg1, cg2, call2ToCall1, fun2ToFun1, ignores) {
    const filter = new FileFilter(cg1, cg2);
    const floc = (s, cg) => filter.isIncluded(loc(s, cg).file, false);
    const e1 = new Map();
    for (const [c, f] of cg1.call2fun) {
        if (!floc(cg1.calls[c], cg1) || !floc(cg1.functions[f], cg1))
            continue;
        if (ignores.has(loc(cg1.functions[f], cg1).start)) {
            continue;
        }
        (0, util_1.mapGetSet)(e1, c).add(f);
    }
    const e2 = new Map();
    for (const [c, f] of cg2.call2fun) {
        if (!floc(cg2.calls[c], cg2) || !floc(cg2.functions[f], cg2))
            continue;
        for (const i of call2ToCall1.get(c) ?? [])
            for (const j of fun2ToFun1.get(f) ?? [])
                (0, util_1.mapGetSet)(e2, i).add(j);
    }
    const ps = [], rs = [];
    for (const [from, s1] of e1) {
        const s2 = e2.get(from) ?? new Set;
        const pos = Array.from(s1).reduce((acc, f) => acc + (s2.has(f) ? 1 : 0), 0);
        ps.push(s2.size > 0 ? pos / s2.size : 1);
        rs.push(pos / s1.size);
    }
    const avg = (xs) => xs.reduce((acc, x) => acc + x, 0) / (xs.length || 1);
    return { precision: avg(ps), recall: avg(rs) };
}
function getIgnores(...cgs) {
    const s = new Set();
    for (const cg of cgs)
        for (const p of cg.ignore ?? [])
            s.add(loc(p, cg).start);
    return s;
}
function computeReachableFunctions(file2, cg1, cg2, fun1ToFun2, ignores, filter) {
    const parser = new util_1.SourceLocationsToJSON(cg2.files);
    const fileToModuleIndex = new Array(cg2.files.length);
    for (const [i, floc] of Object.entries(cg2.functions)) {
        const parsed = parser.parseLocationJSON(floc);
        if (parsed.loc && parsed.loc.start.line === 1 && parsed.loc.start.column === 0) {
            const prev = fileToModuleIndex[parsed.fileIndex]?.loc;
            if (prev === undefined || parsed.loc.end.line > prev.end.line ||
                (parsed.loc.end.line === prev.end.line && parsed.loc.end.column >= prev.end.column))
                fileToModuleIndex[parsed.fileIndex] = { index: Number(i), loc: parsed.loc };
        }
    }
    const Q = [];
    for (const [i, file] of cg2.files.entries())
        if (!/\bnode_modules\//.test(file)) {
            const mi = fileToModuleIndex[i];
            if (mi !== undefined)
                Q.push(mi.index);
            else
                logger_1.default.warn(`Unable to determine module function for ${file}`);
        }
    const funEdges = new Map();
    for (const [a, b] of cg2.fun2fun)
        (0, util_1.mapArrayAdd)(a, b, funEdges);
    const SCGreach = new Set(Q);
    while (Q.length) {
        const i = Q.pop();
        for (const ni of funEdges.get(i) ?? [])
            if (!SCGreach.has(ni)) {
                SCGreach.add(ni);
                Q.push(ni);
            }
    }
    if (logger_1.default.isDebugEnabled()) {
        logger_1.default.debug("Statically reachable functions:");
        for (const i of SCGreach)
            logger_1.default.debug(`\t${loc(cg2.functions[i], cg2).end}`);
    }
    let dcgReach = 0, comReach = 0;
    for (const [i, rawloc] of Object.entries(cg1.functions)) {
        const { start, file } = loc(rawloc, cg1);
        if (ignores.has(start) || !filter.isIncluded(file, false))
            continue;
        dcgReach++;
        if (Array.from(fun1ToFun2.get(Number(i)) ?? []).some(j => SCGreach.has(j)))
            comReach++;
        else
            logger_1.default.info(`Function ${start} is unreachable in ${file2}`);
    }
    function checkEdge(a, b, kind = "function", rloc) {
        const { start: aloc, file: file1 } = loc(cg1.functions[a], cg1);
        if (ignores.has(aloc) || !filter.isIncluded(file1, false) ||
            !Array.from(fun1ToFun2.get(a) ?? []).some(f => SCGreach.has(f)))
            return;
        const { start: bloc, file: file2 } = loc(cg1.functions[b], cg1);
        if (!ignores.has(bloc) && filter.isIncluded(file2, false) &&
            !Array.from(fun1ToFun2.get(b) ?? []).some(f => SCGreach.has(f)))
            logger_1.default.info(`Missed ${kind}->function edge ${rloc ?? aloc} -> ${bloc} could increase reachability recall`);
    }
    for (const [a, b] of cg1.fun2fun)
        checkEdge(a, b);
    const callFunIdx = (0, util_1.mapCallsToFunctions)(cg1);
    for (const [a, b] of cg1.call2fun) {
        const af = callFunIdx.get(a);
        if (af === undefined)
            continue;
        const { start } = loc(cg1.calls[a], cg1);
        checkEdge(af, b, "call", start);
    }
    return [dcgReach, SCGreach.size, comReach];
}
function compareCallGraphs(file1, file2, cg2, compareBothWays = true, compareReachability = false) {
    logger_1.default.info(`Comparing ${file1} and ${file2}`);
    const cg1 = JSON.parse((0, fs_1.readFileSync)(file1, "utf8"));
    cg2 ??= JSON.parse((0, fs_1.readFileSync)(file2, "utf8"));
    compareEntryArrays(cg1.entries ?? [], cg2.entries ?? [], file1, file2);
    if (compareBothWays)
        compareEntryArrays(cg2.entries ?? [], cg1.entries ?? [], file2, file1);
    const filter2 = compareFileArrays(cg1.files, cg2, file1, file2);
    const filter1 = compareBothWays && compareFileArrays(cg2.files, cg1, file2, file1) || undefined;
    const ignores = getIgnores(cg1, cg2);
    const [fun1ToFun2, fun2ToFun1] = matchLocationObjects(cg1, cg2, "functions", ignores);
    compareLocationObjects(fun1ToFun2, cg1, file1, file2, "Function", ignores, filter2);
    if (compareBothWays)
        compareLocationObjects(fun2ToFun1, cg2, file2, file1, "Function", ignores, filter1);
    const [call1ToCall2, call2ToCall1] = matchLocationObjects(cg1, cg2, "calls", ignores);
    compareLocationObjects(call1ToCall2, cg1, file1, file2, "Call", ignores, filter2);
    if (compareBothWays)
        compareLocationObjects(call2ToCall1, cg2, file2, file1, "Call", ignores, filter1);
    const [foundFun1, totalFun1, ignoredFun1] = compareEdges(file1, file2, cg1, cg2, "Function", fun1ToFun2, fun1ToFun2, ignores, filter2);
    const [foundFun2, totalFun2, ignoredFun2] = compareBothWays &&
        compareEdges(file2, file1, cg2, cg1, "Function", fun2ToFun1, fun2ToFun1, ignores, filter1) || [0, 0, 0];
    const [foundCall1, totalCall1, ignoredCall1] = compareEdges(file1, file2, cg1, cg2, "Call", call1ToCall2, fun1ToFun2, ignores, filter2);
    const [foundCall2, totalCall2, ignoredCall2] = compareBothWays &&
        compareEdges(file2, file1, cg2, cg1, "Call", call2ToCall1, fun2ToFun1, ignores, filter1) || [0, 0, 0];
    const [dcgReach, scgReach, comReach] = compareReachability && computeReachableFunctions(file2, cg1, cg2, fun1ToFun2, ignores, filter2) || [0, 0, 0];
    const formatFraction = (num, den) => `${num}/${den}${den === 0 ? "" : ` (${(0, util_1.percent)(num / den)})`}`;
    if (ignoredFun1 > 0 || ignoredCall1 > 0)
        logger_1.default.info(`Ignored in ${file1}: ${ignoredFun1} functions, ${ignoredCall1} calls`);
    if (ignoredFun2 > 0 || ignoredCall2 > 0)
        logger_1.default.info(`Ignored in ${file2}: ${ignoredFun2} functions, ${ignoredCall2} calls`);
    if (compareBothWays)
        logger_1.default.info(`Function->function edges in ${file2} that are also in ${file1}: ${formatFraction(foundFun2, totalFun2)}`);
    logger_1.default.info(`Function->function edges in ${file1} that are also in ${file2}: ${formatFraction(foundFun1, totalFun1)}`);
    if (compareBothWays)
        logger_1.default.info(`Call->function edges in ${file2} that are also in ${file1}: ${formatFraction(foundCall2, totalCall2)}`);
    logger_1.default.info(`Call->function edges in ${file1} that are also in ${file2}: ${formatFraction(foundCall1, totalCall1)}`);
    const { precision, recall } = compareCallSiteEdges(cg1, cg2, call2ToCall1, fun2ToFun1, ignores);
    logger_1.default.info(`Per-call average precision: ${(0, util_1.percent)(precision)}, recall: ${(0, util_1.percent)(recall)}`);
    if (compareReachability) {
        if (compareBothWays)
            logger_1.default.info(`Reachable functions and modules in ${file2} that are also in ${file1}: ${formatFraction(comReach, scgReach)}`);
        logger_1.default.info(`Functions and modules in ${file1} that are reachable in ${file2}: ${formatFraction(comReach, dcgReach)}`);
    }
    return {
        fun2funFound: foundFun1, fun2funTotal: totalFun1,
        call2funFound: foundCall1, call2funTotal: totalCall1,
        reachableFound: comReach, reachableTotal: dcgReach,
    };
}
exports.compareCallGraphs = compareCallGraphs;
//# sourceMappingURL=compare.js.map