"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.exportDataFlowGraphHtml = exports.exportCallGraphHtml = void 0;
const fs_1 = require("fs");
const infos_1 = require("../analysis/infos");
const util_1 = require("../misc/util");
const constraintvars_1 = require("../analysis/constraintvars");
const tokens_1 = require("../analysis/tokens");
const types_1 = require("@babel/types");
const vulnerabilities_1 = require("../typings/vulnerabilities");
const tostringwithcode_1 = require("./tostringwithcode");
function IdGenerator() {
    const ids = new Map();
    let next = 1;
    return (x) => {
        let t = ids.get(x);
        if (!t) {
            t = next++;
            ids.set(x, t);
        }
        return t;
    };
}
class Elements {
    elements = [];
    add(data) {
        this.elements.push({ data });
    }
}
function getReachable(f) {
    const reachable = new Set();
    const w = new Array();
    function reach(v) {
        if (!reachable.has(v)) {
            reachable.add(v);
            w.push(v);
        }
    }
    for (const e of f.a.entryFiles)
        reach(f.a.moduleInfosByPath.get(e));
    while (w.length > 0) {
        const v = w.pop();
        for (const n of [...f.requireGraph.get(v) || [], ...f.functionToFunction.get(v) || []])
            reach(n);
    }
    for (const m of f.a.moduleInfos.values())
        if (reachable.has(m))
            reachable.add(m.packageInfo);
    return reachable;
}
function isTrivialVar(v, ts, size, redir) {
    if (size > 1)
        return false;
    if (size === 0 || (v instanceof constraintvars_1.NodeVar && (0, types_1.isIdentifier)(v.node) && v.node.loc?.start.line === 0))
        return true;
    const first = ts[Symbol.iterator]().next().value;
    for (const w of [v, ...redir.get(v) ?? []])
        if (!(w instanceof constraintvars_1.ObjectPropertyVar && w.obj instanceof tokens_1.NativeObjectToken && first instanceof tokens_1.NativeObjectToken))
            return false;
    return true;
}
function getVisualizerCallGraph(f, vulnerabilities) {
    const functionCallCounts = new Map();
    const moduleCallCounts = new Map();
    const packageCallCounts = new Map();
    let maxFunctionCallCount = 1, maxModuleCallCount = 1, maxPackageCallCount = 1;
    for (const dsts of f.functionToFunction.values())
        for (const dst of dsts) {
            const fw = (0, util_1.getOrSet)(functionCallCounts, dst, () => 0) + 1;
            functionCallCounts.set(dst, fw);
            if (fw > maxFunctionCallCount)
                maxFunctionCallCount = fw;
            const fm = (0, util_1.getOrSet)(moduleCallCounts, dst.moduleInfo, () => 0) + 1;
            moduleCallCounts.set(dst.moduleInfo, fm);
            if (fm > maxModuleCallCount)
                maxModuleCallCount = fm;
            const fp = (0, util_1.getOrSet)(packageCallCounts, dst.packageInfo, () => 0) + 1;
            packageCallCounts.set(dst.packageInfo, fp);
            if (fp > maxPackageCallCount)
                maxPackageCallCount = fp;
        }
    for (const dsts of f.requireGraph.values())
        for (const dst of dsts) {
            const fm = (0, util_1.getOrSet)(moduleCallCounts, dst, () => 0) + 1;
            moduleCallCounts.set(dst, fm);
            if (fm > maxModuleCallCount)
                maxModuleCallCount = fm;
            const fp = (0, util_1.getOrSet)(packageCallCounts, dst.packageInfo, () => 0) + 1;
            packageCallCounts.set(dst.packageInfo, fp);
            if (fp > maxPackageCallCount)
                maxPackageCallCount = fp;
        }
    const reachable = getReachable(f);
    const id = IdGenerator();
    const e = new Elements();
    for (const p of f.a.packageInfos.values()) {
        const packageCallCount = packageCallCounts.get(p) ?? 0;
        e.add({
            id: id(p),
            kind: "package",
            name: p.name,
            fullName: p.toString(),
            callWeight: Math.round(100 * packageCallCount / maxPackageCallCount),
            callCount: packageCallCount,
            isEntry: p.isEntry ? "true" : undefined,
            isReachable: reachable.has(p) ? "true" : undefined
        });
    }
    function addFunction(n, parent) {
        const functionCallCount = functionCallCounts.get(n) ?? 0;
        e.add({
            id: id(n),
            kind: "function",
            parent: id(parent),
            name: (n.name ?? "<anon>") + ` ${(0, util_1.locationToString)(n.node.loc, false, true)}`,
            fullName: (0, tostringwithcode_1.funcToStringWithCode)(n),
            callWeight: Math.round(100 * functionCallCount / maxFunctionCallCount),
            callCount: functionCallCount,
            isReachable: reachable.has(n) ? "true" : undefined,
        });
        for (const fun of n.functions)
            addFunction(fun, n);
    }
    for (const m of f.a.moduleInfos.values()) {
        const moduleCallCount = moduleCallCounts.get(m) ?? 0;
        e.add({
            id: id(m),
            kind: "module",
            parent: id(m.packageInfo),
            name: m.relativePath,
            fullName: m.toString(),
            callWeight: Math.round(100 * moduleCallCount / maxModuleCallCount),
            callCount: moduleCallCount,
            isEntry: m.isEntry ? "true" : undefined,
            isReachable: reachable.has(m) ? "true" : undefined
        });
        for (const fun of m.functions)
            addFunction(fun, m);
    }
    let numEdges = 0;
    for (const [src, dsts] of f.functionToFunction)
        for (const dst of dsts) {
            e.add({
                kind: "call",
                source: id(src),
                target: id(dst)
            });
            numEdges++;
        }
    for (const [src, dsts] of f.requireGraph)
        for (const dst of dsts) {
            e.add({
                kind: "require",
                source: id(src),
                target: id(dst)
            });
            numEdges++;
        }
    let vuls;
    if (vulnerabilities.package && vulnerabilities.package.size > 0) {
        const relevant = new Set();
        const sources = new Map();
        const targets = new Map();
        function add(v, p, kind, m) {
            let x = m.get(v);
            if (!x) {
                x = { package: new Set(), module: new Set(), function: new Set() };
                m.set(v, x);
            }
            x[kind].add(p);
        }
        for (const ts of vulnerabilities.package.values())
            for (const vs of ts.values())
                (0, util_1.addAll)(vs, relevant);
        for (const [src, m] of vulnerabilities.package)
            for (const [dst, vs] of m)
                for (const v of vs) {
                    add(v, src, "package", sources);
                    add(v, dst, "package", targets);
                }
        if (vulnerabilities.module)
            for (const [src, m] of vulnerabilities.module)
                for (const [dst, vs] of m)
                    for (const v of vs) {
                        add(v, src, "module", sources);
                        add(v, dst, "module", targets);
                    }
        if (vulnerabilities.function)
            for (const [src, m] of vulnerabilities.function)
                for (const [dst, vs] of m)
                    for (const v of vs) {
                        add(v, src, "function", sources);
                        add(v, dst, "function", targets);
                    }
        vuls = [];
        for (const v of relevant) {
            const x = {
                title: (0, vulnerabilities_1.getVulnerabilityId)(v),
                package: { sources: [], targets: [] },
                module: { sources: [], targets: [] },
                function: { sources: [], targets: [] }
            };
            for (const kind of ["package", "module", "function"]) {
                const ss = sources.get(v);
                if (ss)
                    for (const s of ss[kind])
                        x[kind].sources.push(id(s));
                const ts = targets.get(v);
                if (ts)
                    for (const t of ts[kind])
                        x[kind].targets.push(id(t));
            }
            vuls.push(x);
        }
    }
    return {
        graphs: [{
                kind: "callgraph",
                elements: e.elements,
                info: `Packages: ${f.a.packageInfos.size}\nModules: ${f.a.moduleInfos.size}\nFunctions: ${f.a.functionInfos.size}\nCall edges: ${numEdges}\nMax number of calls for packages: ${maxPackageCallCount}, modules: ${maxModuleCallCount}, functions: ${maxFunctionCallCount}`,
                vulnerabilities: vuls
            }]
    };
}
function getVisualizerDataFlowGraphs(f) {
    let maxVariableCount = 1, maxModuleTokenCount = 1, maxPackageTokenCount = 1;
    const moduleTokenCounts = new Map();
    const packageTokenCounts = new Map();
    const nontrivialVars = new Set(), anyEdges = new Set();
    const parents = new Map();
    const redir = new Map();
    for (const [v, w] of f.redirections)
        (0, util_1.mapGetArray)(redir, f.getRepresentative(w)).push(v);
    for (const [v, ts, size] of f.getAllVarsAndTokens()) {
        if (!isTrivialVar(v, ts, size, redir)) {
            nontrivialVars.add(v);
            const p = f.a.getConstraintVarParent(v);
            if (p)
                parents.set(v, p);
        }
        if (size - 1 > maxVariableCount)
            maxVariableCount = size - 1;
    }
    for (const [src, dsts] of f.subsetEdges)
        for (const dst of dsts) {
            if (nontrivialVars.has(dst))
                anyEdges.add(src);
            if (nontrivialVars.has(src))
                anyEdges.add(dst);
        }
    const id = IdGenerator();
    const res = { graphs: [] };
    for (const p of f.a.packageInfos.values()) {
        let maxLocalVariableCount = 1, maxLocalModuleTokenCount = 1;
        const e = new Elements();
        const vars = new Set();
        for (const [v, , size] of f.getAllVarsAndTokens())
            if (nontrivialVars.has(v) && anyEdges.has(v)) {
                const parent = parents.get(v);
                if (parent === p || parent instanceof infos_1.ModuleInfo && parent.packageInfo === p) {
                    e.add({
                        id: id(v),
                        kind: "variable",
                        parent: id(parent),
                        fullName: (0, tostringwithcode_1.constraintVarToStringWithCode)(v),
                        tokenWeight: Math.floor(100 * (size - 1) / maxLocalVariableCount),
                        tokenCount: size
                    });
                    vars.add(v);
                    if (size - 1 > maxVariableCount)
                        maxVariableCount = size - 1;
                    if (size - 1 > maxLocalVariableCount)
                        maxLocalVariableCount = size - 1;
                    let pa;
                    if (parent instanceof infos_1.ModuleInfo) {
                        pa = parent.packageInfo;
                        const fm = (0, util_1.getOrSet)(moduleTokenCounts, parent, () => 0) + 1;
                        moduleTokenCounts.set(parent, fm);
                        if (fm > maxModuleTokenCount)
                            maxModuleTokenCount = fm;
                        if (fm > maxLocalModuleTokenCount)
                            maxLocalModuleTokenCount = fm;
                    }
                    else
                        pa = parent;
                    const pm = (0, util_1.getOrSet)(packageTokenCounts, pa, () => 0) + 1;
                    packageTokenCounts.set(pa, pm);
                    if (pm > maxPackageTokenCount)
                        maxPackageTokenCount = pm;
                }
            }
        let numFunctions = 0;
        for (const m of p.modules.values()) {
            const moduleTokenCount = moduleTokenCounts.get(m) ?? 0;
            e.add({
                id: id(m),
                kind: "module",
                parent: id(m.packageInfo),
                name: m.relativePath,
                fullName: m.toString(),
                tokenWeight: Math.floor(100 * (moduleTokenCount - 1) / maxLocalModuleTokenCount),
                tokenCount: moduleTokenCount
            });
            numFunctions += m.functions.size;
        }
        for (const [src, dsts] of f.subsetEdges)
            for (const dst of dsts)
                if (nontrivialVars.has(src) && nontrivialVars.has(dst) && anyEdges.has(src) && anyEdges.has(dst) && vars.has(src) && vars.has(dst))
                    e.add({
                        kind: "data",
                        source: id(src),
                        target: id(dst)
                    });
        res.graphs.push({
            title: p.toString(),
            kind: "dataflow",
            elements: e.elements,
            info: `Modules: ${p.modules.size}\nFunctions: ${numFunctions}\nVariables: ${vars.size}\nMax number of values for modules: ${maxLocalModuleTokenCount}, variables: ${maxLocalVariableCount}`
        });
    }
    res.graphs.sort((p1, p2) => p1.title.localeCompare(p2.title));
    const e = new Elements();
    for (const p of f.a.packageInfos.values()) {
        const packageTokenCount = packageTokenCounts.get(p) ?? 0;
        e.add({
            id: id(p),
            kind: "package",
            name: p.name,
            fullName: p.toString(),
            tokenWeight: Math.floor(100 * (packageTokenCount - 1) / maxPackageTokenCount),
            tokenCount: packageTokenCount
        });
    }
    for (const m of f.a.moduleInfos.values()) {
        const moduleTokenCount = moduleTokenCounts.get(m) ?? 0;
        e.add({
            id: id(m),
            kind: "module",
            parent: id(m.packageInfo),
            name: m.relativePath,
            fullName: m.toString(),
            tokenWeight: Math.floor(100 * (moduleTokenCount - 1) / maxModuleTokenCount),
            tokenCount: moduleTokenCount
        });
    }
    const numEdges = new Map();
    let maxNumEdges = 1;
    for (const [src, dsts] of f.subsetEdges) {
        const srcParent = parents.get(src);
        if (srcParent)
            for (const dst of dsts) {
                if (nontrivialVars.has(src) && nontrivialVars.has(dst) && anyEdges.has(src) && anyEdges.has(dst)) {
                    const dstParent = parents.get(dst);
                    if (dstParent) {
                        const source = id(srcParent), target = id(dstParent);
                        if (source !== target) {
                            const m = (0, util_1.mapGetMap)(numEdges, source);
                            const w = (0, util_1.getOrSet)(m, target, () => 0) + 1;
                            m.set(target, w);
                            if (w > maxNumEdges)
                                maxNumEdges = w;
                        }
                    }
                }
            }
    }
    for (const [src, m] of numEdges)
        for (const [dst, n] of m)
            e.add({
                kind: "data",
                source: src,
                target: dst,
                weight: Math.floor(100 * n / maxNumEdges)
            });
    res.graphs.unshift({
        title: "Packages and modules",
        kind: "dataflow",
        elements: e.elements,
        info: `Packages: ${f.a.packageInfos.size}\nModules: ${f.a.moduleInfos.size}\nFunctions: ${f.a.functionInfos.size}\nMax number of values for packages: ${maxPackageTokenCount}, modules: ${maxModuleTokenCount}, variables: ${maxVariableCount}`
    });
    return res;
}
function writeVisualizerHtml(filename, g) {
    const DATA = "$DATA";
    const templateFile = __dirname + "/../../resources/visualizer.html";
    const t = (0, fs_1.readFileSync)(templateFile, "utf-8");
    const i = t.indexOf(DATA);
    const res = t.substring(0, i) + JSON.stringify(g) + t.substring(i + DATA.length);
    (0, fs_1.writeFileSync)(filename, res);
}
function exportCallGraphHtml(f, filename, vulnerabilities) {
    writeVisualizerHtml(filename, getVisualizerCallGraph(f, vulnerabilities));
}
exports.exportCallGraphHtml = exportCallGraphHtml;
function exportDataFlowGraphHtml(f, filename) {
    writeVisualizerHtml(filename, getVisualizerDataFlowGraphs(f));
}
exports.exportDataFlowGraphHtml = exportDataFlowGraphHtml;
//# sourceMappingURL=visualizer.js.map