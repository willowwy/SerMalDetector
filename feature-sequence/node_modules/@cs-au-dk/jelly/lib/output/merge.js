"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.merge = void 0;
const assert_1 = __importDefault(require("assert"));
function merge(callgraphs) {
    const result = {
        entries: [],
        files: [],
        functions: [],
        calls: [],
        fun2fun: [],
        call2fun: [],
        ignore: []
    };
    const fun2fun = new Map();
    const call2fun = new Map();
    for (const cg of callgraphs) {
        if (cg.entries)
            for (const entry of cg.entries)
                if (result.entries?.indexOf(entry) === -1)
                    result.entries.push(entry);
        const fileMap = new Map();
        if (cg.files) {
            for (let originalId = 0; originalId < cg.files.length; originalId++) {
                const file = cg.files[originalId];
                assert_1.default.ok(file);
                let resultId = result.files?.indexOf(file);
                if (resultId === -1) {
                    resultId = result.files.length;
                    result.files.push(file);
                }
                assert_1.default.equal(result.files[resultId], file);
                fileMap.set(originalId, resultId);
            }
        }
        const translate = (loc) => {
            const i = loc.indexOf(":");
            assert_1.default.notEqual(i, -1);
            const originalFileId = parseInt(loc.substring(0, i));
            const newFileId = fileMap.get(originalFileId);
            assert_1.default.notEqual(newFileId, undefined);
            return String(newFileId) + loc.substring(i);
        };
        const functionsMap = new Map();
        if (cg.functions) {
            for (const originalIdStr of Object.keys(cg.functions)) {
                const originalId = parseInt(originalIdStr);
                let fn = cg.functions[originalId];
                assert_1.default.ok(fn);
                fn = translate(fn);
                let resultId = result.functions.indexOf(fn);
                if (resultId === -1) {
                    resultId = result.functions.length;
                    result.functions.push(fn);
                }
                assert_1.default.equal(result.functions[resultId], fn);
                functionsMap.set(originalId, resultId);
            }
        }
        const callsMap = new Map();
        if (cg.calls) {
            for (const originalIdStr of Object.keys(cg.calls)) {
                const originalId = parseInt(originalIdStr);
                const call = translate(cg.calls[originalId]);
                let resultId = result.calls.indexOf(call);
                if (resultId === -1) {
                    resultId = result.calls.length;
                    result.calls.push(call);
                }
                callsMap.set(originalId, resultId);
            }
        }
        if (cg.fun2fun)
            for (const [u, v] of cg.fun2fun)
                if (functionsMap.has(u) && functionsMap.has(v)) {
                    const e = [functionsMap.get(u), functionsMap.get(v)];
                    fun2fun.set(e.join(","), e);
                }
        if (cg.call2fun)
            for (const [u, v] of cg.call2fun)
                if (callsMap.has(u) && functionsMap.has(v)) {
                    const e = [callsMap.get(u), functionsMap.get(v)];
                    call2fun.set(e.join(","), e);
                }
        if (cg.ignore)
            for (const ignoreLoc of cg.ignore.map(translate))
                if (result.ignore?.indexOf(ignoreLoc) == -1)
                    result.ignore.push(ignoreLoc);
    }
    result.fun2fun = [...fun2fun.values()];
    result.call2fun = [...call2fun.values()];
    const firstTime = callgraphs[0]?.time;
    if (firstTime !== undefined)
        result.time = firstTime;
    return result;
}
exports.merge = merge;
//# sourceMappingURL=merge.js.map