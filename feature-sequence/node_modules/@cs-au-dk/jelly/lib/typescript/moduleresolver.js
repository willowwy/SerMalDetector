"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TSModuleResolver = void 0;
const node_path_1 = require("node:path");
const node_fs_1 = __importDefault(require("node:fs"));
const typescript_1 = __importDefault(require("typescript"));
const options_1 = require("../options");
const logger_1 = __importDefault(require("../misc/logger"));
const host = typescript_1.default.createCompilerHost({});
const parseConfigHost = {
    fileExists: host.fileExists,
    readDirectory: typescript_1.default.sys.readDirectory,
    readFile: host.readFile,
    useCaseSensitiveFileNames: host.useCaseSensitiveFileNames(),
};
class TSModuleResolver {
    tsconfigCache = new Map();
    getTSOptions(file) {
        let opts = {
            module: typescript_1.default.ModuleKind.NodeNext,
        };
        const misses = [];
        let dir = file;
        while ((dir = (0, node_path_1.dirname)(dir)).startsWith(options_1.options.basedir)) {
            const cached = this.tsconfigCache.get(dir);
            if (cached !== undefined) {
                opts = cached;
                break;
            }
            misses.push(dir);
            const tsconfig = (0, node_path_1.join)(dir, "tsconfig.json");
            if (node_fs_1.default.existsSync(tsconfig)) {
                const res = typescript_1.default.readConfigFile(tsconfig, host.readFile);
                if (!res.error)
                    opts = typescript_1.default.parseJsonConfigFileContent(res.config, parseConfigHost, dir).options;
                else
                    logger_1.default.warn(`Warning: Unable to read ${tsconfig} (${typescript_1.default.formatDiagnostic(res.error, host)})`);
                break;
            }
            if (dir == (0, node_path_1.dirname)(dir) || (0, node_path_1.basename)(dir) === "node_modules")
                break;
        }
        opts.allowJs = true;
        opts.checkJs = true;
        opts.noDtsResolution = true;
        for (const miss of misses)
            this.tsconfigCache.set(miss, opts);
        return opts;
    }
    resolveModuleName(str, file) {
        const opts = this.getTSOptions(file);
        const resolutionMode = typescript_1.default.getImpliedNodeFormatForFile(file, undefined, host, opts);
        const t = str.endsWith(".ts") && resolutionMode !== typescript_1.default.ModuleKind.ESNext ? str.substring(0, str.length - 3) : str;
        const filepath = typescript_1.default.resolveModuleName(t, file, opts, host, undefined, undefined, resolutionMode).resolvedModule?.resolvedFileName;
        if (!filepath || (filepath.endsWith(".d.ts") && !str.endsWith(".d.ts")))
            throw new Error();
        return filepath;
    }
}
exports.TSModuleResolver = TSModuleResolver;
//# sourceMappingURL=moduleresolver.js.map