"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TypeScriptTypeInferrer = void 0;
const ts = __importStar(require("typescript"));
const typescript_1 = require("typescript");
const logger_1 = __importStar(require("../misc/logger"));
const util_1 = require("../misc/util");
const path_1 = require("path");
const timer_1 = __importDefault(require("../misc/timer"));
const patterns_1 = require("../patternmatching/patterns");
const fs_1 = require("fs");
const options_1 = require("../options");
class TypeScriptTypeInferrer {
    program;
    checker;
    files = new Map();
    timer = new timer_1.default();
    constructor(files) {
        (0, logger_1.writeStdOutIfActive)("Parsing as TypeScript...");
        logger_1.default.info("Parsing as TypeScript");
        const tsconfig = ts.findConfigFile(options_1.options.basedir, ts.sys.fileExists);
        const inside = tsconfig && tsconfig.startsWith(options_1.options.basedir);
        if (tsconfig && inside)
            logger_1.default.verbose(`Using ${tsconfig}`);
        this.program = tsconfig && inside ? this.createProgram(tsconfig) :
            ts.createProgram(files.map(f => (0, path_1.resolve)(options_1.options.basedir, f)), {
                target: ts.ScriptTarget.ES5,
                module: ts.ModuleKind.CommonJS,
                allowJs: true,
                checkJs: true
            });
        this.checker = this.program.getTypeChecker();
        if (logger_1.default.isDebugEnabled())
            logger_1.default.debug("Parsed files (excluding declaration files):");
        for (const file of this.program.getSourceFiles())
            if (!file.isDeclarationFile) {
                this.files.set(file.fileName, file);
                logger_1.default.debug(file.fileName);
            }
        logger_1.default.info(`TypeScript parsing time: ${this.timer.elapsed()}ms, files: ${this.program.getSourceFiles().length}`);
    }
    createProgram(tsconfigPath) {
        const tsConfig = ts.readConfigFile(tsconfigPath, ts.sys.readFile);
        const configHostParser = {
            fileExists: fs_1.existsSync,
            readDirectory: ts.sys.readDirectory,
            readFile: file => (0, fs_1.readFileSync)(file, 'utf8'),
            useCaseSensitiveFileNames: process.platform === 'linux'
        };
        const tsConfigParsed = ts.parseJsonConfigFileContent(tsConfig.config, configHostParser, (0, path_1.resolve)((0, path_1.dirname)(tsconfigPath)), { noEmit: true });
        const compilerHost = ts.createCompilerHost(tsConfigParsed.options, true);
        return ts.createProgram(tsConfigParsed.fileNames, tsConfigParsed.options, compilerHost);
    }
    getTypeAtTSNode(node, loc) {
        try {
            return this.checker.getTypeAtLocation(node);
        }
        catch (e) {
            logger_1.default.error(`TypeScript internal error while querying type at ${typeof loc === "string" ? loc : (0, util_1.locationToStringWithFileAndEnd)(loc)}: ${e}`);
            return undefined;
        }
    }
    getType(loc) {
        const file = "module" in loc && this.files.get(loc.module.getPath());
        if (!file)
            return undefined;
        try {
            const start = file.getPositionOfLineAndCharacter(loc.start.line - 1, loc.start.column);
            const end = file.getPositionOfLineAndCharacter(loc.end.line - 1, loc.end.column);
            let node = ts.getTokenAtPosition(file, start);
            while (node && node.end < end)
                node = node.parent;
            if (!node)
                return undefined;
            const posLineChar = file.getLineAndCharacterOfPosition(node.getStart());
            const endLineChar = file.getLineAndCharacterOfPosition(node.getEnd());
            if (logger_1.default.isVerboseEnabled() &&
                posLineChar.line + 1 !== loc.start.line ||
                posLineChar.character !== loc.start.column ||
                endLineChar.line + 1 !== loc.end.line ||
                endLineChar.character !== loc.end.column)
                logger_1.default.verbose(`TypeScript AST node misaligned: ${file.fileName}:${posLineChar.line + 1}:${posLineChar.character + 1}:${endLineChar.line + 1}:${endLineChar.character + 1}, expected ${(0, util_1.locationToStringWithFileAndEnd)(loc)}`);
            const type = this.getTypeAtTSNode(node, loc);
            if (logger_1.default.isDebugEnabled())
                logger_1.default.debug(`TypeScript type at ${(0, util_1.locationToStringWithFileAndEnd)(loc)}: ${type ? this.checker.typeToString(type) : "???"}`);
            return type;
        }
        catch {
            return undefined;
        }
    }
    convertType(type) {
        if (!type)
            return undefined;
        if (type.flags & typescript_1.TypeFlags.Any && !(type.symbol && type.symbol.flags & typescript_1.SymbolFlags.Transient))
            return patterns_1.Type.makeSimpleType("any");
        if (type.flags & (typescript_1.TypeFlags.String | typescript_1.TypeFlags.TemplateLiteral))
            return patterns_1.Type.makeSimpleType("string");
        if (type.flags & typescript_1.TypeFlags.Number)
            return patterns_1.Type.makeSimpleType("number");
        if (type.flags & typescript_1.TypeFlags.Boolean)
            return patterns_1.Type.makeSimpleType("boolean");
        if (type.flags & typescript_1.TypeFlags.Undefined)
            return patterns_1.Type.makeSimpleType("undefined");
        if (type.flags & typescript_1.TypeFlags.Null)
            return patterns_1.Type.makeSimpleType("null");
        if (type.flags & (typescript_1.TypeFlags.StringLiteral | typescript_1.TypeFlags.NumberLiteral))
            return patterns_1.Type.makeValueType(type.value);
        if (type.flags & typescript_1.TypeFlags.BooleanLiteral) {
            const intrinsicName = type.intrinsicName;
            if (intrinsicName === "true")
                return patterns_1.Type.makeValueType(true);
            if (intrinsicName === "false")
                return patterns_1.Type.makeValueType(false);
        }
        if (type.flags & typescript_1.TypeFlags.Object && type.symbol) {
            if (type.symbol.escapedName === "Array")
                return patterns_1.Type.makeSimpleType("array");
            if (type.symbol.escapedName === "__object")
                return patterns_1.Type.makeSimpleType("object");
            if (type.symbol.flags & (typescript_1.SymbolFlags.Function | typescript_1.SymbolFlags.Method))
                return patterns_1.Type.makeSimpleType("function", undefined);
            if (type.symbol.flags & (typescript_1.SymbolFlags.Interface | typescript_1.SymbolFlags.Class | typescript_1.SymbolFlags.RegularEnum))
                return patterns_1.Type.makeTSType(type.symbol.escapedName);
        }
        if (type.aliasSymbol)
            return patterns_1.Type.makeTSType(type.aliasSymbol.escapedName);
        return undefined;
    }
    getLibraryUsage() {
        const res = new Map();
        const program = this.program;
        const checker = this.checker;
        for (const file of this.files.values()) {
            function visit(node) {
                function getLoc(start, end) {
                    return `${file.fileName}:${start.line + 1}:${start.character + 1}:${end.line + 1}:${end.character + 1}`;
                }
                function visitType(type) {
                    if (type.isUnionOrIntersection()) {
                        for (const t of type.types)
                            visitType(t);
                    }
                    else if (!(type.flags & typescript_1.TypeFlags.Any)) {
                        const declFile = type.symbol?.getDeclarations()?.[0]?.getSourceFile().fileName;
                        if (declFile) {
                            const packageFile = program.sourceFileToPackageName.get(declFile);
                            if (packageFile) {
                                const i1 = packageFile.indexOf("/");
                                const i2 = packageFile.startsWith("@") ? packageFile.indexOf("/", i1 + 1) : i1;
                                const packageName = packageFile.substring(0, i2);
                                const start = file.getLineAndCharacterOfPosition(node.getStart());
                                const end = file.getLineAndCharacterOfPosition(node.getEnd());
                                (0, util_1.mapArrayAdd)(packageName, [{
                                        filename: file.fileName,
                                        start: { line: start.line + 1, column: start.character },
                                        end: { line: end.line + 1, column: end.character }
                                    },
                                    type], res);
                                if (logger_1.default.isVerboseEnabled())
                                    logger_1.default.verbose(`${getLoc(start, end)}: ${checker.typeToString(type)} in ${packageName}, type.flags=${type.flags}, type.symbol.flags=${type.symbol?.flags}`);
                                return;
                            }
                        }
                    }
                }
                try {
                    visitType(checker.getTypeAtLocation(node));
                }
                catch (e) {
                    logger_1.default.warn(`TypeScript internal error while querying type: ${e}`);
                }
                ts.forEachChild(node, visit);
            }
            ts.forEachChild(file, visit);
        }
        return res;
    }
    libraryUsageToJSON(u) {
        const res = { files: [], packages: {} };
        const locs = new util_1.SourceLocationsToJSON(res.files);
        for (const [p, as] of u) {
            const bs = [];
            for (const [loc, type] of as)
                bs.push([locs.makeLocString(loc), this.checker.typeToString(type)]);
            res.packages[p] = bs;
        }
        return res;
    }
}
exports.TypeScriptTypeInferrer = TypeScriptTypeInferrer;
//# sourceMappingURL=typeinferrer.js.map