"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.expressionMatchesType = void 0;
const types_1 = require("@babel/types");
const patterns_1 = require("./patterns");
const util_1 = require("../misc/util");
const astpatterns_1 = require("./astpatterns");
const logger_1 = __importDefault(require("../misc/logger"));
function getType(n, typer) {
    let t1;
    const valueType = (0, astpatterns_1.getValueType)(n);
    if (valueType !== undefined)
        t1 = new patterns_1.Type(undefined, undefined, valueType, undefined);
    else {
        const simpleType = (0, astpatterns_1.getSimpleType)(n);
        if (simpleType !== undefined)
            t1 = new patterns_1.Type(simpleType, simpleType === "function" ? (0, astpatterns_1.getNumberOfFunctionParams)(n) : undefined, undefined, undefined);
    }
    const t2 = typer && n.loc ? typer.convertType(typer.getType(n.loc)) : undefined;
    if (t1) {
        if (t2) {
            if (logger_1.default.isDebugEnabled() && t1.toString() !== t2.toString() &&
                !(t1.simpleType === "function" && t2.simpleType === "function" && t1.functionArgs !== undefined && t2.functionArgs === undefined) &&
                !(t1.simpleType === "empty-array" && t2.simpleType === "array"))
                logger_1.default.debug(`Inferred types differ at ${(0, util_1.locationToStringWithFileAndEnd)(n.loc)}: ${t1} <-> ${t2}`);
            const m12 = matches(t1, t2);
            const m21 = matches(t2, t1);
            if (m12 === util_1.Ternary.False || m21 === util_1.Ternary.False)
                logger_1.default.warn(`Warning: Incompatible types inferred at ${(0, util_1.locationToStringWithFileAndEnd)(n.loc)}: ${t1} <-> ${t2}`);
            else if (matches(t2, t1) === util_1.Ternary.True) {
                if (logger_1.default.isDebugEnabled() && t1.toString() !== t2.toString())
                    logger_1.default.debug(`Choosing TypeScript type ${t2} over ${t1}`);
                return t2;
            }
        }
        else if (typer)
            logger_1.default.warn(`Warning: No TypeScript type inferred for ${t1} at ${(0, util_1.locationToStringWithFileAndEnd)(n.loc)}`);
        return t1;
    }
    else {
        if (logger_1.default.isDebugEnabled() && t2 && (t2.simpleType !== undefined || t2.valueType !== undefined))
            logger_1.default.debug(`No pattern type inferred for ${t2} at ${(0, util_1.locationToStringWithFileAndEnd)(n.loc)}`);
        return t2;
    }
}
function matches(t1, t2) {
    if (t2.simpleType === "any" ||
        (t1.simpleType !== undefined && t1.simpleType === t2.simpleType && (t1.simpleType !== "function" || t2.functionArgs === undefined || t1.functionArgs === t2.functionArgs)) ||
        (t1.valueType !== undefined && t1.valueType === t2.valueType) ||
        (t1.valueType !== undefined && typeof t1.valueType === t2.simpleType) ||
        (t1.simpleType === "empty-array" && t2.simpleType === "array") ||
        (t1.tsType !== undefined && t1.tsType === t2.tsType))
        return util_1.Ternary.True;
    if (t1.simpleType === "any" ||
        (t2.simpleType && t2.simpleType === t1.simpleType && (t2.simpleType !== "function" || t1.functionArgs === undefined || t2.functionArgs === t1.functionArgs)) ||
        (t2.valueType !== undefined && t2.valueType === t1.valueType) ||
        (t2.valueType !== undefined && typeof t2.valueType === t1.simpleType) ||
        (t2.simpleType === "empty-array" && t1.simpleType === "array") ||
        (t2.tsType !== undefined && (t1.tsType !== undefined || t1.simpleType === "object" || t1.simpleType === "array" || t1.simpleType === "function")))
        return util_1.Ternary.Maybe;
    return util_1.Ternary.False;
}
function expressionMatchesType(n, props, ts, typer) {
    const m = (0, astpatterns_1.followProps)(n, props);
    if (!(0, types_1.isNode)(m))
        return m;
    const mt = getType(m, typer);
    if (!mt)
        return util_1.Ternary.Maybe;
    let res = util_1.Ternary.False;
    for (const t of ts) {
        if (t.tsType && !typer)
            logger_1.default.error("Error: Pattern uses TypeScript type, but TypeScript type inference is not enabled (see option --typescript)");
        res = (0, util_1.ternaryOr)(res, matches(mt, t));
    }
    if (logger_1.default.isDebugEnabled())
        logger_1.default.debug(`expressionMatchesType node: ${(0, util_1.locationToStringWithFileAndEnd)(n.loc)}, type: ${ts.join(",")}, result: ${(0, util_1.ternaryToString)(res)}`);
    return res;
}
exports.expressionMatchesType = expressionMatchesType;
//# sourceMappingURL=typematcher.js.map