"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.reportAccessPaths = exports.reportAPIExportedFunctions = exports.getAPIExported = void 0;
const patternparser_1 = require("./patternparser");
const tokens_1 = require("../analysis/tokens");
const patterns_1 = require("./patterns");
const logger_1 = __importDefault(require("../misc/logger"));
const util_1 = require("../misc/util");
const constraintvars_1 = require("../analysis/constraintvars");
const path_1 = require("path");
const infos_1 = require("../analysis/infos");
const assert_1 = __importDefault(require("assert"));
const ecmascript_1 = require("../natives/ecmascript");
const MAX_ACCESS_PATHS = 10;
function getAPIExported(f) {
    logger_1.default.info("Collecting exported API");
    const c = new patternparser_1.AccessPathPatternCanonicalizer;
    const res = new Map();
    const worklist = new Map();
    function add(v, ap) {
        for (const t of f.getTokens(f.getRepresentative(v)))
            if (t instanceof tokens_1.NativeObjectToken || t instanceof tokens_1.AllocationSiteToken || t instanceof tokens_1.FunctionToken || t instanceof tokens_1.PackageObjectToken) {
                const aps = (0, util_1.mapGetSet)(res, t);
                let prefix = ap;
                do {
                    if (aps.has(prefix))
                        return;
                    if (prefix instanceof patterns_1.PropertyAccessPathPattern)
                        prefix = prefix.base;
                    else if (prefix instanceof patterns_1.CallResultAccessPathPattern)
                        prefix = prefix.fun;
                } while (!(prefix instanceof patterns_1.ImportAccessPathPattern));
                if (aps.size + 1 >= MAX_ACCESS_PATHS) {
                    logger_1.default.debug(`Reached ${MAX_ACCESS_PATHS} access paths for ${t}, skipping remaining ones`);
                    if (aps.size >= MAX_ACCESS_PATHS)
                        continue;
                }
                if (logger_1.default.isDebugEnabled())
                    logger_1.default.debug(`Added access path for ${t}: ${ap}`);
                if (logger_1.default.isVerboseEnabled())
                    if (t instanceof tokens_1.FunctionToken)
                        logger_1.default.info(`Access path for ${t.fun.type} at ${(0, util_1.locationToStringWithFileAndEnd)(t.fun.loc)}: ${ap}`);
                aps.add(ap);
                (0, util_1.mapGetSet)(worklist, t).add(ap);
            }
    }
    for (const m of f.a.moduleInfos.values())
        add(f.varProducer.objPropVar(f.a.canonicalizeToken(new tokens_1.NativeObjectToken("module", m)), "exports"), c.canonicalize(new patterns_1.ImportAccessPathPattern(m.getOfficialName())));
    for (const [t, aps] of worklist)
        for (const ap of aps) {
            aps.delete(ap);
            if (aps.size === 0)
                worklist.delete(t);
            for (const prop of f.objectProperties.get(t) ?? [])
                if (!(0, ecmascript_1.isInternalProperty)(prop))
                    add(f.varProducer.objPropVar(t, prop), c.canonicalize(new patterns_1.PropertyAccessPathPattern(ap, [prop])));
            if (t instanceof tokens_1.FunctionToken)
                add(f.a.canonicalizeVar(new constraintvars_1.FunctionReturnVar(t.fun)), c.canonicalize(new patterns_1.CallResultAccessPathPattern(ap)));
        }
    return res;
}
exports.getAPIExported = getAPIExported;
function reportAPIExportedFunctions(r) {
    for (const [t, aps] of r)
        for (const ap of aps)
            if (t instanceof tokens_1.FunctionToken)
                logger_1.default.info(`${(0, util_1.locationToStringWithFileAndEnd)(t.fun.loc)}: ${ap}`);
}
exports.reportAPIExportedFunctions = reportAPIExportedFunctions;
function findFunctionAtLocation(a, loc) {
    const i = loc.lastIndexOf(":");
    if (i != -1) {
        const file = (0, path_1.resolve)(loc.substring(0, i));
        const line = parseInt(loc.substring(i + 1), 10);
        const modinfo = a.moduleInfosByPath.get(file);
        if (line > 0 && modinfo && modinfo.node?.loc && line <= modinfo.node.loc.end.line) {
            let best = modinfo;
            for (const [fun, funinfo] of a.functionInfos)
                if (fun.loc && (0, util_1.locationContains)(fun.loc, file, line))
                    if (best.node.loc.start.line < fun.loc.start.line || fun.loc.end.line < best.node.loc.end.line)
                        best = funinfo;
            return best;
        }
    }
    return undefined;
}
function getReverseGraph(g) {
    const r = new Map();
    for (const [from, tos] of g)
        for (const to of tos)
            (0, util_1.mapGetSet)(r, to).add(from);
    return r;
}
function findReachingFunctions(f, fun) {
    const callers = getReverseGraph(f.functionToFunction);
    const requires = getReverseGraph(f.requireGraph);
    const r = new Map();
    const w = new Set();
    r.set(fun, new Set());
    w.add(fun);
    for (const f of w) {
        w.delete(f);
        const ps = f instanceof infos_1.FunctionInfo ? callers.get(f) : requires.get(f);
        if (ps)
            for (const p of ps) {
                if (!r.has(p))
                    w.add(p);
                (0, util_1.mapGetSet)(r, p).add(f);
            }
    }
    return r;
}
function reportAccessPaths(f, r, loc) {
    const fun = findFunctionAtLocation(f.a, loc);
    if (!fun) {
        logger_1.default.error(`Location ${loc} not found`);
        return;
    }
    if (logger_1.default.isDebugEnabled())
        logger_1.default.debug(`${loc} belongs to ${fun}`);
    const reach = findReachingFunctions(f, fun);
    logger_1.default.info(`Functions that may reach ${loc} (nearest first):`);
    for (const [f, ns] of reach) {
        logger_1.default.info(` ${f}`);
        for (const n of ns)
            logger_1.default.info(`  â†³ ${n}`);
    }
    logger_1.default.info(`Access paths that may reach ${loc}:`);
    for (const m of reach.keys())
        if (m instanceof infos_1.ModuleInfo)
            logger_1.default.info(` ${new patterns_1.ImportAccessPathPattern(m.getOfficialName())}`);
    let more = false;
    const all = new Set();
    for (const [t, aps] of r)
        if (t instanceof tokens_1.FunctionToken) {
            const n = f.a.functionInfos.get(t.fun);
            (0, assert_1.default)(n);
            if (reach.has(n)) {
                for (const ap of aps)
                    all.add(ap.toString());
                if (aps.size >= MAX_ACCESS_PATHS)
                    more = true;
            }
        }
    for (const ap of Array.from(all).sort())
        logger_1.default.info(` ${ap}`);
    if (more)
        logger_1.default.info(" ...");
}
exports.reportAccessPaths = reportAccessPaths;
//# sourceMappingURL=apiexported.js.map