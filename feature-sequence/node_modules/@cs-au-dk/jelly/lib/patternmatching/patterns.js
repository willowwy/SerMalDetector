"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Type = exports.FilterSelector = exports.TypeFilter = exports.NumArgsCallFilter = exports.Filter = exports.PotentiallyUnknownAccessPathPattern = exports.WildcardAccessPathPattern = exports.ExclusionAccessPathPattern = exports.DisjunctionAccessPathPattern = exports.AbbreviatedPathPattern = exports.ComponentAccessPathPattern = exports.CallResultAccessPathPattern = exports.PropertyAccessPathPattern = exports.ImportAccessPathPattern = exports.CallDetectionPattern = exports.WriteDetectionPattern = exports.ReadDetectionPattern = exports.ImportDetectionPattern = exports.DetectionPattern = void 0;
const assert_1 = __importDefault(require("assert"));
class DetectionPattern {
    ap;
    constructor(ap) {
        this.ap = ap;
    }
}
exports.DetectionPattern = DetectionPattern;
class ImportDetectionPattern extends DetectionPattern {
    onlyDefault;
    constructor(ap, onlyDefault) {
        super(ap);
        this.onlyDefault = onlyDefault;
    }
    toString() {
        return `import${this.onlyDefault ? "D" : ""} ${this.ap}`;
    }
}
exports.ImportDetectionPattern = ImportDetectionPattern;
class ReadDetectionPattern extends DetectionPattern {
    notInvoked;
    baseFilter;
    constructor(ap, notInvoked, baseFilter) {
        super(ap);
        this.notInvoked = notInvoked;
        this.baseFilter = baseFilter;
    }
    toString() {
        const base = this.baseFilter ? ` base:${this.baseFilter.length === 1 ? this.baseFilter[0] : `{${this.baseFilter.join(",")}`}` : "";
        return `read${this.notInvoked ? "O" : ""} ${this.ap}${base}`;
    }
}
exports.ReadDetectionPattern = ReadDetectionPattern;
class WriteDetectionPattern extends DetectionPattern {
    valueFilter;
    baseFilter;
    constructor(ap, valueFilter, baseFilter) {
        super(ap);
        this.valueFilter = valueFilter;
        this.baseFilter = baseFilter;
    }
    toString() {
        const base = this.baseFilter ? ` base:${this.baseFilter.length === 1 ? this.baseFilter[0] : `{${this.baseFilter.join(",")}`}` : "";
        const value = this.valueFilter ? ` value:${this.valueFilter.length === 1 ? this.valueFilter[0] : `{${this.valueFilter.join(",")}`}` : "";
        return `write ${this.ap}${base}${value}`;
    }
}
exports.WriteDetectionPattern = WriteDetectionPattern;
class CallDetectionPattern extends DetectionPattern {
    onlyReturnChanged;
    onlyWhenUsedAsPromise;
    onlyNonNewCalls;
    filters;
    constructor(ap, onlyReturnChanged, onlyWhenUsedAsPromise, onlyNonNewCalls, filters) {
        super(ap);
        this.onlyReturnChanged = onlyReturnChanged;
        this.onlyWhenUsedAsPromise = onlyWhenUsedAsPromise;
        this.onlyNonNewCalls = onlyNonNewCalls;
        this.filters = filters;
    }
    toString() {
        return `call${this.onlyReturnChanged ? "R" : this.onlyWhenUsedAsPromise ? "Promise" : this.onlyNonNewCalls ? "NotNew" : ""} ${this.ap}${this.filters && this.filters.length > 0 ? " " + this.filters.join(" ") : ""}`;
    }
}
exports.CallDetectionPattern = CallDetectionPattern;
class ImportAccessPathPattern {
    glob;
    constructor(glob) {
        this.glob = glob;
    }
    toString() {
        return `<${this.glob}>`;
    }
    visitAccessPathPatterns(visitor) {
        visitor(this);
    }
}
exports.ImportAccessPathPattern = ImportAccessPathPattern;
class PropertyAccessPathPattern {
    base;
    props;
    constructor(base, props) {
        this.base = base;
        this.props = props;
    }
    toString() {
        return `${this.base}.${this.props.length === 1 ? `${this.props[0]}` : `{${this.props.join(',')}}`}`;
    }
    visitAccessPathPatterns(visitor) {
        visitor(this);
        this.base.visitAccessPathPatterns(visitor);
    }
}
exports.PropertyAccessPathPattern = PropertyAccessPathPattern;
class CallResultAccessPathPattern {
    fun;
    constructor(fun) {
        this.fun = fun;
    }
    toString() {
        return `${this.fun}()`;
    }
    visitAccessPathPatterns(visitor) {
        visitor(this);
        this.fun.visitAccessPathPatterns(visitor);
    }
}
exports.CallResultAccessPathPattern = CallResultAccessPathPattern;
class ComponentAccessPathPattern {
    component;
    constructor(component) {
        this.component = component;
    }
    toString() {
        return `${this.component}<>`;
    }
    visitAccessPathPatterns(visitor) {
        visitor(this);
        this.component.visitAccessPathPatterns(visitor);
    }
}
exports.ComponentAccessPathPattern = ComponentAccessPathPattern;
class AbbreviatedPathPattern {
    prefix;
    constructor(prefix) {
        this.prefix = prefix;
    }
    toString() {
        return `${this.prefix}â€¦`;
    }
    visitAccessPathPatterns(visitor) {
        visitor(this);
        this.prefix.visitAccessPathPatterns(visitor);
    }
}
exports.AbbreviatedPathPattern = AbbreviatedPathPattern;
class DisjunctionAccessPathPattern {
    aps;
    constructor(aps) {
        this.aps = aps;
    }
    toString() {
        return `{${this.aps.map((ap) => ap.toString()).join(',')}}`;
    }
    visitAccessPathPatterns(visitor) {
        visitor(this);
        for (const ap of this.aps)
            ap.visitAccessPathPatterns(visitor);
    }
}
exports.DisjunctionAccessPathPattern = DisjunctionAccessPathPattern;
class ExclusionAccessPathPattern {
    include;
    exclude;
    constructor(include, exclude) {
        this.include = include;
        this.exclude = exclude;
        this.include = include;
        this.exclude = exclude;
    }
    toString() {
        return `(${this.include}\\${this.exclude})`;
    }
    visitAccessPathPatterns(visitor) {
        visitor(this);
        this.include.visitAccessPathPatterns(visitor);
        this.exclude.visitAccessPathPatterns(visitor);
    }
}
exports.ExclusionAccessPathPattern = ExclusionAccessPathPattern;
class WildcardAccessPathPattern {
    ap;
    constructor(ap) {
        this.ap = ap;
    }
    toString() {
        return `${this.ap}**`;
    }
    visitAccessPathPatterns(visitor) {
        visitor(this);
        this.ap.visitAccessPathPatterns(visitor);
    }
}
exports.WildcardAccessPathPattern = WildcardAccessPathPattern;
class PotentiallyUnknownAccessPathPattern {
    ap;
    constructor(ap) {
        this.ap = ap;
    }
    toString() {
        return `${this.ap}?`;
    }
    visitAccessPathPatterns(visitor) {
        visitor(this);
        this.ap.visitAccessPathPatterns(visitor);
    }
}
exports.PotentiallyUnknownAccessPathPattern = PotentiallyUnknownAccessPathPattern;
class Filter {
}
exports.Filter = Filter;
class NumArgsCallFilter extends Filter {
    minArgs;
    maxArgs;
    constructor(minArgs, maxArgs) {
        super();
        this.minArgs = minArgs;
        this.maxArgs = maxArgs;
    }
    toString() {
        return `[${this.minArgs !== undefined ? this.minArgs : ""},${this.maxArgs !== undefined ? this.maxArgs : ""}]`;
    }
}
exports.NumArgsCallFilter = NumArgsCallFilter;
class TypeFilter extends Filter {
    selector;
    types;
    constructor(selector, types) {
        super();
        this.selector = selector;
        this.types = types;
    }
    toString() {
        return `${this.selector}:${this.types.length === 1 ? this.types[0] : `{${this.types.join(",")}`}`;
    }
}
exports.TypeFilter = TypeFilter;
class FilterSelector {
    head;
    props;
    constructor(head, props) {
        this.head = head;
        this.props = props;
    }
    toString() {
        return `${this.head}${this.props ? `.${this.props.join(".")}` : ""}`;
    }
}
exports.FilterSelector = FilterSelector;
class Type {
    simpleType;
    functionArgs;
    valueType;
    tsType;
    constructor(simpleType, functionArgs, valueType, tsType) {
        this.simpleType = simpleType;
        this.functionArgs = functionArgs;
        this.valueType = valueType;
        this.tsType = tsType;
        (0, assert_1.default)((simpleType !== undefined ? 1 : 0) + (valueType !== undefined ? 1 : 0) + (tsType !== undefined ? 1 : 0) === 1);
        (0, assert_1.default)(!functionArgs || simpleType === "function");
    }
    toString() {
        if (this.simpleType)
            return this.simpleType + (this.functionArgs !== undefined ? this.functionArgs : "");
        if (this.tsType)
            return this.tsType;
        (0, assert_1.default)(this.valueType !== undefined, "Unexpected type in toString");
        switch (typeof this.valueType) {
            case "string":
                return `"${this.valueType}"`;
            case "number":
            case "boolean":
                return this.valueType.toString();
            default:
                assert_1.default.fail(`Unexpected type ${typeof this.valueType}`);
        }
    }
    static makeSimpleType(simpleType, functionArgs) {
        return new Type(simpleType, functionArgs, undefined, undefined);
    }
    static makeValueType(valueType) {
        return new Type(undefined, undefined, valueType, undefined);
    }
    static makeTSType(tsType) {
        return new Type(undefined, undefined, undefined, tsType);
    }
}
exports.Type = Type;
//# sourceMappingURL=patterns.js.map