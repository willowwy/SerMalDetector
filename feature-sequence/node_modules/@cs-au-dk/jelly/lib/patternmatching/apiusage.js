"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.convertAPIUsageToJSON = exports.reportAPIUsage = exports.getAPIUsage = void 0;
const logger_1 = __importDefault(require("../misc/logger"));
const util_1 = require("../misc/util");
const patterns_1 = require("./patterns");
const types_1 = require("@babel/types");
const patternparser_1 = require("./patternparser");
function getAPIUsage(f) {
    logger_1.default.info("Collecting API usage");
    const reached = { import: new Map, read: new Map, write: new Map, call: new Map, component: new Map };
    const res1 = { import: new Map, read: new Map, write: new Map, call: new Map, component: new Map };
    const res2 = { import: new Map, read: new Map, write: new Map, call: new Map, component: new Map };
    const c = new patternparser_1.AccessPathPatternCanonicalizer;
    const worklist = new Map();
    function add(t, p, ap, n) {
        function sub(p) {
            return p instanceof patterns_1.PropertyAccessPathPattern ? p.base :
                p instanceof patterns_1.CallResultAccessPathPattern ? p.fun :
                    p instanceof patterns_1.ComponentAccessPathPattern ? p.component :
                        undefined;
        }
        function copyWithSub(as, sub) {
            if (as instanceof patterns_1.PropertyAccessPathPattern)
                return new patterns_1.PropertyAccessPathPattern(sub, as.props);
            else if (as instanceof patterns_1.CallResultAccessPathPattern)
                return new patterns_1.CallResultAccessPathPattern(sub);
            else if (as instanceof patterns_1.ComponentAccessPathPattern)
                return new patterns_1.ComponentAccessPathPattern(sub);
            else
                return as;
        }
        const p1 = sub(p);
        if (p1) {
            const p2 = sub(p1);
            if (p2) {
                if (p2 instanceof patterns_1.AbbreviatedPathPattern && p1 instanceof patterns_1.CallResultAccessPathPattern && !(p instanceof patterns_1.CallResultAccessPathPattern))
                    p = copyWithSub(p, p2);
                else {
                    const p3 = sub(p2);
                    if (p3) {
                        if (p3 instanceof patterns_1.AbbreviatedPathPattern) {
                            if (p1 instanceof patterns_1.CallResultAccessPathPattern)
                                p = copyWithSub(p, p3);
                            else
                                p = copyWithSub(p, copyWithSub(p1, p3));
                        }
                        else {
                            const p4 = sub(p3);
                            if (p4)
                                if (p1 instanceof patterns_1.CallResultAccessPathPattern)
                                    p = copyWithSub(p, new patterns_1.AbbreviatedPathPattern(p3));
                                else
                                    p = copyWithSub(p, copyWithSub(p1, new patterns_1.AbbreviatedPathPattern(p3)));
                        }
                    }
                }
            }
        }
        p = c.canonicalize(p);
        const aps = (0, util_1.mapGetSet)(reached[t], p);
        if (!aps.has(n)) {
            if (logger_1.default.isDebugEnabled())
                logger_1.default.debug(`Found ${t} ${p} at ${(0, util_1.locationToStringWithFileAndEnd)(n.loc)}`);
            aps.add(n);
            function isReadAtCall() {
                if (t === "read") {
                    const m = f.callResultAccessPaths.get(ap);
                    if (m)
                        for (const f of m.keys())
                            if (((0, types_1.isCallExpression)(f) || (0, types_1.isOptionalCallExpression)(f) || (0, types_1.isNewExpression)(f)) && f.callee === n)
                                return true;
                }
                return false;
            }
            if (isReadAtCall()) {
                if (logger_1.default.isDebugEnabled())
                    logger_1.default.debug(`Read-call ${ap} at ${(0, util_1.locationToStringWithFileAndEnd)(n.loc)}`);
            }
            else {
                (0, util_1.mapGetSet)(res1[t], p).add(n);
                (0, util_1.mapGetSet)(res2[t], n).add(p);
            }
            (0, util_1.mapGetSet)(worklist, p).add(ap);
        }
    }
    for (const [ap, ns] of f.moduleAccessPaths)
        for (const n of ns)
            add("import", c.canonicalize(new patterns_1.ImportAccessPathPattern(ap.moduleInfo.getOfficialName())), ap, n);
    for (const [p, aps] of worklist)
        for (const ap of aps) {
            aps.delete(ap);
            if (aps.size === 0)
                worklist.delete(p);
            const m1 = f.propertyReadAccessPaths.get(ap);
            if (m1)
                for (const [prop, np] of m1)
                    for (const [n2, { bp }] of np)
                        add("read", c.canonicalize(new patterns_1.PropertyAccessPathPattern(p, [prop])), bp, n2);
            const m2 = f.propertyWriteAccessPaths.get(ap);
            if (m2)
                for (const [prop, np] of m2)
                    for (const [n2, { bp }] of np)
                        add("write", c.canonicalize(new patterns_1.PropertyAccessPathPattern(p, [prop])), bp, n2);
            const m3 = f.callResultAccessPaths.get(ap);
            if (m3)
                for (const [n2, { bp }] of m3)
                    add("call", c.canonicalize(new patterns_1.CallResultAccessPathPattern(p)), bp, n2);
            const m4 = f.componentAccessPaths.get(ap);
            if (m4)
                for (const [n2, { bp }] of m4)
                    add("component", c.canonicalize(new patterns_1.ComponentAccessPathPattern(p)), bp, n2);
        }
    return [res1, res2];
}
exports.getAPIUsage = getAPIUsage;
function reportAPIUsage(r1, r2) {
    logger_1.default.info("API usage, access path patterns -> nodes:");
    let numAccessPathPatterns = 0, numAccessPathPatternsAtNodes = 0;
    for (const [t, m] of Object.entries(r1)) {
        for (const [p, ns] of m) {
            logger_1.default.info(`${t} ${p}:`);
            for (const n of ns)
                logger_1.default.info(`  ${(0, util_1.locationToStringWithFileAndEnd)(n.loc)}`);
            numAccessPathPatternsAtNodes += ns.size;
        }
        numAccessPathPatterns += m.size;
    }
    logger_1.default.info(`Access path patterns: ${numAccessPathPatterns}, access path patterns at nodes: ${numAccessPathPatternsAtNodes}`);
}
exports.reportAPIUsage = reportAPIUsage;
function convertAPIUsageToJSON(r) {
    const res = { import: {}, read: {}, write: {}, call: {}, component: {} };
    for (const type of Object.getOwnPropertyNames(r)) {
        const t = {};
        for (const [p, nodes] of r[type]) {
            const a = [];
            for (const n of nodes)
                if (n.loc) {
                    const loc = n.loc;
                    if (loc.module)
                        a.push({ filename: loc.module.getPath(), start: loc.start, end: loc.end });
                }
            t[p.toString()] = a;
        }
        res[type] = t;
    }
    return res;
}
exports.convertAPIUsageToJSON = convertAPIUsageToJSON;
//# sourceMappingURL=apiusage.js.map