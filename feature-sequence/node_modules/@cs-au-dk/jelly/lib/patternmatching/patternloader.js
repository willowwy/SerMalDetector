"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getProperties = exports.getGlobs = exports.removeObsoletePatterns = exports.convertTapirPatterns = exports.loadTapirDetectionPatternFiles = void 0;
const fs_1 = require("fs");
const patternparser_1 = require("./patternparser");
const patterns_1 = require("./patterns");
const logger_1 = __importDefault(require("../misc/logger"));
const util_1 = require("../misc/util");
function loadTapirDetectionPatternFiles(files) {
    const res = [];
    for (const file of files) {
        logger_1.default.info(`Loading patterns from ${file}`);
        for (const p of JSON.parse((0, fs_1.readFileSync)(file, "utf8")))
            res.push(p);
    }
    return res;
}
exports.loadTapirDetectionPatternFiles = loadTapirDetectionPatternFiles;
function convertTapirPatterns(tapir, c = new patternparser_1.AccessPathPatternCanonicalizer()) {
    const res = [];
    for (const p of tapir) {
        const pattern = "detectionPattern" in p ? p.detectionPattern : "semanticPatchId" in p ? p.semanticPatch.detectionPattern : p.pattern;
        try {
            res.push((0, patternparser_1.parseDetectionPattern)(pattern, c));
        }
        catch (pos) {
            logger_1.default.error(`Error: Pattern parse error:\n${pattern}${"semanticPatchId" in p ? ` (pattern #${p.semanticPatchId} version ${p.version})` : ""}`);
            logger_1.default.error(`${" ".repeat(pos)}^ (column ${pos})`);
        }
    }
    return res;
}
exports.convertTapirPatterns = convertTapirPatterns;
function removeObsoletePatterns(patterns) {
    const m = new Map();
    for (const p of patterns)
        if ("semanticPatchId" in p) {
            const q = m.get(p.semanticPatchId);
            if ((!q || ("version" in q && q.version < p.version)))
                if (p.enabled)
                    m.set(p.semanticPatchId, p);
                else
                    m.delete(p.semanticPatchId);
        }
        else if (!p.deprecation) {
            if (m.has(p.id))
                logger_1.default.warn(`Multiple patterns with ID ${p.id}`);
            m.set(p.id, p);
        }
    return Array.from(m.values());
}
exports.removeObsoletePatterns = removeObsoletePatterns;
function getGlobs(ds) {
    const s = new Set();
    for (const d of ds)
        if (d)
            d.ap.visitAccessPathPatterns(p => {
                if (p instanceof patterns_1.ImportAccessPathPattern)
                    s.add(p.glob);
            });
    return s;
}
exports.getGlobs = getGlobs;
function getProperties(ds) {
    const s = new Set();
    for (const d of ds)
        if (d)
            d.ap.visitAccessPathPatterns(p => {
                if (p instanceof patterns_1.PropertyAccessPathPattern)
                    (0, util_1.addAll)(p.props, s);
            });
    return s;
}
exports.getProperties = getProperties;
//# sourceMappingURL=patternloader.js.map