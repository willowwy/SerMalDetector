"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseDetectionPattern = exports.AccessPathPatternCanonicalizer = void 0;
const patterns_1 = require("./patterns");
class AccessPathPatternCanonicalizer {
    canonical = new Map;
    canonicalize(p) {
        const key = p.toString();
        const c = this.canonical.get(key);
        if (c)
            return c;
        this.canonical.set(key, p);
        return p;
    }
}
exports.AccessPathPatternCanonicalizer = AccessPathPatternCanonicalizer;
if (require.main === module) {
    console.log(parseDetectionPattern(process.argv[2], new AccessPathPatternCanonicalizer()).toString());
}
function parseDetectionPattern(pattern, c) {
    function parseSpace(start, optional = true) {
        let pos = start;
        while (pattern[pos] === " ")
            pos++;
        if (!optional && pos === start)
            throw pos;
        return pos;
    }
    function parseEnd(start) {
        if (start != pattern.length)
            throw start;
    }
    function parseOptionalKeyword(start, keyword) {
        if (pattern.substring(start, start + keyword.length).toLowerCase() === keyword)
            return [true, start + keyword.length];
        else
            return [false, start];
    }
    function parseChar(start, char) {
        if (pattern[start] === char)
            return start + 1;
        else
            throw start;
    }
    function parseAccessPathPattern(start) {
        let p, pos;
        pos = parseSpace(start);
        switch (pattern[pos]) {
            case "<":
                let g;
                [g, pos] = parseGlob(pos + 1);
                p = c.canonicalize(new patterns_1.ImportAccessPathPattern(g));
                pos = parseSpace(pos);
                pos = parseChar(pos, ">");
                break;
            case "{":
                pos = pos + 1;
                const aps = [];
                do {
                    let q;
                    [q, pos] = parseAccessPathPattern(pos);
                    pos = parseSpace(pos);
                    aps.push(q);
                } while (pattern[pos] === "," && ++pos);
                pos = parseChar(pos, "}");
                p = c.canonicalize(new patterns_1.DisjunctionAccessPathPattern(aps));
                break;
            case "(":
                let incl, excl;
                [incl, pos] = parseAccessPathPattern(pos + 1);
                pos = parseSpace(pos);
                pos = parseChar(pos, "\\");
                [excl, pos] = parseAccessPathPattern(pos);
                pos = parseSpace(pos);
                pos = parseChar(pos, ")");
                p = c.canonicalize(new patterns_1.ExclusionAccessPathPattern(incl, excl));
                break;
            default:
                throw start;
        }
        pos = parseSpace(pos);
        while ("(.?*".includes(pattern[pos])) {
            if (pattern[pos] === ".") {
                pos++;
                pos = parseSpace(pos);
                const props = [];
                if (pattern[pos] === "{" && ++pos) {
                    do {
                        let prop;
                        pos = parseSpace(pos);
                        [prop, pos] = parseProp(pos);
                        pos = parseSpace(pos);
                        props.push(prop);
                    } while (pattern[pos] === "," && ++pos);
                    pos = parseChar(pos, "}");
                }
                else {
                    let prop;
                    [prop, pos] = parseProp(pos);
                    props.push(prop);
                }
                p = c.canonicalize(new patterns_1.PropertyAccessPathPattern(p, props));
            }
            else if (pattern[pos] === "(" && pattern[pos + 1] === ")") {
                pos += 2;
                pos = parseSpace(pos);
                p = c.canonicalize(new patterns_1.CallResultAccessPathPattern(p));
            }
            else if (pattern[pos] === "?") {
                pos++;
                pos = parseSpace(pos);
                p = c.canonicalize(new patterns_1.PotentiallyUnknownAccessPathPattern(p));
            }
            else if (pattern[pos] === "*" && pattern[pos + 1] === "*") {
                pos += 2;
                pos = parseSpace(pos);
                p = c.canonicalize(new patterns_1.WildcardAccessPathPattern(p));
            }
            else
                throw pos + 1;
            pos = parseSpace(pos);
        }
        return [p, pos];
    }
    function parseProp(start) {
        let pos = start;
        while (pos < pattern.length && !",{}./()*<>[]: ".includes(pattern[pos]))
            pos++;
        if (pos === start)
            throw pos;
        return [pattern.substring(start, pos), pos];
    }
    function parseGlob(start) {
        let end = pattern.indexOf(">", start);
        if (end === -1)
            end = pattern.length;
        const glob = pattern.substring(start, end).trim();
        return [glob, end];
    }
    function parseOptionalNumber(start, allowNegative = false) {
        let pos = start;
        if (allowNegative && pattern[pos] === "-")
            pos++;
        while (pattern[pos] >= "0" && pattern[pos] <= "9")
            pos++;
        if (pos === start)
            return [undefined, start];
        return [parseInt(pattern.substring(start, pos), 10), pos];
    }
    function parseTypeScriptType(start) {
        let pos = start, c;
        while (c = pattern[pos], (c >= "0" && c <= "9") || (c >= "a" && c <= 'z') || (c >= "A" && c <= "Z") || "._$".includes(c))
            pos++;
        if (pos === start)
            throw start;
        return [pattern.substring(start, pos), pos];
    }
    function parseFilter(start) {
        let pos = start;
        if (pattern[pos] === "[") {
            pos++;
            pos = parseSpace(pos);
            let minArgs;
            [minArgs, pos] = parseOptionalNumber(pos);
            pos = parseSpace(pos);
            pos = parseChar(pos, ",");
            pos = parseSpace(pos);
            let maxArgs;
            [maxArgs, pos] = parseOptionalNumber(pos);
            pos = parseSpace(pos);
            pos = parseChar(pos, "]");
            pos = parseSpace(pos);
            return [new patterns_1.NumArgsCallFilter(minArgs, maxArgs), pos];
        }
        else {
            let selector;
            [selector, pos] = parseFilterSelector(pos);
            pos = parseSpace(pos);
            pos = parseChar(pos, ":");
            pos = parseSpace(pos);
            let types;
            [types, pos] = parseTypes(pos);
            pos = parseSpace(pos);
            return [new patterns_1.TypeFilter(selector, types), pos];
        }
    }
    function parseColonTypes(start) {
        pos = parseSpace(start);
        pos = parseChar(pos, ":");
        pos = parseSpace(pos);
        let types;
        [types, pos] = parseTypes(pos);
        pos = parseSpace(pos);
        return [types, pos];
    }
    function parseOptionalBaseFilter(start) {
        let [base, pos] = parseOptionalKeyword(start, "base");
        if (!base)
            return [undefined, pos];
        let types;
        [types, pos] = parseColonTypes(pos);
        return [types, pos];
    }
    function parseOptionalValueFilter(start) {
        let [value, pos] = parseOptionalKeyword(start, "value");
        if (!value)
            return [undefined, pos];
        let types;
        [types, pos] = parseColonTypes(pos);
        return [types, pos];
    }
    function parseOptionalValueBaseFilters(start) {
        let [valueFilter, pos] = parseOptionalValueFilter(start);
        let baseFilter;
        [baseFilter, pos] = parseOptionalBaseFilter(pos);
        if (!valueFilter && baseFilter)
            [valueFilter, pos] = parseOptionalValueFilter(pos);
        return [valueFilter, baseFilter, pos];
    }
    function parseFilterSelector(start) {
        let head;
        let [base, pos] = parseOptionalKeyword(start, "base");
        if (base)
            head = "base";
        else {
            [head, pos] = parseOptionalNumber(pos, true);
            if (head === undefined)
                throw start;
        }
        const props = [];
        pos = parseSpace(pos);
        while (pattern[pos] === "." && ++pos) {
            let prop;
            pos = parseSpace(pos);
            [prop, pos] = parseProp(pos);
            pos = parseSpace(pos);
            props.push(prop);
        }
        return [new patterns_1.FilterSelector(head, props.length > 0 ? props : undefined), pos];
    }
    function parseTypes(start) {
        let pos = start;
        const types = [];
        if (pattern[pos] === "{" && ++pos) {
            do {
                let typ;
                pos = parseSpace(pos);
                [typ, pos] = parseType(pos);
                pos = parseSpace(pos);
                types.push(typ);
            } while (pattern[pos] === "," && ++pos);
            pos = parseChar(pos, "}");
        }
        else {
            let typ;
            [typ, pos] = parseType(pos);
            types.push(typ);
        }
        return [types, pos];
    }
    function parseType(start) {
        for (const t of ["undefined", "boolean", "string", "number", "array", "empty-array", "object", "null", "function", "any"])
            if (pattern.startsWith(t, start)) {
                let num, pos = start + t.length;
                if (t === "function")
                    [num, pos] = parseOptionalNumber(pos);
                return [new patterns_1.Type(t, num, undefined, undefined), pos];
            }
        let match, pos;
        [match, pos] = parseOptionalKeyword(start, "true");
        if (match)
            return [new patterns_1.Type(undefined, undefined, true, undefined), pos];
        [match, pos] = parseOptionalKeyword(start, "false");
        if (match)
            return [new patterns_1.Type(undefined, undefined, false, undefined), pos];
        if (pattern[pos] === "\"" && ++pos) {
            const i = pattern.indexOf("\"", pos);
            if (i === -1)
                throw pos;
            const str = pattern.substring(pos, i);
            pos = i + 1;
            return [new patterns_1.Type(undefined, undefined, str, undefined), pos];
        }
        let num;
        [num, pos] = parseOptionalNumber(start, true);
        if (num !== undefined)
            return [new patterns_1.Type(undefined, undefined, num, undefined), pos];
        let tsType;
        [tsType, pos] = parseTypeScriptType(start);
        return [new patterns_1.Type(undefined, undefined, undefined, tsType), pos];
    }
    let pos, res, p, b;
    pos = parseSpace(0);
    if (([b, pos] = parseOptionalKeyword(pos, "import")) && b) {
        let onlyDefault;
        [onlyDefault, pos] = parseOptionalKeyword(pos, "d");
        pos = parseSpace(pos, false);
        if (pattern[pos] !== "<") {
            let g;
            [g, pos] = parseGlob(pos);
            p = c.canonicalize(new patterns_1.ImportAccessPathPattern(g));
        }
        else {
            [p, pos] = parseAccessPathPattern(pos);
            if (!(p instanceof patterns_1.ImportAccessPathPattern))
                throw pos;
        }
        res = new patterns_1.ImportDetectionPattern(p, onlyDefault);
    }
    else if (([b, pos] = parseOptionalKeyword(pos, "read")) && b) {
        let notInvoked;
        [notInvoked, pos] = parseOptionalKeyword(pos, "o");
        pos = parseSpace(pos, false);
        [p, pos] = parseAccessPathPattern(pos);
        if (!(p instanceof patterns_1.PropertyAccessPathPattern))
            throw pos;
        let baseFilter;
        [baseFilter, pos] = parseOptionalBaseFilter(pos);
        res = new patterns_1.ReadDetectionPattern(p, notInvoked, baseFilter);
    }
    else if (([b, pos] = parseOptionalKeyword(pos, "write")) && b) {
        pos = parseSpace(pos, false);
        [p, pos] = parseAccessPathPattern(pos);
        if (!(p instanceof patterns_1.PropertyAccessPathPattern))
            throw pos;
        let valueFilter, baseFilter;
        [valueFilter, baseFilter, pos] = parseOptionalValueBaseFilters(pos);
        res = new patterns_1.WriteDetectionPattern(p, valueFilter, baseFilter);
    }
    else if (([b, pos] = parseOptionalKeyword(pos, "call")) && b) {
        let onlyReturnChanged, onlyWhenUsedAsPromise, onlyNonNewCalls;
        [onlyReturnChanged, pos] = parseOptionalKeyword(pos, "r");
        [onlyWhenUsedAsPromise, pos] = parseOptionalKeyword(pos, "promise");
        [onlyNonNewCalls, pos] = parseOptionalKeyword(pos, "notnew");
        pos = parseSpace(pos, false);
        [p, pos] = parseAccessPathPattern(pos);
        const filters = [];
        while (pos < pattern.length) {
            let filter;
            [filter, pos] = parseFilter(pos);
            filters.push(filter);
        }
        res = new patterns_1.CallDetectionPattern(p, onlyReturnChanged, onlyWhenUsedAsPromise, onlyNonNewCalls, filters.length > 0 ? filters : undefined);
    }
    else
        throw 0;
    pos = parseSpace(pos);
    parseEnd(pos);
    return res;
}
exports.parseDetectionPattern = parseDetectionPattern;
//# sourceMappingURL=patternparser.js.map