"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.VulnerabilityDetector = void 0;
const infos_1 = require("../analysis/infos");
const semver_1 = require("semver");
const vulnerabilities_1 = require("../typings/vulnerabilities");
const util_1 = require("../misc/util");
const logger_1 = __importStar(require("../misc/logger"));
const patternparser_1 = require("./patternparser");
const patternmatcher_1 = require("./patternmatcher");
const timer_1 = require("../misc/timer");
class VulnerabilityDetector {
    vulnerabilities = new Map();
    patterns = new Map();
    vulnerabilityPackageMatches = new Map();
    vulnerabilityModuleMatches = new Map();
    vulnerabilityFunctionMatches = new Map();
    constructor(vs) {
        const c = new patternparser_1.AccessPathPatternCanonicalizer();
        for (const v of vs) {
            if ("affected" in v.osv && v.osv.affected) {
                for (const affected of v.osv.affected)
                    if (affected.package && affected.package.ecosystem === "npm")
                        (0, util_1.mapGetArray)(this.vulnerabilities, affected.package.name).push(v);
            }
            else if ("dependency" in v.osv)
                (0, util_1.mapGetArray)(this.vulnerabilities, v.osv.dependency).push(v);
            if (v.patterns)
                for (const p of v.patterns) {
                    const dp = `call ${p}`;
                    try {
                        (0, util_1.mapGetArray)(this.patterns, v).push((0, patternparser_1.parseDetectionPattern)(dp, c));
                    }
                    catch (dpos) {
                        const pos = dpos - 5;
                        logger_1.default.error(`Error: Pattern parse error:\n${p} (${(0, vulnerabilities_1.getVulnerabilityId)(v)})`);
                        logger_1.default.error(`${" ".repeat(pos)}^ (column ${pos})`);
                    }
                }
        }
    }
    getPatterns() {
        const res = [];
        for (const ps of this.patterns.values())
            for (const p of ps)
                res.push(p);
        return res;
    }
    reachedPackage(packageInfo) {
        const vs = this.vulnerabilities.get(packageInfo.name);
        if (vs) {
            for (const v of vs)
                if (this.checkPackageMatchesOpenSourceVulnerability(packageInfo, v.osv)) {
                    (0, util_1.mapGetSet)(this.vulnerabilityPackageMatches, packageInfo).add(v);
                    logger_1.default.info(`Detected vulnerable package ${packageInfo} (vulnerability: ${(0, vulnerabilities_1.getVulnerabilityId)(v)})`);
                }
        }
    }
    reachedModule(moduleInfo) {
        const vs = this.vulnerabilityPackageMatches.get(moduleInfo.packageInfo);
        if (vs) {
            for (const v of vs)
                if (this.checkModuleContainsVulnerabilityLocation(moduleInfo, v.location)) {
                    (0, util_1.mapGetSet)(this.vulnerabilityModuleMatches, moduleInfo).add(v);
                    logger_1.default.info(`Detected vulnerable module ${moduleInfo} (vulnerability: ${(0, vulnerabilities_1.getVulnerabilityId)(v)})`);
                    if (v.location && !v.location.line && !v.location.code)
                        (0, util_1.mapGetSet)(this.vulnerabilityFunctionMatches, moduleInfo).add(v);
                }
        }
    }
    reachedFunction(fun, functionInfo) {
        const vs = this.vulnerabilityModuleMatches.get(functionInfo.moduleInfo);
        if (vs) {
            for (const v of vs)
                if (this.checkFunctionContainsVulnerabilityLocation(fun, v.location)) {
                    (0, util_1.mapGetSet)(this.vulnerabilityFunctionMatches, functionInfo).add(v);
                    logger_1.default.info(`Detected vulnerable function ${functionInfo} (vulnerability: ${(0, vulnerabilities_1.getVulnerabilityId)(v)})`);
                }
        }
    }
    findPackagesThatMayDependOnVulnerablePackages(f) {
        const reverseDependencies = new Map();
        for (const p of f.a.packageInfos.values())
            for (const d of p.directDependencies)
                (0, util_1.mapGetSet)(reverseDependencies, d).add(p);
        return this.propagateBackwards(this.vulnerabilityPackageMatches, reverseDependencies);
    }
    findModulesThatMayDependOnVulnerableModules(f) {
        const reverseDependencies = new Map();
        for (const p of f.a.packageInfos.values())
            for (const m of p.modules.values()) {
                const r = f.requireGraph.get(m);
                if (r)
                    for (const d of r)
                        (0, util_1.mapGetSet)(reverseDependencies, d).add(m);
            }
        return this.propagateBackwards(this.vulnerabilityModuleMatches, reverseDependencies);
    }
    findFunctionsThatMayReachVulnerableFunctions(f) {
        const reverseDependencies = new Map();
        function add(d, n) {
            if (!d.packageInfo.isEntry || !n.packageInfo.isEntry)
                (0, util_1.mapGetSet)(reverseDependencies, d).add(n);
        }
        for (const p of f.a.packageInfos.values())
            for (const m of p.modules.values()) {
                const r = f.requireGraph.get(m);
                if (r)
                    for (const d of r)
                        add(d, m);
                for (const n of m.functions) {
                    const r = f.functionToFunction.get(n);
                    if (r)
                        for (const d of r)
                            add(d, n);
                }
                const t = f.functionToFunction.get(m);
                if (t)
                    for (const d of t)
                        add(d, m);
            }
        return this.propagateBackwards(this.vulnerabilityFunctionMatches, reverseDependencies);
    }
    findCallsThatMayReachVulnerableFunctions(f, fvs) {
        const res = new Map();
        for (const [call, s] of f.callToFunctionOrModule)
            for (const n of s)
                if (n instanceof infos_1.FunctionInfo || n instanceof infos_1.ModuleInfo)
                    if (!n.packageInfo.isEntry) {
                        const m = fvs.get(n);
                        if (m)
                            for (const [dst, vs] of m)
                                (0, util_1.addAll)(vs, (0, util_1.mapGetSet)((0, util_1.mapGetMap)(res, call), dst));
                    }
        return res;
    }
    propagateBackwards(matches, reverseDependencies) {
        const w = new Map();
        for (const [p, vs] of matches)
            w.set(p, new Map([[p, new Set(vs)]]));
        const res = new Map();
        for (const [p, m] of w) {
            w.delete(p);
            for (const [q, vs] of m) {
                (0, util_1.addAll)(vs, (0, util_1.mapGetSet)((0, util_1.mapGetMap)(res, p), q));
                const r = reverseDependencies.get(p);
                if (r)
                    for (const d of r)
                        for (const v of vs) {
                            const m = (0, util_1.mapGetMap)(res, d);
                            const t = (0, util_1.mapGetMap)(w, d);
                            if (!(0, util_1.mapGetSet)(m, q).has(v))
                                (0, util_1.mapGetSet)(t, q).add(v);
                        }
            }
        }
        return res;
    }
    reportResults(f, vulnerabilities) {
        if (vulnerabilities.package)
            for (const [src, m] of vulnerabilities.package)
                for (const [dst, vs] of m)
                    if (src !== dst)
                        for (const v of vs)
                            if (src.isEntry)
                                logger_1.default.warn(`Vulnerability warning: Main package ${src} depends on vulnerable package ${dst} (vulnerability: ${(0, vulnerabilities_1.getVulnerabilityId)(v)})`);
                            else
                                logger_1.default.warn(`Vulnerability warning: Dependency package ${src} depends on vulnerable package ${dst} (vulnerability: ${(0, vulnerabilities_1.getVulnerabilityId)(v)})`);
        if (vulnerabilities.module)
            for (const [src, m] of vulnerabilities.module)
                for (const [dst, vs] of m)
                    if (src !== dst)
                        for (const v of vs)
                            if (src.isEntry)
                                logger_1.default.warn(`Vulnerability warning: Main module ${src} depends on vulnerable module ${dst} (vulnerability: ${(0, vulnerabilities_1.getVulnerabilityId)(v)})`);
                            else
                                logger_1.default.warn(`Vulnerability warning: Dependency module ${src} depends on vulnerable module ${dst} (vulnerability: ${(0, vulnerabilities_1.getVulnerabilityId)(v)})`);
        if (vulnerabilities.function)
            for (const [src, m] of vulnerabilities.function)
                for (const [dst, vs] of m)
                    if (src !== dst)
                        for (const v of vs)
                            if (src.packageInfo.isEntry)
                                logger_1.default.warn(`Vulnerability warning: Main package ${src instanceof infos_1.FunctionInfo ? "function" : "module"} ${src} may reach vulnerable function ${dst} (vulnerability: ${(0, vulnerabilities_1.getVulnerabilityId)(v)})`);
                            else
                                logger_1.default.warn(`Vulnerability warning: Dependency ${src instanceof infos_1.FunctionInfo ? "function" : "module"} ${src} may reach vulnerable function ${dst} (vulnerability: ${(0, vulnerabilities_1.getVulnerabilityId)(v)})`);
        if (vulnerabilities.call)
            for (const [src, m] of vulnerabilities.call)
                for (const [dst, vs] of m)
                    for (const v of vs)
                        if (f.callToContainingFunction.get(src).packageInfo.isEntry)
                            logger_1.default.warn(`Vulnerability warning: Main package function call site ${(0, util_1.locationToStringWithFile)(src.loc)} may reach vulnerable function ${dst} (vulnerability: ${(0, vulnerabilities_1.getVulnerabilityId)(v)})`);
                        else
                            logger_1.default.warn(`Vulnerability warning: Dependency function call site ${(0, util_1.locationToStringWithFile)(src.loc)} may reach vulnerable function ${dst} (vulnerability: ${(0, vulnerabilities_1.getVulnerabilityId)(v)})`);
    }
    checkPackageMatchesOpenSourceVulnerability(p, osv) {
        if ("affected" in osv && osv.affected)
            for (const affected of osv.affected)
                if (affected.package && affected.package.ecosystem === "npm" && affected.package.name === p.name) {
                    if (p.version === undefined)
                        return true;
                    if (affected.versions)
                        for (const version of affected.versions)
                            if (version === p.version)
                                return true;
                    if (affected.ranges) {
                        for (const range of affected.ranges) {
                            let beforeLimits = false;
                            if (!range.events.find(event => "limit" in event))
                                beforeLimits = true;
                            else
                                for (const event of range.events)
                                    if (event.limit && (event.limit === "*" || (0, semver_1.lt)(p.version, event.limit))) {
                                        beforeLimits = true;
                                        break;
                                    }
                            if (beforeLimits) {
                                let match = false;
                                for (const event of range.events) {
                                    if (event.introduced && (event.introduced === "0" || (0, semver_1.gte)(p.version, event.introduced)))
                                        match = true;
                                    else if (event.fixed && (0, semver_1.gte)(p.version, event.fixed))
                                        match = false;
                                    else if (event.last_affected && (0, semver_1.gt)(p.version, event.last_affected))
                                        match = false;
                                }
                                if (match)
                                    return true;
                            }
                        }
                    }
                }
        if ("url" in osv) {
            if (osv.dependency === p.name) {
                if (p.version === undefined)
                    return true;
                return (0, semver_1.satisfies)(p.version, osv.range);
            }
        }
        return false;
    }
    checkModuleContainsVulnerabilityLocation(moduleInfo, loc) {
        return Boolean(loc && loc.file === moduleInfo.relativePath);
    }
    checkFunctionContainsVulnerabilityLocation(fun, loc) {
        if (!(loc && loc.file && loc.line && loc.code))
            return false;
        const source = fun.getSource();
        const firstMatch = source.indexOf(loc.code);
        if (firstMatch === -1)
            return false;
        const multipleMatches = source.indexOf(loc.code, firstMatch + 1) !== -1;
        if (!multipleMatches)
            return true;
        return Boolean(fun.node.loc?.start.line && fun.node.loc?.end.line && fun.node.loc?.start.line <= loc.line + 1 && loc.line <= fun.node.loc?.end.line + 1);
    }
    patternMatch(fragmentState, typer, diagnostics) {
        const res = new Map();
        (0, logger_1.writeStdOutIfActive)("Pattern matching...");
        try {
            const matcher = new patternmatcher_1.PatternMatcher(fragmentState, typer);
            for (const [v, ps] of this.patterns)
                for (const p of ps) {
                    const moduleFilter = (m) => m instanceof infos_1.DummyModuleInfo || this.checkPackageMatchesOpenSourceVulnerability(m.packageInfo, v.osv);
                    for (const m of matcher.findDetectionPatternMatches(p, moduleFilter)) {
                        logger_1.default.info(`Detected call to vulnerable function: ${p} at ${(0, util_1.locationToStringWithFileAndEnd)(m.exp.loc)} (vulnerability: ${(0, vulnerabilities_1.getVulnerabilityId)(v)})`);
                        (0, util_1.mapGetSet)((0, util_1.mapGetMap)(res, m.exp), fragmentState.callToContainingFunction.get(m.exp)).add(v);
                    }
                }
        }
        catch (ex) {
            if (ex instanceof timer_1.TimeoutException) {
                logger_1.default.error("Time limit reached, pattern matching aborted");
                if (diagnostics)
                    diagnostics.timeout = true;
            }
            else
                throw ex;
        }
        return res;
    }
}
exports.VulnerabilityDetector = VulnerabilityDetector;
//# sourceMappingURL=vulnerabilitydetector.js.map