"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.tapirPatternMatch = exports.tapirLoadPatterns = void 0;
const patternloader_1 = require("./patternloader");
const options_1 = require("../options");
const logger_1 = __importStar(require("../misc/logger"));
const util_1 = require("../misc/util");
const timer_1 = require("../misc/timer");
const patternmatcher_1 = require("./patternmatcher");
function tapirLoadPatterns(patternFiles) {
    const tapirPatterns = (0, patternloader_1.removeObsoletePatterns)((0, patternloader_1.loadTapirDetectionPatternFiles)(patternFiles));
    const patterns = (0, patternloader_1.convertTapirPatterns)(tapirPatterns);
    (0, options_1.setDefaultTrackedModules)((0, patternloader_1.getGlobs)(patterns));
    (0, options_1.setPatternProperties)((0, patternloader_1.getProperties)(patterns));
    return [tapirPatterns, patterns];
}
exports.tapirLoadPatterns = tapirLoadPatterns;
function tapirPatternMatch(tapirPatterns, patterns, solver, typer, expected) {
    (0, logger_1.writeStdOutIfActive)("Pattern matching...");
    const matcher = new patternmatcher_1.PatternMatcher(solver.fragmentState, typer);
    let matches = 0, matchesLow = 0, expectedMatches = 0, unexpectedMatches = 0, expectedLow = 0, expectedHigh = 0, unexpectedLow = 0, unexpectedHigh = 0, matchesTapirFalsePositives = 0, missesTapirFalsePositives = 0, missesParseErrors = 0, missesFileNotAnalyzed = 0;
    const expectedRemaining = Array.from(expected || []);
    function isTapirFalsePositive(q) {
        return "questions" in q && q.questions.find(e => e.answer === "no" && !["transformation", "extra", "ask-before-patch"].includes(e.type));
    }
    function isHigh(m) {
        return !m.uncertainties?.length;
    }
    try {
        for (let i = 0; i < patterns.length; i++) {
            const tp = tapirPatterns[i];
            const tpId = "semanticPatchId" in tp ? tp.semanticPatchId : tp.id;
            const tpPattern = "semanticPatchId" in tp ? tp.semanticPatch.detectionPattern : tp.pattern;
            const tpVersion = "version" in tp ? ` (version ${tp.version})` : "";
            const p = patterns[i];
            if (p) {
                solver.globalState.timeoutTimer.checkTimeout();
                const ms = matcher.findDetectionPatternMatches(p);
                for (const m of ms) {
                    logger_1.default.info(`Pattern #${tpId}: ${tpPattern}${tpVersion} matches ${(0, util_1.locationToStringWithFileAndEnd)(m.exp.loc)} (confidence: ${isHigh(m) ? "high" : "low"})`);
                    if (m.uncertainties && m.uncertainties.length > 0) {
                        for (const u of m.uncertainties)
                            logger_1.default.info(`Uncertainty: ${(0, patternmatcher_1.generateQuestion)(u) ?? "Access path match uncertain"}`);
                        matchesLow++;
                    }
                }
                matches += ms.length;
                if (expected)
                    for (const m of ms) {
                        let anyMatch = false;
                        for (const q of expected) {
                            if (("classification" in q ? q.classification : q.semanticPatchId) === tpId && m.exp.loc && "module" in m.exp.loc && m.exp.loc.module?.getPath().endsWith(q.file) &&
                                ("semanticPatchVersion" in q && "version" in tp ? q.semanticPatchVersion === tp.version : true) &&
                                ("lineNumber" in q ? q.lineNumber === m.exp.loc?.start.line :
                                    new RegExp(`^${m.exp.loc?.start.line}:\\d+:${m.exp.loc?.end.line}:\\d+$`).test(q.loc))) {
                                anyMatch = true;
                                const qi = expectedRemaining.indexOf(q);
                                if (qi !== -1) {
                                    expectedRemaining.splice(qi, 1);
                                    let confidence;
                                    if ("highConfidence" in q) {
                                        if (q.highConfidence === isHigh(m)) {
                                            confidence = `expected ${isHigh(m) ? "high" : "low"}`;
                                            if (q.highConfidence)
                                                expectedHigh++;
                                            else
                                                expectedLow++;
                                        }
                                        else if (q.highConfidence) {
                                            confidence = "unexpected low";
                                            unexpectedLow++;
                                        }
                                        else {
                                            confidence = "unexpected high";
                                            unexpectedHigh++;
                                        }
                                    }
                                    const tapirFalsePositive = isTapirFalsePositive(q);
                                    logger_1.default.info(`Expected match for pattern #${tpId}${tpVersion} at ${q.file}:${"lineNumber" in q ? q.lineNumber : q.loc}` +
                                        (confidence ? ` (confidence: ${confidence})` : "") +
                                        (tapirFalsePositive ? " (TAPIR false positive)" : ""));
                                    if (tapirFalsePositive)
                                        matchesTapirFalsePositives++;
                                    expectedMatches++;
                                }
                            }
                        }
                        if (!anyMatch) {
                            logger_1.default.warn(`Unexpected match for pattern #${tpId}${tpVersion} at ${(0, util_1.locationToStringWithFileAndEnd)(m.exp.loc)} (confidence: ${isHigh(m) ? "high" : "low"})`);
                            unexpectedMatches++;
                        }
                    }
            }
            else
                logger_1.default.info(`Skipping pattern #${tpId}${tpVersion} due to parse error`);
        }
    }
    catch (ex) {
        if (ex instanceof timer_1.TimeoutException) {
            logger_1.default.error("Time limit reached, pattern matching aborted");
            if (solver.diagnostics)
                solver.diagnostics.timeout = true;
        }
        else
            throw ex;
    }
    if (solver.globalState.filesAnalyzed.length === 0)
        logger_1.default.warn("Zero files analyzed");
    if (expected)
        for (const q of expectedRemaining) {
            const tapirFalsePositive = isTapirFalsePositive(q);
            const id = "classification" in q ? q.classification : q.semanticPatchId;
            const version = "semanticPatchVersion" in q ? ` (version ${q.semanticPatchVersion})` : "";
            const fileAnalyzed = solver.globalState.filesAnalyzed.find(f => f.endsWith(q.file)) !== undefined;
            logger_1.default.warn(`Missed match for pattern #${id}${version} at ${q.file}:${"lineNumber" in q ? q.lineNumber : q.loc}` +
                (tapirFalsePositive ? " (TAPIR false positive)" : "") +
                ("highConfidence" in q ? ` (${q.highConfidence ? "high" : "low"} confidence)` : "") +
                (fileAnalyzed ? "" : " (file not analyzed)"));
            if (tapirFalsePositive)
                missesTapirFalsePositives++;
            if (solver.globalState.filesWithParseErrors.find(f => f.endsWith(q.file)))
                missesParseErrors++;
            if (!fileAnalyzed)
                missesFileNotAnalyzed++;
        }
    logger_1.default.info(`Matches: ${matches}${expected ? `, expected: ${expected.length}` : ""} (patterns: ${patterns.length})`);
    if (expected) {
        logger_1.default.info(`Expected matches: ${expectedMatches}, unexpected: ${unexpectedMatches}, misses: ${expectedRemaining.length}`);
        logger_1.default.info(`Confidence expected low: ${expectedLow}, expected high: ${expectedHigh}, unexpected low: ${unexpectedLow}, unexpected high: ${unexpectedHigh}`);
        logger_1.default.info(`TAPIR false positives matches: ${matchesTapirFalsePositives}, misses: ${missesTapirFalsePositives}`);
        logger_1.default.info(`Misses in files with parse errors: ${missesParseErrors}, misses in files not analyzed: ${missesFileNotAnalyzed}`);
    }
    const misses = expectedRemaining.length;
    return {
        matches, matchesLow, expectedMatches, unexpectedMatches, misses,
        expectedLow, expectedHigh, unexpectedLow, unexpectedHigh,
        matchesTapirFalsePositives, missesTapirFalsePositives,
        missesParseErrors, missesFileNotAnalyzed
    };
}
exports.tapirPatternMatch = tapirPatternMatch;
//# sourceMappingURL=tapirpatterns.js.map