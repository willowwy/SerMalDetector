"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateQuestion = exports.convertPatternMatchesToJSON = exports.PatternMatcher = exports.confidenceLevels = void 0;
const infos_1 = require("../analysis/infos");
const patterns_1 = require("./patterns");
const assert_1 = __importDefault(require("assert"));
const util_1 = require("../misc/util");
const types_1 = require("@babel/types");
const micromatch_1 = __importDefault(require("micromatch"));
const tokens_1 = require("../analysis/tokens");
const logger_1 = __importDefault(require("../misc/logger"));
const constraintvars_1 = require("../analysis/constraintvars");
const accesspaths_1 = require("../analysis/accesspaths");
const astpatterns_1 = require("./astpatterns");
const typematcher_1 = require("./typematcher");
const options_1 = require("../options");
exports.confidenceLevels = ["high", "low"];
class PatternMatcher {
    fragmentState;
    typer;
    moduleCache = new Map;
    expressionCache = new Map;
    writeExpressionCache = new Map;
    unknownsCache;
    escapingToExternal = new Map();
    constructor(fragmentState, typer) {
        this.fragmentState = fragmentState;
        this.typer = typer;
    }
    findGlobMatches(glob) {
        let res = this.moduleCache.get(glob);
        if (!res) {
            res = [];
            this.moduleCache.set(glob, res);
            const isMatch = micromatch_1.default.matcher(glob);
            for (const [ap, ns] of this.fragmentState.moduleAccessPaths) {
                const m = ap.moduleInfo;
                if (isMatch(m.getOfficialName()) || (ap.requireName && isMatch(ap.requireName)))
                    if (options_1.options.patterns && m instanceof infos_1.ModuleInfo && m.isIncluded)
                        logger_1.default.error(`Error: Pattern contains analyzed module ${m.getOfficialName()} (see --ignore-dependencies)`);
                    else
                        res.push([ap, ns]);
            }
        }
        return res;
    }
    findAccessPathPatternMatches(p, moduleFilter, write) {
        const cache = write ? this.writeExpressionCache : this.expressionCache;
        let res = cache.get(p);
        if (!res) {
            const high = new Map, low = new Map;
            res = { high, low };
            cache.set(p, res);
            const f = this.fragmentState;
            function addMatches(level, ap, q, tmp, subvs, exclude) {
                if (q)
                    for (const [r, { bp, sub }] of q)
                        if (!exclude || !exclude.has(r) || !exclude.get(r).has(bp)) {
                            if (logger_1.default.isDebugEnabled())
                                logger_1.default.debug(`Match ${bp} (sub: ${ap}) at ${(0, util_1.nodeToString)(r)} (confidence: ${level})`);
                            (0, util_1.mapGetSet)(tmp, r).add(bp);
                            subvs.set(r, sub);
                        }
            }
            function transfer(level, sub, tmp, subvs, nextsub) {
                let covered;
                if (level === "high") {
                    covered = new Set;
                    for (const subv of subvs.values()) {
                        let isCovered = true;
                        for (const t of f.getTokens(f.getRepresentative(subv)))
                            if (t instanceof tokens_1.AccessPathToken) {
                                let isMatched = false;
                                for (const aps of sub.high.values())
                                    if (aps.has(t.ap)) {
                                        isMatched = true;
                                        break;
                                    }
                                if (!isMatched) {
                                    isCovered = false;
                                    break;
                                }
                            }
                            else {
                                isCovered = false;
                                break;
                            }
                        if (logger_1.default.isDebugEnabled())
                            logger_1.default.debug(`Covered ${subv}: ${isCovered}`);
                        if (isCovered)
                            covered.add(subv);
                    }
                }
                for (const [n, bps] of tmp)
                    for (const bp of bps) {
                        let newlevel = level;
                        if (level === "high" && !covered.has(subvs.get(n))) {
                            if (logger_1.default.isDebugEnabled())
                                logger_1.default.debug(`Demoting match ${(0, util_1.nodeToString)(n)} with ${p} to low confidence`);
                            newlevel = "low";
                        }
                        const s = (0, util_1.mapGetSet)(res[newlevel], n);
                        if (!s.has(bp)) {
                            s.add(bp);
                            if (nextsub)
                                (0, util_1.mapGetSet)(nextsub[newlevel], n).add(bp);
                        }
                    }
            }
            const addEscapingToExternal = (ap, write) => {
                const esc = this.escapingToExternal.get(ap);
                if (esc)
                    for (const n of esc)
                        if (!write || ((0, types_1.isAssignmentExpression)(n) && ((0, types_1.isMemberExpression)(n.left) || (0, types_1.isOptionalMemberExpression)(n.left))))
                            (0, util_1.mapGetSet)(res.low, n).add(ap);
            };
            if (p instanceof patterns_1.ImportAccessPathPattern) {
                let globMatches = this.findGlobMatches(p.glob);
                if (moduleFilter)
                    globMatches = globMatches.filter(([ap, _ns]) => moduleFilter(ap.moduleInfo));
                for (const [ap, ns] of globMatches)
                    for (const n of ns)
                        (0, util_1.mapGetSet)(high, n).add(ap);
                for (const aps of high.values())
                    for (const ap of aps) {
                        const ps = f.propertyReadAccessPaths.get(ap);
                        if (ps) {
                            const q = ps.get("default");
                            if (q)
                                for (const [p, { bp }] of q)
                                    (0, util_1.mapGetSet)(high, p).add(bp);
                        }
                    }
            }
            else if (p instanceof patterns_1.PropertyAccessPathPattern) {
                const sub = this.findAccessPathPatternMatches(p.base, moduleFilter);
                for (const level of exports.confidenceLevels) {
                    const tmp = new Map();
                    const subvs = new Map();
                    for (const aps of sub[level].values())
                        for (const ap of aps) {
                            const ps = (write ? f.propertyWriteAccessPaths : f.propertyReadAccessPaths).get(ap);
                            if (ps)
                                for (const prop of p.props)
                                    addMatches(level, ap, ps.get(prop), tmp, subvs);
                            addEscapingToExternal(ap);
                        }
                    transfer(level, sub, tmp, subvs);
                }
            }
            else if (p instanceof patterns_1.CallResultAccessPathPattern) {
                const sub = this.findAccessPathPatternMatches(p.fun, moduleFilter);
                for (const level of exports.confidenceLevels) {
                    const tmp = new Map();
                    const subvs = new Map();
                    for (const aps of sub[level].values())
                        for (const ap of aps) {
                            addMatches(level, ap, f.callResultAccessPaths.get(ap), tmp, subvs);
                            addEscapingToExternal(ap);
                        }
                    transfer(level, sub, tmp, subvs);
                }
            }
            else if (p instanceof patterns_1.DisjunctionAccessPathPattern) {
                const subs = [];
                for (const ap of p.aps)
                    subs.push(this.findAccessPathPatternMatches(ap, moduleFilter));
                for (const sub of subs)
                    for (const level of exports.confidenceLevels)
                        for (const [n, aps] of sub[level])
                            (0, util_1.addAll)(aps, (0, util_1.mapGetSet)(res[level], n));
                for (const sub of subs)
                    for (const [n, aps] of sub.low)
                        (0, util_1.deleteAll)(aps.values(), (0, util_1.mapGetSet)(high, n));
            }
            else if (p instanceof patterns_1.ExclusionAccessPathPattern) {
                const included = this.findAccessPathPatternMatches(p.include, moduleFilter);
                const excluded = this.findAccessPathPatternMatches(p.exclude, moduleFilter);
                for (const level of exports.confidenceLevels)
                    for (const [n, aps] of included[level])
                        (0, util_1.addAll)(aps, (0, util_1.mapGetSet)(res[level], n));
                for (const [n, aps] of excluded.high) {
                    (0, util_1.deleteMapSetAll)(high, n, aps);
                    (0, util_1.deleteMapSetAll)(low, n, aps);
                }
                for (const [n, aps] of excluded.low)
                    for (const ap of aps)
                        if (high.get(n)?.delete(ap))
                            (0, util_1.mapGetSet)(low, n).add(ap);
            }
            else if (p instanceof patterns_1.PotentiallyUnknownAccessPathPattern) {
                const sub = this.findAccessPathPatternMatches(p.ap, moduleFilter);
                for (const level of exports.confidenceLevels)
                    for (const [n, aps] of sub[level])
                        (0, util_1.addAll)(aps, (0, util_1.mapGetSet)(res[level], n));
                for (const n of this.findUnknowns())
                    (0, util_1.mapGetSet)(low, n).add(accesspaths_1.UnknownAccessPath.instance);
            }
            else if (p instanceof patterns_1.WildcardAccessPathPattern) {
                let sub = this.findAccessPathPatternMatches(p.ap, moduleFilter);
                for (const level of exports.confidenceLevels)
                    for (const [n, bps] of sub[level])
                        (0, util_1.addAll)(bps, (0, util_1.mapGetSet)(res[level], n));
                const visited = { high: new Set, low: new Set };
                while (sub.high.size !== 0 || sub.low.size !== 0) {
                    const nextsub = { high: new Map, low: new Map };
                    for (const level of exports.confidenceLevels) {
                        const tmp = new Map();
                        const subvs = new Map();
                        for (const aps of sub[level].values())
                            for (const ap of aps)
                                if (!visited[level].has(ap)) {
                                    visited[level].add(ap);
                                    const ps = (write ? f.propertyWriteAccessPaths : f.propertyReadAccessPaths).get(ap);
                                    if (ps)
                                        for (const q of ps.values())
                                            addMatches(level, ap, q, tmp, subvs, res[level]);
                                    addMatches(level, ap, f.callResultAccessPaths.get(ap), tmp, subvs, res[level]);
                                }
                        transfer(level, sub, tmp, subvs, nextsub);
                    }
                    sub = nextsub;
                }
            }
            else
                assert_1.default.fail("Unexpected AccessPathPattern");
        }
        if (logger_1.default.isDebugEnabled())
            for (const level of exports.confidenceLevels)
                for (const [e, aps] of res[level])
                    for (const ap of aps)
                        logger_1.default.debug(`Pattern ${p} matched access path ${ap} at ${(0, util_1.locationToStringWithFileAndEnd)(e.loc)} (confidence: ${level})`);
        return res;
    }
    findUnknowns() {
        if (!this.unknownsCache) {
            this.unknownsCache = [];
            const check = (v, ts) => {
                for (const t of ts)
                    if (t instanceof tokens_1.AccessPathToken && t.ap instanceof accesspaths_1.UnknownAccessPath) {
                        if (logger_1.default.isDebugEnabled())
                            logger_1.default.debug(`Unknown: ${v} (${t})`);
                        this.unknownsCache.push(v.node);
                        break;
                    }
            };
            for (const [v, ts] of this.fragmentState.getAllVarsAndTokens())
                if (v instanceof constraintvars_1.NodeVar)
                    check(v, ts);
            for (const v of this.fragmentState.redirections)
                if (v instanceof constraintvars_1.NodeVar)
                    check(v, this.fragmentState.getTokens(this.fragmentState.getRepresentative(v)));
        }
        return this.unknownsCache;
    }
    filterMatches(n, filter) {
        if (!((0, types_1.isCallExpression)(n) || (0, types_1.isOptionalCallExpression)(n) || (0, types_1.isNewExpression)(n)))
            return [util_1.Ternary.Maybe, n];
        if (filter instanceof patterns_1.NumArgsCallFilter) {
            let simple = true, exps = 0;
            for (const arg of n.arguments)
                if ((0, types_1.isExpression)(arg))
                    exps++;
                else
                    simple = false;
            let res;
            if (simple)
                res = (filter.minArgs === undefined || filter.minArgs <= n.arguments.length) &&
                    (filter.maxArgs === undefined || n.arguments.length <= filter.maxArgs) ? util_1.Ternary.True : util_1.Ternary.False;
            else if (filter.maxArgs === undefined && filter.minArgs !== undefined && filter.minArgs <= exps)
                res = util_1.Ternary.True;
            else
                res = util_1.Ternary.Maybe;
            return [res, n];
        }
        if (!(filter instanceof patterns_1.TypeFilter))
            assert_1.default.fail("Unexpected Filter");
        for (const arg of n.arguments)
            if (!(0, types_1.isExpression)(arg))
                return [util_1.Ternary.Maybe, n];
        let arg;
        if (filter.selector.head === "base") {
            arg = n.callee;
            if (((0, types_1.isMemberExpression)(n.callee) || (0, types_1.isOptionalMemberExpression)(n.callee)) && (0, types_1.isExpression)(n.callee.object))
                arg = n.callee.object;
            else
                return [util_1.Ternary.Maybe, n];
        }
        else if (filter.selector.head < 0) {
            if (n.arguments.length + filter.selector.head >= 0)
                arg = n.arguments[n.arguments.length + filter.selector.head];
            else
                return [util_1.Ternary.False, n];
        }
        else {
            if (filter.selector.head < n.arguments.length)
                arg = n.arguments[filter.selector.head];
            else
                return [util_1.Ternary.False, n];
        }
        return [(0, typematcher_1.expressionMatchesType)(arg, filter.selector.props, filter.types, this.typer), arg];
    }
    findEscapingAccessPathsToExternal() {
        const f = this.fragmentState;
        for (const [v, ns] of f.maybeEscapingToExternal)
            for (const t of f.getTokens(f.getRepresentative(v)))
                if (t instanceof tokens_1.AccessPathToken)
                    (0, util_1.addAll)(ns, (0, util_1.mapGetSet)(this.escapingToExternal, t.ap));
    }
    findDetectionPatternMatches(d, moduleFilter) {
        this.findEscapingAccessPathsToExternal();
        const res = [];
        if (d instanceof patterns_1.ImportDetectionPattern) {
            const sub = this.findAccessPathPatternMatches(d.ap, moduleFilter);
            for (const level of exports.confidenceLevels)
                for (const exp of sub[level].keys())
                    if (!((0, types_1.isMemberExpression)(exp) || (0, types_1.isOptionalMemberExpression)(exp)) && !(0, types_1.isIdentifier)(exp))
                        if (!d.onlyDefault || (0, astpatterns_1.isDefaultImport)(exp))
                            res.push({ exp, uncertainties: level === "low" ? ["accessPath"] : undefined });
        }
        else if (d instanceof patterns_1.ReadDetectionPattern) {
            const sub = this.findAccessPathPatternMatches(d.ap, moduleFilter);
            for (const level of exports.confidenceLevels) {
                for (const exp of sub[level].keys()) {
                    if (!d.notInvoked || !this.fragmentState.invokedExpressions.has(exp)) {
                        const uncertainties = [];
                        if (level === "low" && !d.baseFilter)
                            uncertainties.push("accessPath");
                        if (d.baseFilter && level === "low") {
                            const expObject = getPropertyReadObject(exp);
                            if (expObject)
                                switch ((0, typematcher_1.expressionMatchesType)(expObject, undefined, d.baseFilter, this.typer)) {
                                    case util_1.Ternary.False:
                                        continue;
                                    case util_1.Ternary.Maybe:
                                        uncertainties.push({ type: "type", exp: expObject, kind: "base", typesToMatch: d.baseFilter });
                                        break;
                                }
                            else
                                uncertainties.push({ type: "type", exp: undefined, kind: "base", typesToMatch: d.baseFilter });
                        }
                        res.push({ exp, uncertainties });
                    }
                    if ((0, types_1.isIdentifier)(exp)) {
                        const refs = this.fragmentState.importDeclRefs.get(exp);
                        if (refs)
                            for (const n of refs) {
                                const uncertainties = [];
                                if (level === "low")
                                    uncertainties.push("accessPath");
                                res.push({ exp: n, uncertainties });
                            }
                    }
                }
            }
        }
        else if (d instanceof patterns_1.WriteDetectionPattern) {
            const sub = this.findAccessPathPatternMatches(d.ap, moduleFilter, true);
            for (const level of exports.confidenceLevels)
                for (const exp of sub[level].keys()) {
                    const uncertainties = [];
                    if (level === "low")
                        uncertainties.push("accessPath");
                    if ((0, types_1.isAssignmentExpression)(exp) && ((0, types_1.isMemberExpression)(exp.left) || (0, types_1.isOptionalMemberExpression)(exp.left))) {
                        if (d.valueFilter)
                            switch ((0, typematcher_1.expressionMatchesType)(exp.right, undefined, d.valueFilter, this.typer)) {
                                case util_1.Ternary.False:
                                    continue;
                                case util_1.Ternary.Maybe:
                                    uncertainties.push({ type: "type", exp: exp.right, kind: "value", typesToMatch: d.valueFilter });
                                    break;
                            }
                        if (d.baseFilter)
                            switch ((0, typematcher_1.expressionMatchesType)(exp.left.object, undefined, d.baseFilter, this.typer)) {
                                case util_1.Ternary.False:
                                    continue;
                                case util_1.Ternary.Maybe:
                                    uncertainties.push({ type: "type", exp: exp.left.object, kind: "base", typesToMatch: d.baseFilter });
                                    break;
                            }
                    }
                    res.push({ exp, uncertainties });
                }
        }
        else if (d instanceof patterns_1.CallDetectionPattern) {
            const sub = this.findAccessPathPatternMatches(new patterns_1.CallResultAccessPathPattern(d.ap), moduleFilter);
            const f = this.fragmentState;
            for (const level of exports.confidenceLevels)
                matches: for (const exp of sub[level].keys()) {
                    if ((!d.onlyReturnChanged || !f.callsWithUnusedResult.has(exp)) &&
                        (!d.onlyNonNewCalls || !(0, types_1.isNewExpression)(exp)) &&
                        (!d.onlyWhenUsedAsPromise || f.callsWithResultMaybeUsedAsPromise.has(exp))) {
                        const uncertainties = [];
                        if (d.onlyWhenUsedAsPromise && f.callsWithResultMaybeUsedAsPromise.has(exp))
                            uncertainties.push("maybePromiseMatch");
                        if (level === "low" && !d.filters?.some(f => f instanceof patterns_1.TypeFilter && f.selector.head === "base"))
                            uncertainties.push("accessPath");
                        if (d.filters)
                            for (const f of d.filters)
                                if (!(level === "high" && f instanceof patterns_1.TypeFilter && f.selector.head === "base")) {
                                    const [t, arg] = this.filterMatches(exp, f);
                                    switch (t) {
                                        case util_1.Ternary.False:
                                            continue matches;
                                        case util_1.Ternary.Maybe:
                                            if (f instanceof patterns_1.NumArgsCallFilter)
                                                uncertainties.push({
                                                    type: "numArg",
                                                    exp,
                                                    numMinArgs: f.minArgs,
                                                    numMaxArgs: f.maxArgs
                                                });
                                            else if (f instanceof patterns_1.TypeFilter)
                                                uncertainties.push({
                                                    type: "type",
                                                    exp: arg,
                                                    kind: f.selector.head,
                                                    typesToMatch: f.types
                                                });
                                            else
                                                throw new Error("Unexpected Filter");
                                            break;
                                    }
                                }
                        res.push({ exp, uncertainties });
                    }
                }
        }
        else
            assert_1.default.fail("Unexpected DetectionPattern");
        return res;
    }
}
exports.PatternMatcher = PatternMatcher;
function getPropertyReadObject(exp) {
    if ((0, types_1.isMemberExpression)(exp) || (0, types_1.isOptionalMemberExpression)(exp))
        return exp.object;
    if ((0, types_1.isIdentifier)(exp))
        return undefined;
    if ((0, types_1.isObjectProperty)(exp))
        return undefined;
    assert_1.default.fail(`Unexpected node type ${exp.type} at ${(0, util_1.locationToStringWithFileAndEnd)(exp.loc)}`);
}
function convertPatternMatchesToJSON(patterns, matcher) {
    const res = { files: [], patterns: [] };
    const locs = new util_1.SourceLocationsToJSON(res.files);
    function convertUncertaintyToJSON(u) {
        if (typeof u === "object" && "exp" in u) {
            const r = { ...u, loc: u.exp && locs.makeLocString(u.exp.loc) };
            delete r.exp;
            return r;
        }
        else
            return u;
    }
    for (const p of patterns)
        if (p) {
            const ms = matcher.findDetectionPatternMatches(p);
            if (ms.length > 0) {
                const matches = [];
                res.patterns.push({ pattern: p.toString(), matches });
                for (const m of ms) {
                    const match = {
                        loc: locs.makeLocString(m.exp.loc),
                        uncertainties: []
                    };
                    matches.push(match);
                    if (m.uncertainties && m.uncertainties.length > 0) {
                        for (const u of m.uncertainties)
                            match.uncertainties.push({
                                uncertainty: convertUncertaintyToJSON(u),
                                text: generateQuestion(u) ?? "Access path match uncertain"
                            });
                    }
                }
            }
        }
    return res;
}
exports.convertPatternMatchesToJSON = convertPatternMatchesToJSON;
function generateQuestion(u) {
    if (u === "accessPath")
        return undefined;
    else if (u === "maybePromiseMatch")
        return "Is the result used as a promise?";
    else if (u.type === "type") {
        const prefix = u.kind === "base" ? "the base expression" : u.kind === "value" ? "the expression" : `argument ${u.kind + 1}`;
        (0, assert_1.default)(u.typesToMatch.length > 0, "typesToMatch empty");
        const suffix = u.typesToMatch.length > 1 ?
            `one of the types ${u.typesToMatch.slice(0, -1).join(", ")}, or ${u.typesToMatch[u.typesToMatch.length - 1]}` :
            `type ${u.typesToMatch[0]}`;
        return `Is ${prefix} of ${suffix}?`;
    }
    else if (u.type === "numArg") {
        const prefix = "Is the call supplied with ";
        if (u.numMinArgs === undefined)
            return `${prefix}at most ${u.numMaxArgs} argument${u.numMaxArgs === 1 ? "" : "s"}?`;
        else if (u.numMaxArgs === undefined)
            return `${prefix}at least ${u.numMinArgs} argument${u.numMinArgs === 1 ? "" : "s"}?`;
        else if (u.numMinArgs === u.numMaxArgs)
            return `${prefix}exactly ${u.numMinArgs} argument${u.numMinArgs === 1 ? "" : "s"}?`;
        else
            return `Is the call supplied with at least ${u.numMinArgs} and at most ${u.numMaxArgs} arguments?`;
    }
    else
        throw new Error("Unexpected Uncertainty type");
}
exports.generateQuestion = generateQuestion;
//# sourceMappingURL=patternmatcher.js.map