import { FunctionInfo, ModuleInfo, PackageInfo } from "../analysis/infos";
import { Vulnerability } from "../typings/vulnerabilities";
import { NodePath } from "@babel/traverse";
import { Class, Function, Node } from "@babel/types";
import { DetectionPattern } from "./patterns";
import { FragmentState } from "../analysis/fragmentstate";
import { TypeScriptTypeInferrer } from "../typescript/typeinferrer";
import AnalysisDiagnostics from "../analysis/diagnostics";
export type PackageDependencyVulnerabilities = Map<PackageInfo, Map<PackageInfo, Set<Vulnerability>>>;
export type ModuleDependencyVulnerabilities = Map<ModuleInfo, Map<ModuleInfo, Set<Vulnerability>>>;
export type FunctionReachabilityVulnerabilities = Map<FunctionInfo | ModuleInfo, Map<FunctionInfo | ModuleInfo, Set<Vulnerability>>>;
export type CallReachabilityVulnerabilities = Map<Node, Map<FunctionInfo | ModuleInfo, Set<Vulnerability>>>;
export type PatternMatchVulnerabilities = Map<Node, Map<FunctionInfo | ModuleInfo, Set<Vulnerability>>>;
export type VulnerabilityResults = {
    package?: PackageDependencyVulnerabilities;
    module?: ModuleDependencyVulnerabilities;
    function?: FunctionReachabilityVulnerabilities;
    call?: CallReachabilityVulnerabilities;
    matches?: PatternMatchVulnerabilities;
};
export declare class VulnerabilityDetector {
    private vulnerabilities;
    private patterns;
    vulnerabilityPackageMatches: Map<PackageInfo, Set<Vulnerability>>;
    vulnerabilityModuleMatches: Map<ModuleInfo, Set<Vulnerability>>;
    vulnerabilityFunctionMatches: Map<ModuleInfo | FunctionInfo, Set<Vulnerability>>;
    constructor(vs: Array<Vulnerability>);
    getPatterns(): Array<DetectionPattern>;
    reachedPackage(packageInfo: PackageInfo): void;
    reachedModule(moduleInfo: ModuleInfo): void;
    reachedFunction(fun: NodePath<Function | Class>, functionInfo: FunctionInfo): void;
    findPackagesThatMayDependOnVulnerablePackages(f: FragmentState): PackageDependencyVulnerabilities;
    findModulesThatMayDependOnVulnerableModules(f: FragmentState): ModuleDependencyVulnerabilities;
    findFunctionsThatMayReachVulnerableFunctions(f: FragmentState): FunctionReachabilityVulnerabilities;
    findCallsThatMayReachVulnerableFunctions(f: FragmentState, fvs: FunctionReachabilityVulnerabilities): CallReachabilityVulnerabilities;
    private propagateBackwards;
    reportResults(f: FragmentState, vulnerabilities: VulnerabilityResults): void;
    private checkPackageMatchesOpenSourceVulnerability;
    private checkModuleContainsVulnerabilityLocation;
    private checkFunctionContainsVulnerabilityLocation;
    patternMatch(fragmentState: FragmentState, typer?: TypeScriptTypeInferrer, diagnostics?: AnalysisDiagnostics): PatternMatchVulnerabilities;
}
