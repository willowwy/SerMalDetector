#!/usr/bin/env node
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const readline = __importStar(require("readline"));
const logger_1 = require("./misc/logger");
const options_1 = require("./options");
const files_1 = require("./misc/files");
const analyzer_1 = require("./analysis/analyzer");
const typeinferrer_1 = require("./typescript/typeinferrer");
const patternloader_1 = require("./patternmatching/patternloader");
const patternmatcher_1 = require("./patternmatching/patternmatcher");
const apiusage_1 = require("./patternmatching/apiusage");
const solver_1 = __importStar(require("./analysis/solver"));
const commander_1 = require("commander");
const winston_1 = __importDefault(require("winston"));
const os_1 = require("os");
const analysisstatereporter_1 = require("./output/analysisstatereporter");
const visualizer_1 = require("./output/visualizer");
const vulnerabilitydetector_1 = require("./patternmatching/vulnerabilitydetector");
const fs_1 = require("fs");
const util_1 = require("./misc/util");
const VERSION = require("../package.json").version;
commander_1.program
    .name("jelly-server")
    .version(VERSION)
    .addHelpText("before", "Copyright (C) 2024 Anders MÃ¸ller\n")
    .option("-f, --logfile <file>", "log file (default: $TMP/jelly-PID.log)")
    .option("-l, --loglevel <level>", "analysis log level (info/warn/error)", "error")
    .option("-r, --loglevel-server <level>", "server log level (verbose/info/error)", "info")
    .action(main)
    .showHelpAfterError()
    .parse();
async function main() {
    (0, options_1.setOptions)(commander_1.program.opts());
    options_1.options.logfile ??= `${(0, os_1.tmpdir)()}/jelly-${process.pid}.log`;
    (0, logger_1.logToFile)(options_1.options.logfile);
    if (options_1.options.loglevel === "debug" || options_1.options.loglevel === "verbose")
        options_1.options.loglevel = "info";
    (0, logger_1.setLogLevel)(options_1.options.loglevel);
    const logger = winston_1.default.createLogger({
        level: options_1.options.loglevelServer,
        format: winston_1.default.format.combine(winston_1.default.format.timestamp(), winston_1.default.format.printf(({ level, message, timestamp }) => `${timestamp} [${level}]: ${message}`)),
        transports: new winston_1.default.transports.File({
            filename: options_1.options.logfile
        })
    });
    logger.info(`Starting server, analysis log level: ${options_1.options.loglevel}, server log level: ${options_1.options.loglevelServer}`);
    const rl = readline.createInterface({
        input: process.stdin,
        output: process.stdout,
        terminal: false
    });
    rl.on("line", async (input) => {
        const trimmed = input.trim();
        if (logger.isVerboseEnabled())
            logger.verbose(`Message received: ${trimmed}`);
        try {
            const message = JSON.parse(trimmed);
            if (message.type === "request") {
                const req = message;
                const handler = requestHandlers[req.command];
                if (handler) {
                    try {
                        const res = await handler(req);
                        if (res)
                            sendResponse(res);
                    }
                    catch (err) {
                        sendErrorResponse(err?.message, req);
                    }
                }
                else
                    sendErrorResponse(`Unrecognized command: ${req.command}`, req);
            }
            else
                sendErrorResponse(`Unexpected message type: ${message.type}`);
        }
        catch (err) {
            sendErrorResponse("Unable to parse request");
        }
    });
    rl.on("close", () => {
        logger.info("Connection closed, shutting down");
        process.exit(0);
    });
    process.on("SIGINT", () => {
        logger.info("Received SIGINT, shutting down");
        process.exit(0);
    });
    let seq = 1;
    function prepareResponse(success, req, extra = {}) {
        return {
            type: "response",
            seq: seq++,
            command: req?.command,
            request_seq: req?.seq,
            success,
            message: extra.message,
            body: extra.body
        };
    }
    function sendResponse(res) {
        const str = JSON.stringify(res);
        process.stdout.write(`Content-Length: ${str.length}\r\n\r\n`);
        process.stdout.write(str);
        process.stdout.write("\r\n");
        if (logger.isVerboseEnabled())
            logger.verbose(`Message sent: ${JSON.stringify(res, undefined, 2)}`);
    }
    function sendErrorResponse(message, req) {
        logger.error(message);
        sendResponse(prepareResponse(false, req, { message }));
    }
    let analyzing = false;
    let aborting = false;
    let files;
    let solver;
    let typer;
    let tapirPatterns;
    let patterns;
    let globs;
    let props;
    let vulnerabilityDetector;
    function clearAnalysisData() {
        files = solver = typer = tapirPatterns = patterns = globs = props = undefined;
        if (typeof gc === "function")
            gc();
    }
    const requestHandlers = {
        exit: async () => {
            logger.info("Received exit command, shutting down");
            process.exit(0);
        },
        options: async (req) => {
            (0, options_1.setOptions)(req.arguments);
            (0, logger_1.setLogLevel)(options_1.options.loglevel);
            if (options_1.options.vulnerabilities) {
                logger.info(`Loading vulnerability patterns from ${options_1.options.vulnerabilities}`);
                vulnerabilityDetector = new vulnerabilitydetector_1.VulnerabilityDetector(JSON.parse((0, fs_1.readFileSync)(options_1.options.vulnerabilities, "utf8")));
            }
            logger.info("Options set");
            return prepareResponse(true, req);
        },
        expandpaths: async (req) => {
            try {
                const body = (0, files_1.expand)(req.arguments);
                const res = prepareResponse(true, req, { body });
                logger.info("Expanded paths");
                return res;
            }
            catch (e) {
                return prepareResponse(false, req, { message: `Error: ${e instanceof Error ? e.message : "Unable to expand paths"}` });
            }
        },
        files: async (req) => {
            if (analyzing)
                return prepareResponse(false, req, { message: "Analysis in progress" });
            files = req.arguments;
            (0, files_1.autoDetectBaseDir)(files);
            logger.info("Files selected");
            return prepareResponse(true, req);
        },
        analyze: async (req) => {
            if (!files)
                return prepareResponse(false, req, { message: "Files have not been selected" });
            if (analyzing)
                return prepareResponse(false, req, { message: "Analysis already in progress" });
            solver = undefined;
            let gs, ps;
            if (globs || vulnerabilityDetector) {
                gs = new Set();
                (0, util_1.addAll)(globs, gs);
                ps = new Set();
                (0, util_1.addAll)(props, ps);
                if (vulnerabilityDetector) {
                    const qs = vulnerabilityDetector.getPatterns();
                    (0, util_1.addAll)((0, patternloader_1.getGlobs)(qs), gs);
                    (0, util_1.addAll)((0, patternloader_1.getProperties)(qs), ps);
                }
            }
            (0, options_1.setDefaultTrackedModules)(gs);
            (0, options_1.setPatternProperties)(options_1.options.apiUsage ? undefined : (ps || new Set));
            analyzing = true;
            aborting = false;
            logger.info("Starting analysis");
            try {
                solver = new solver_1.default(() => aborting);
                await (0, analyzer_1.analyzeFiles)(files, solver);
                logger.info(`Analysis completed${solver.diagnostics.aborted ? " (aborted)" : solver.diagnostics.timeout ? " (timeout)" : ""}`);
                return prepareResponse(true, req);
            }
            catch (ex) {
                logger.info("Analysis terminated unsuccessfully");
                if (ex instanceof solver_1.AbortedException)
                    return prepareResponse(false, req, { message: "Analysis was aborted" });
                throw ex;
            }
            finally {
                analyzing = aborting = false;
            }
        },
        abort: async (req) => {
            if (!analyzing)
                return prepareResponse(false, req, { message: "Analysis not currently running" });
            logger.info("Aborting analysis");
            aborting = true;
            return prepareResponse(true, req);
        },
        clear: async (req) => {
            if (analyzing)
                return prepareResponse(false, req, { message: "Analysis in progress" });
            clearAnalysisData();
            logger.info("Analysis data cleared");
            return prepareResponse(true, req);
        },
        reset: async (req) => {
            if (analyzing)
                return prepareResponse(false, req, { message: "Analysis in progress" });
            clearAnalysisData();
            (0, options_1.resetOptions)();
            logger.info("Reset completed");
            return prepareResponse(true, req);
        },
        typescript: async (req) => {
            if (!files)
                return prepareResponse(false, req, { message: "No files selected" });
            typer = new typeinferrer_1.TypeScriptTypeInferrer(files);
            logger.info("TypeScript parsing done");
            return prepareResponse(true, req);
        },
        diagnostics: async (req) => {
            if (!solver)
                return prepareResponse(false, req, { message: "Analysis results not available" });
            solver.updateDiagnostics();
            const res = prepareResponse(true, req, { body: solver.diagnostics });
            logger.info("Sending analysis diagnostics");
            return res;
        },
        apiusage: async (req) => {
            if (!solver || analyzing)
                return prepareResponse(false, req, { message: "Analysis results not available" });
            if (!options_1.options.apiUsage)
                return prepareResponse(false, req, { message: "API usage not enabled, must be enabled before analyze" });
            const [r1] = (0, apiusage_1.getAPIUsage)(solver.fragmentState);
            const body = (0, apiusage_1.convertAPIUsageToJSON)(r1);
            const res = prepareResponse(true, req, { body });
            logger.info("Sending API usage");
            return res;
        },
        patternfiles: async (req) => {
            if (analyzing)
                return prepareResponse(false, req, { message: "Analysis in progress" });
            tapirPatterns = (0, patternloader_1.removeObsoletePatterns)((0, patternloader_1.loadTapirDetectionPatternFiles)(req.arguments));
            patterns = (0, patternloader_1.convertTapirPatterns)(tapirPatterns);
            globs = (0, patternloader_1.getGlobs)(patterns);
            props = (0, patternloader_1.getProperties)(patterns);
            logger.info("Patterns loaded from files");
            return prepareResponse(true, req);
        },
        patterns: async (req) => {
            if (analyzing)
                return prepareResponse(false, req, { message: "Analysis in progress" });
            tapirPatterns = (0, patternloader_1.removeObsoletePatterns)(req.arguments);
            patterns = (0, patternloader_1.convertTapirPatterns)(tapirPatterns);
            globs = (0, patternloader_1.getGlobs)(patterns);
            props = (0, patternloader_1.getProperties)(patterns);
            logger.info("Patterns loaded");
            return prepareResponse(true, req);
        },
        patternmatch: async (req) => {
            if (!solver || analyzing)
                return prepareResponse(false, req, { message: "Analysis results not available" });
            if (!tapirPatterns || !patterns)
                return prepareResponse(false, req, { message: "Patterns have not been loaded" });
            const matcher = new patternmatcher_1.PatternMatcher(solver.fragmentState, typer);
            const body = (0, patternmatcher_1.convertPatternMatchesToJSON)(patterns, matcher);
            const res = prepareResponse(true, req, { body });
            logger.info("Sending pattern matching results");
            return res;
        },
        callgraph: async (req) => {
            if (!solver || !files)
                return prepareResponse(false, req, { message: "Analysis results not available" });
            const res = prepareResponse(true, req, { body: new analysisstatereporter_1.AnalysisStateReporter(solver.fragmentState).callGraphToJSON(files) });
            logger.info("Sending call graph");
            return res;
        },
        htmlcallgraph: async (req) => {
            if (!solver || !files)
                return prepareResponse(false, req, { message: "Analysis results not available" });
            if (!options_1.options.callgraphHtml)
                return prepareResponse(false, req, { message: "Option callgraphHtml not set" });
            const vr = {};
            if (vulnerabilityDetector && options_1.options.vulnerabilities) {
                const f = solver.fragmentState;
                vr.package = vulnerabilityDetector.findPackagesThatMayDependOnVulnerablePackages(f);
                vr.module = vulnerabilityDetector.findModulesThatMayDependOnVulnerableModules(f);
                vr.function = vulnerabilityDetector.findFunctionsThatMayReachVulnerableFunctions(f);
                vr.call = vulnerabilityDetector.findCallsThatMayReachVulnerableFunctions(f, vr.function);
                vr.matches = vulnerabilityDetector.patternMatch(f, typer, solver.diagnostics);
            }
            (0, visualizer_1.exportCallGraphHtml)(solver.fragmentState, options_1.options.callgraphHtml, vr);
            logger.info("Call graph HTML file generated");
            return prepareResponse(true, req);
        },
        htmldataflowgraph: async (req) => {
            if (!solver || !files)
                return prepareResponse(false, req, { message: "Analysis results not available" });
            if (!options_1.options.dataflowHtml)
                return prepareResponse(false, req, { message: "Option dataflowHtml not set" });
            (0, visualizer_1.exportDataFlowGraphHtml)(solver.fragmentState, options_1.options.dataflowHtml);
            logger.info("Data-flow graph HTML file generated");
            return prepareResponse(true, req);
        },
        tslibraryusage: async (req) => {
            if (!typer)
                return prepareResponse(false, req, { message: "TypeScript parsing result not available" });
            const res = prepareResponse(true, req, { body: typer.libraryUsageToJSON(typer.getLibraryUsage()) });
            logger.info("Sending TypeScript library usage");
            return res;
        },
        reachablepackages: async (req) => {
            if (!solver)
                return prepareResponse(false, req, { message: "Analysis results not available" });
            const packages = [];
            for (const p of solver.globalState.packageInfos.values())
                packages.push({
                    name: p.name,
                    version: p.version
                });
            const res = prepareResponse(true, req, { body: packages });
            logger.info("Sending reachable packages");
            return res;
        },
    };
}
//# sourceMappingURL=server.js.map