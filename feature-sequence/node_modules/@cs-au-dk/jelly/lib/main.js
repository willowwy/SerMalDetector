#!/usr/bin/env node
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const analyzer_1 = require("./analysis/analyzer");
const fs_1 = require("fs");
const commander_1 = require("commander");
const logger_1 = __importStar(require("./misc/logger"));
const options_1 = require("./options");
const child_process_1 = require("child_process");
const path_1 = __importDefault(require("path"));
const files_1 = require("./misc/files");
const tapirpatterns_1 = require("./patternmatching/tapirpatterns");
const graphviz_1 = require("./output/graphviz");
const analysisstatereporter_1 = require("./output/analysisstatereporter");
const typeinferrer_1 = require("./typescript/typeinferrer");
const apiusage_1 = require("./patternmatching/apiusage");
const patternloader_1 = require("./patternmatching/patternloader");
const compare_1 = require("./output/compare");
const memory_1 = require("./misc/memory");
const solver_1 = __importDefault(require("./analysis/solver"));
const visualizer_1 = require("./output/visualizer");
const vulnerabilitydetector_1 = require("./patternmatching/vulnerabilitydetector");
const util_1 = require("./misc/util");
const apiexported_1 = require("./patternmatching/apiexported");
const merge_1 = require("./output/merge");
commander_1.program
    .name("jelly")
    .version(options_1.VERSION)
    .addHelpText("before", "Copyright (C) 2023-2024 Anders MÃ¸ller & Oskar Haarklou Veileborg\n")
    .option("-b, --basedir <directory>", "base directory for files to analyze (default: auto-detect)")
    .option("-f, --logfile <file>", "log to file (default: log to stdout)")
    .option("-l, --loglevel <level>", "log level (debug/verbose/info/warn/error)", "info")
    .option("-i, --timeout <seconds>", "limit analysis time")
    .option("-a, --dataflow-html <file>", "save data-flow graph as HTML file")
    .option("-m, --callgraph-html <file>", "save call graph as HTML file")
    .option("-j, --callgraph-json <file>", "save call graph as JSON file")
    .option("-s, --soundness <file>", "compare with dynamic call graph")
    .option("-n, --graal-home <directory>", "home of graal-nodejs (default: $GRAAL_HOME)")
    .option("-d, --dynamic <file>", "generate call graph dynamically, no static analysis")
    .option("-p, --patterns <file...>", "files containing API usage patterns to detect")
    .option("-v, --vulnerabilities <file>", "report vulnerability matches")
    .option("--include-packages <package...>", "include only dependencies in this list")
    .option("--exclude-packages <package...>", "exclude dependencies in this list")
    .option("--ignore-dependencies", "don't include dependencies in analysis")
    .option("--ignore-unresolved", "don't report errors about unresolved modules")
    .option("--npm-test <dir>", "run 'npm test' instead of 'node' (use with -d)")
    .option("--callgraph", "report call graph")
    .option("--tokens-json <file>", "save tokens for constraint variables as JSON file")
    .option("--tokens", "report tokens for constraint variables")
    .option("--largest", "report largest token sets and subset relations")
    .option("--no-cycle-elimination", "disable cycle elimination")
    .option("--no-natives", "disable nonessential models of native libraries")
    .option("--skip-graal-test", "skip graal-nodejs test (use with -d)")
    .option("--no-print-progress", "don't print analysis progress information")
    .option("--no-tty", "don't print solver progress for TTY")
    .option("--warnings-unsupported", "print warnings about unsupported features")
    .option("--gc", "enable garbage collection for more accurate memory usage reporting")
    .option("--typescript", "enable TypeScript type inference (use with -p)")
    .option("--api-usage", "report API usage of external packages (implies --ignore-dependencies)")
    .option("--api-exported", "report API of modules")
    .option("--find-access-paths <location>", "find access paths for source location (file:line)")
    .option("--higher-order-functions", "report higher-order functions")
    .option("--zeros", "report calls with zero callees and functions with zero callers")
    .option("--exclude-entries <glob...>", "files to exclude when specifying entry directories")
    .option("--tracked-modules <glob...>", "modules to track usage of (default: empty unless using -p, -v or --api-usage)")
    .option("--external-matches", "enable pattern matches from external code")
    .option("--no-callgraph-implicit", "omit implicit calls in call graph")
    .option("--no-callgraph-native", "omit native calls in call graph")
    .option("--no-callgraph-require", "omit module loading in call graph")
    .option("--no-callgraph-external", "omit heuristic external callbacks in call graph")
    .option("--diagnostics", "report internal analysis diagnostics")
    .option("--diagnostics-json <file>", "save analysis diagnostics in JSON file")
    .option("--variable-kinds", "report constraint variable kinds")
    .option("--max-rounds <number>", "limit number of fixpoint rounds for each module and package")
    .option("--typescript-library-usage <file>", "save TypeScript library usage in JSON file, no analysis")
    .option("--modules-only", "report reachable packages and modules only, no analysis")
    .option("--compare-callgraphs", "compare two call graphs given as JSON files, no analysis")
    .option("--reachability", "compare reachability as an additional call graph comparison metric (use with -s or --compare-callgraphs)")
    .option("--assume-in-node-modules", "treat analyzed files as in node_modules")
    .option("--no-alloc", "disable allocation site abstraction")
    .option("--oldobj", "old object abstraction")
    .option("--widening", "enable object widening")
    .option("--patch-dynamics", "enable dynamic property access patching heuristic")
    .option("--patch-method-calls", "enable method call patching heuristic")
    .option("--read-neighbors", "enable package neighbor heuristic")
    .option("--proto", "model assignments to the __proto__ property")
    .option("--obj-spread", "model spread syntax for object literals ({...obj})")
    .usage("[options] [files]")
    .addHelpText("after", "\nAll modules reachable by require/import from the given files are included in the analysis\n" +
    "(except when using --ignore-dependencies, --include-packages or --exclude-packages).\n" +
    "If specifying directories instead of files, the files in the directories and their\n" +
    "subdirectories are used as entry points.\n" +
    "The special argument -- indicates end of options, typically after multi-argument options.\n" +
    `Memory limit is ${(0, memory_1.getMemoryLimit)()}MB.${options_1.PKG ? "" : " Change with, for example: NODE_OPTIONS=--max-old-space-size=8192"}`)
    .action(main)
    .showHelpAfterError()
    .parse();
async function main() {
    options_1.options.tty = true;
    (0, options_1.setOptions)(commander_1.program.opts());
    if (options_1.options.logfile)
        (0, logger_1.logToFile)(options_1.options.logfile);
    (0, logger_1.setLogLevel)(options_1.options.loglevel);
    if (options_1.PKG)
        for (const opt of ["dynamic"])
            if (options_1.options[opt]) {
                logger_1.default.error(`Error: Option --${opt} not available in binary executable`);
                process.exitCode = -1;
                return;
            }
    if (options_1.options.compareCallgraphs) {
        if (commander_1.program.args.length !== 2) {
            logger_1.default.error("Error: Option --compare-callgraphs expects two files");
            process.exitCode = -1;
            return;
        }
        (0, compare_1.compareCallGraphs)(commander_1.program.args[0], commander_1.program.args[1], undefined, true, options_1.options.reachability);
        return;
    }
    if (options_1.options.patterns && options_1.options.vulnerabilities) {
        logger_1.default.error("Error: Options --patterns and --vulnerabilities cannot be used together");
        process.exitCode = -1;
        return;
    }
    if (options_1.options.gc && typeof gc !== "function") {
        const args = process.argv.slice(1);
        args.unshift("--expose-gc");
        const t = (0, child_process_1.spawnSync)(process.execPath, args, { stdio: "inherit" });
        if (t.status === null) {
            logger_1.default.error("Error: Unable to restart with --expose-gc");
            process.exitCode = -1;
        }
        else
            process.exitCode = t.status;
        return;
    }
    if (options_1.options.dynamic) {
        const graalHome = options_1.options.graalHome || process.env.GRAAL_HOME;
        const node = graalHome ? path_1.default.resolve(graalHome, "bin/node") : "node";
        if (!options_1.options.skipGraalTest) {
            logger_1.default.info("Testing graal-nodejs");
            const t = (0, child_process_1.spawnSync)(node, ["-e", "process.exit(typeof Graal === 'object' ? 0 : -1)"]);
            if (t.status === null) {
                logger_1.default.error(`Error: Unable to execute ${node}`);
                process.exitCode = -1;
                return;
            }
            if (t.status !== 0) {
                logger_1.default.error("Error: 'node' is not graal-nodejs, try option --graal-home or environment variable GRAAL_HOME");
                process.exitCode = -1;
                return;
            }
        }
        logger_1.default.info("Generating dynamic call graph");
        let cmd, args, cwd, env = {};
        if (options_1.options.npmTest) {
            cmd = "npm";
            args = ["test", ...commander_1.program.args];
            cwd = path_1.default.resolve(options_1.options.npmTest);
            env = { NODE_ENV: "test" };
        }
        else {
            if (commander_1.program.args.length === 0) {
                logger_1.default.info("File missing, aborting");
                return;
            }
            const file = path_1.default.resolve(commander_1.program.args[0]);
            cwd = options_1.options.basedir ? path_1.default.resolve(options_1.options.basedir) : path_1.default.dirname(file);
            cmd = `${__dirname}/../bin/node`;
            args = [path_1.default.relative(cwd, file)].concat(commander_1.program.args.slice(1));
        }
        const dyn = path_1.default.resolve(options_1.options.dynamic);
        const t = (0, child_process_1.spawnSync)(cmd, args, {
            stdio: "inherit",
            cwd,
            env: {
                ...process.env,
                ...env,
                JELLY_OUT: dyn,
                GRAAL_HOME: graalHome ? path_1.default.resolve(graalHome) : undefined,
                PATH: `${__dirname}/../bin${path_1.default.delimiter}${process.env.PATH}`,
            },
        });
        if (t.status === null) {
            logger_1.default.error(`Error: Unable to execute ${cmd}`);
            process.exitCode = -1;
            return;
        }
        const dir = path_1.default.dirname(dyn);
        const cgs = [];
        for (const f of (0, fs_1.readdirSync)(dir, { withFileTypes: true }))
            if (f.isFile()) {
                const p = path_1.default.resolve(dir, f.name);
                if (p.startsWith(`${dyn}-`)) {
                    cgs.push(JSON.parse((0, fs_1.readFileSync)(p, "utf-8")));
                    (0, fs_1.unlinkSync)(p);
                }
            }
        logger_1.default.verbose(`Collected ${cgs.length} call graphs from instrumented execution`);
        const fd = (0, fs_1.openSync)(dyn, "w");
        (0, files_1.writeStreamedStringify)((0, merge_1.merge)(cgs), fd);
        (0, fs_1.closeSync)(fd);
        logger_1.default.info(`Dynamic call graph written to ${dyn}`);
    }
    else {
        if (commander_1.program.args.length === 0) {
            logger_1.default.info("No files to analyze (use --help to see usage)");
            return;
        }
        if (!(0, files_1.autoDetectBaseDir)(commander_1.program.args))
            return;
        let files;
        try {
            files = (0, files_1.expand)(commander_1.program.args);
        }
        catch (e) {
            logger_1.default.info(`Error: ${e instanceof Error ? "code" in e && e.code === "ENOENT" && "path" in e ? `File not found ${e.path}` : e.message : "Unable to expand paths"}`);
            return;
        }
        if (logger_1.default.isVerboseEnabled()) {
            logger_1.default.verbose("Entry files:");
            for (const file of files)
                logger_1.default.verbose(`  ${file}`);
        }
        if (options_1.options.typescriptLibraryUsage) {
            const ts = new typeinferrer_1.TypeScriptTypeInferrer(files);
            const fd = (0, fs_1.openSync)(options_1.options.typescriptLibraryUsage, "w");
            (0, files_1.writeStreamedStringify)(ts.libraryUsageToJSON(ts.getLibraryUsage()), fd);
            (0, fs_1.closeSync)(fd);
            logger_1.default.info(`TypeScript library usage written to ${options_1.options.typescriptLibraryUsage}`);
        }
        else {
            let tapirPatterns, patterns, globs, props, vulnerabilityDetector;
            if (options_1.options.patterns) {
                tapirPatterns = (0, patternloader_1.removeObsoletePatterns)((0, patternloader_1.loadTapirDetectionPatternFiles)(options_1.options.patterns));
                patterns = (0, patternloader_1.convertTapirPatterns)(tapirPatterns);
                globs = (0, patternloader_1.getGlobs)(patterns);
                props = (0, patternloader_1.getProperties)(patterns);
            }
            if (options_1.options.vulnerabilities) {
                logger_1.default.info(`Loading vulnerability patterns from ${options_1.options.vulnerabilities}`);
                vulnerabilityDetector = new vulnerabilitydetector_1.VulnerabilityDetector(JSON.parse((0, fs_1.readFileSync)(options_1.options.vulnerabilities, "utf8")));
                const ps = vulnerabilityDetector.getPatterns();
                (0, util_1.addAll)((0, patternloader_1.getGlobs)(ps), (globs = (globs ?? new Set())));
                (0, util_1.addAll)((0, patternloader_1.getProperties)(ps), (props = (props ?? new Set())));
            }
            (0, options_1.setDefaultTrackedModules)(globs);
            (0, options_1.setPatternProperties)(options_1.options.apiUsage ? undefined : (props || new Set()));
            const solver = new solver_1.default();
            const a = solver.globalState;
            a.vulnerabilities = vulnerabilityDetector;
            await (0, analyzer_1.analyzeFiles)(files, solver);
            const f = solver.fragmentState;
            const out = new analysisstatereporter_1.AnalysisStateReporter(f);
            let typer;
            if (options_1.options.typescript)
                typer = new typeinferrer_1.TypeScriptTypeInferrer(files);
            const vr = {};
            if (vulnerabilityDetector) {
                vr.package = vulnerabilityDetector.findPackagesThatMayDependOnVulnerablePackages(f);
                vr.module = vulnerabilityDetector.findModulesThatMayDependOnVulnerableModules(f);
                vr.function = vulnerabilityDetector.findFunctionsThatMayReachVulnerableFunctions(f);
                vr.call = vulnerabilityDetector.findCallsThatMayReachVulnerableFunctions(f, vr.function);
                vulnerabilityDetector.reportResults(f, vr);
                vr.matches = vulnerabilityDetector.patternMatch(f, typer, solver.diagnostics);
            }
            if (options_1.options.callgraphHtml) {
                const file = options_1.options.callgraphHtml;
                (0, visualizer_1.exportCallGraphHtml)(f, file, vr);
                logger_1.default.info(`Call graph written to ${file}`);
            }
            if (options_1.options.dataflowHtml) {
                const file = options_1.options.dataflowHtml;
                (0, visualizer_1.exportDataFlowGraphHtml)(f, file);
                logger_1.default.info(`Data-flow graph written to ${file}`);
            }
            if (options_1.options.callgraphGraphviz) {
                const file = options_1.options.callgraphGraphviz;
                const fd = (0, fs_1.openSync)(file, "w");
                (0, graphviz_1.toDot)(f, fd);
                (0, fs_1.closeSync)(fd);
                logger_1.default.info(`Call graph written to ${file}`);
            }
            if (options_1.options.callgraph)
                out.reportCallGraph();
            if (options_1.options.tokens)
                out.reportTokens();
            if (options_1.options.tokensJson)
                out.saveTokens(options_1.options.tokensJson);
            if (options_1.options.largest) {
                out.reportLargestSubsetEdges();
                out.reportLargestTokenSets();
            }
            if (options_1.options.callgraphJson)
                out.saveCallGraph(options_1.options.callgraphJson, files);
            if (options_1.options.diagnosticsJson)
                out.saveDiagnostics(solver.diagnostics, options_1.options.diagnosticsJson);
            if (options_1.options.modulesOnly)
                out.reportReachablePackagesAndModules();
            if (options_1.options.soundness)
                (0, compare_1.compareCallGraphs)(options_1.options.soundness, "<computed>", out.callGraphToJSON(files), false, options_1.options.reachability);
            if (tapirPatterns && patterns)
                (0, tapirpatterns_1.tapirPatternMatch)(tapirPatterns, patterns, solver, typer, undefined);
            if (options_1.options.apiUsage) {
                const [r1, r2] = (0, apiusage_1.getAPIUsage)(f);
                (0, apiusage_1.reportAPIUsage)(r1, r2);
            }
            if (options_1.options.apiExported || options_1.options.findAccessPaths) {
                const r = (0, apiexported_1.getAPIExported)(f);
                if (options_1.options.apiExported)
                    (0, apiexported_1.reportAPIExportedFunctions)(r);
                if (options_1.options.findAccessPaths)
                    (0, apiexported_1.reportAccessPaths)(f, r, options_1.options.findAccessPaths);
            }
            if (options_1.options.higherOrderFunctions)
                out.reportHigherOrderFunctions();
            if (options_1.options.zeros) {
                const funs = out.getZeroCallerFunctions();
                out.reportZeroCallerFunctions(funs);
                const calls = out.getZeroCalleeCalls();
                out.reportZeroCalleeCalls(calls);
            }
            if (options_1.options.variableKinds)
                out.reportVariableKinds();
        }
    }
}
//# sourceMappingURL=main.js.map