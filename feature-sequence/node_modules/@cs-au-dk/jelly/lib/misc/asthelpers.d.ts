import { NodePath } from "@babel/traverse";
import { CallExpression, Class, ClassAccessorProperty, ClassMethod, ClassPrivateMethod, ClassPrivateProperty, ClassProperty, Expression, Identifier, ImportDefaultSpecifier, ImportSpecifier, JSXMemberExpression, MemberExpression, NewExpression, ObjectMethod, ObjectProperty, OptionalCallExpression, OptionalMemberExpression, Property, StringLiteral } from "@babel/types";
import { CallNodePath } from "../natives/nativebuilder";
import { FragmentState } from "../analysis/fragmentstate";
export declare function getProperty(node: MemberExpression | OptionalMemberExpression | JSXMemberExpression): string | undefined;
export declare function getKey(node: ObjectProperty | ClassProperty | ClassAccessorProperty | ClassPrivateProperty | ObjectMethod | ClassMethod | ClassPrivateMethod): string | undefined;
export declare function isParentExpressionStatement(path: NodePath): boolean;
export declare function isCalleeExpression(path: NodePath): boolean;
export declare function getBaseAndProperty(path: CallNodePath): {
    base: Expression;
    property: string | undefined;
} | undefined;
export declare function getExportName(exported: Identifier | StringLiteral): string;
export declare function getImportName(imp: ImportSpecifier | ImportDefaultSpecifier): string;
export declare function getClass(path: NodePath<any>): Class | undefined;
export declare function getAdjustedCallNodePath(path: CallNodePath): NodePath;
export declare function isMaybeUsedAsPromise(path: NodePath<CallExpression | OptionalCallExpression | NewExpression>): boolean;
export declare function isInTryBlockOrBranch(path: NodePath): boolean;
export declare function registerArtificialClassPropertyInitializer(f: FragmentState, path: NodePath<Property>): void;
