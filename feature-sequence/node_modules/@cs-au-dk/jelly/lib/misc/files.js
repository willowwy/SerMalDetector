"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.writeStreamedStringify = exports.codeFromLocation = exports.autoDetectBaseDir = exports.requireResolve = exports.expand = void 0;
const fs_1 = require("fs");
const path_1 = require("path");
const module_1 = __importDefault(require("module"));
const options_1 = require("../options");
const micromatch_1 = __importDefault(require("micromatch"));
const util_1 = require("./util");
const logger_1 = __importDefault(require("./logger"));
const packagejson_1 = require("./packagejson");
const stringify2stream_1 = __importDefault(require("stringify2stream"));
function expand(paths) {
    if (typeof paths === "string")
        paths = [paths];
    const res = [];
    for (const path of paths)
        for (const e of expandRec((0, path_1.resolve)(path), false))
            res.push(e);
    if (options_1.options.excludeEntries) {
        const excl = new Set((0, micromatch_1.default)(res, options_1.options.excludeEntries));
        const eres = [];
        for (const r of res)
            if (!excl.has(r))
                eres.push(r);
        return eres;
    }
    else
        return res;
}
exports.expand = expand;
function* expandRec(path, sub) {
    const stat = (0, fs_1.lstatSync)(path);
    const inNodeModules = options_1.options.assumeInNodeModules || path.includes("node_modules");
    if (stat.isDirectory()) {
        const base = (0, path_1.basename)(path);
        if (!sub ||
            !(["node_modules", ".git", ".yarn"].includes(base) ||
                (!inNodeModules && ["out", "build", "dist", "generated"].includes(base)))) {
            const files = (0, fs_1.readdirSync)(path);
            if (!sub || inNodeModules || !files.includes("package.json"))
                for (const file of files.map(f => (0, path_1.resolve)(path, f)).sort((f1, f2) => {
                    return ((0, fs_1.lstatSync)(f1).isDirectory() ? 1 : 0) - ((0, fs_1.lstatSync)(f2).isDirectory() ? 1 : 0) || f1.localeCompare(f2);
                }))
                    yield* expandRec(file, true);
            else
                logger_1.default.debug(`Skipping directory ${path}`);
        }
        else
            logger_1.default.debug(`Skipping directory ${path}`);
    }
    else if (stat.isFile() && !path.endsWith(".d.ts") &&
        (!inNodeModules || !(path.endsWith(".min.js") || path.endsWith(".bundle.js"))) &&
        (path.endsWith(".js") || path.endsWith(".jsx") || path.endsWith(".es") || path.endsWith(".mjs") || path.endsWith(".cjs") || path.endsWith(".ts") || path.endsWith(".tsx") || path.endsWith(".mts") || path.endsWith(".cts")
            || isShebang(path)))
        yield (0, path_1.relative)(options_1.options.basedir, path);
    else
        logger_1.default.debug(`Skipping file ${path}`);
}
function isShebang(path) {
    const fd = (0, fs_1.openSync)(path, 'r');
    const buf = Buffer.alloc(256);
    (0, fs_1.readSync)(fd, buf, 0, buf.length, 0);
    (0, fs_1.closeSync)(fd);
    const str = buf.toString('utf8');
    return str.startsWith("#!") && str.substring(0, str.indexOf("\n")).includes("node");
}
function requireResolve(str, file, node, f) {
    if (str.endsWith(".json")) {
        logger_1.default.debug(`Skipping JSON file '${str}'`);
        return undefined;
    }
    else if (str.endsWith(".node")) {
        logger_1.default.debug(`Skipping binary addon file '${str}'`);
        return undefined;
    }
    else if (str.endsWith(".less") || str.endsWith(".svg") || str.endsWith(".png") || str.endsWith(".css") || str.endsWith(".scss")) {
        logger_1.default.verbose(`Ignoring module '${str}' with special extension`);
        return undefined;
    }
    else if (str[0] === "/") {
        f.error(`Ignoring absolute module path '${str}'`, node);
        return undefined;
    }
    let filepath;
    try {
        filepath = f.a.tsModuleResolver.resolveModuleName(str, file);
        if (file.endsWith(".js") && filepath.endsWith(".ts") && !str.endsWith(".ts")) {
            const p = filepath.substring(0, filepath.length - 3) + ".js";
            if ((0, fs_1.existsSync)(p))
                filepath = p;
        }
    }
    catch (e) {
        logger_1.default.debug(`Could not resolve module '${str}' required from ${file} with TS compiler`);
        try {
            filepath = module_1.default.createRequire(file).resolve(str);
        }
        catch { }
        if (!filepath)
            for (const p of f.a.packageInfos.values())
                if (p.name === str)
                    if (filepath) {
                        f.error(`Multiple packages named ${str} found, skipping module load`, node);
                        throw e;
                    }
                    else {
                        filepath = (0, path_1.resolve)(p.dir, p.main || "index.js");
                        if (!(0, fs_1.existsSync)(filepath))
                            filepath = undefined;
                    }
        if (!filepath)
            throw e;
    }
    if (!filepath.startsWith(options_1.options.basedir)) {
        const msg = `Found module at ${filepath}, but not in basedir`;
        logger_1.default.debug(msg);
        throw new Error(msg);
    }
    if (filepath.endsWith(".d.ts") || ![".js", ".jsx", ".es", ".mjs", ".cjs", ".ts", ".tsx", ".mts", ".cts"].includes((0, path_1.extname)(filepath))) {
        f.warn(`Module '${filepath}' has unrecognized extension, skipping it`, node);
        return undefined;
    }
    if (logger_1.default.isDebugEnabled())
        logger_1.default.debug(`Module '${str}' required from ${file} resolved to: ${filepath}`);
    return filepath;
}
exports.requireResolve = requireResolve;
function autoDetectBaseDir(paths) {
    if (options_1.options.basedir) {
        const stat = (0, fs_1.lstatSync)(options_1.options.basedir);
        if (!stat.isDirectory()) {
            logger_1.default.info(`Error: basedir ${options_1.options.basedir} is not a directory, aborting`);
            return false;
        }
        return true;
    }
    if (paths.length === 0)
        return true;
    if (paths.length > 1) {
        logger_1.default.info("Can't auto-detect basedir (use option -b), aborting");
        return false;
    }
    if (!(0, fs_1.existsSync)(paths[0])) {
        logger_1.default.info(`File or directory ${paths[0]} not found, aborting`);
        return false;
    }
    const t = (0, packagejson_1.findPackageJson)(paths[0]);
    if (!t) {
        logger_1.default.info("Can't auto-detect basedir, package.json not found (use option -b), aborting");
        return false;
    }
    options_1.options.basedir = (0, path_1.resolve)(process.cwd(), t.dir);
    logger_1.default.verbose(`Basedir auto-detected: ${options_1.options.basedir}`);
    return true;
}
exports.autoDetectBaseDir = autoDetectBaseDir;
const codeCache = new Map();
function codeFromLocation(loc) {
    if (!loc)
        return "-";
    const locStr = (0, util_1.locationToStringWithFileAndEnd)(loc, true);
    let content = codeCache.get(locStr);
    if (!content) {
        content = "";
        if (loc && loc.module) {
            const fileContent = (0, fs_1.readFileSync)(loc.module.getPath()).toString().split(/\r?\n/);
            let startRecord = false;
            for (let i = loc.start.line; i <= loc.end.line; i++) {
                const currLine = fileContent[i - 1];
                for (let j = 0; j < currLine.length; j++) {
                    if (i === loc.start.line && loc.start.column === j)
                        startRecord = true;
                    if (i === loc.end.line && j === loc.end.column) {
                        startRecord = false;
                        break;
                    }
                    if (startRecord)
                        content += currLine.charAt(j);
                }
            }
            content = content.replaceAll(/\s+/g, " ");
            if (content.length > 50)
                content = `${content.substring(0, 20)}...$${content.substring(content.length - 20)}`;
        }
        codeCache.set(locStr, content);
    }
    return content;
}
exports.codeFromLocation = codeFromLocation;
function writeStreamedStringify(value, fd, replacer, space) {
    (0, stringify2stream_1.default)(value, (chunk) => {
        if (chunk)
            (0, fs_1.writeSync)(fd, chunk);
    }, replacer, space);
}
exports.writeStreamedStringify = writeStreamedStringify;
//# sourceMappingURL=files.js.map