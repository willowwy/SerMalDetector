"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.registerArtificialClassPropertyInitializer = exports.isInTryBlockOrBranch = exports.isMaybeUsedAsPromise = exports.getAdjustedCallNodePath = exports.getClass = exports.getImportName = exports.getExportName = exports.getBaseAndProperty = exports.isCalleeExpression = exports.isParentExpressionStatement = exports.getKey = exports.getProperty = void 0;
const types_1 = require("@babel/types");
const assert_1 = __importDefault(require("assert"));
function getProperty(node) {
    if ((0, types_1.isJSXMemberExpression)(node))
        return node.property.name;
    else if ((0, types_1.isIdentifier)(node.property) && !node.computed)
        return node.property.name;
    else if ((0, types_1.isStringLiteral)(node.property))
        return node.property.value;
    else if ((0, types_1.isNumericLiteral)(node.property))
        return node.property.value.toString();
    else if ((0, types_1.isPrivateName)(node.property))
        return `#${node.property.id.name}`;
    return undefined;
}
exports.getProperty = getProperty;
function getKey(node) {
    if ((0, types_1.isClassPrivateProperty)(node) || (0, types_1.isClassPrivateMethod)(node))
        return `#${node.key.id.name}`;
    else if ((0, types_1.isIdentifier)(node.key) && !node.computed)
        return node.key.name;
    else if ((0, types_1.isStringLiteral)(node.key))
        return node.key.value;
    else if ((0, types_1.isNumericLiteral)(node.key))
        return node.key.value.toString();
    return undefined;
}
exports.getKey = getKey;
function isParentExpressionStatement(path) {
    let p = path;
    do {
        p = p.parentPath;
    } while (p && (0, types_1.isParenthesizedExpression)(p.node));
    return p !== null && (0, types_1.isExpressionStatement)(p.node);
}
exports.isParentExpressionStatement = isParentExpressionStatement;
function isCallNodePath(path, opts) {
    return path.isCallExpression(opts) || path.isOptionalCallExpression(opts) || path.isNewExpression(opts);
}
function isCalleeExpression(path) {
    const parent = path.parentPath;
    if (parent?.isParenthesizedExpression())
        return isCalleeExpression(parent);
    return parent !== null && isCallNodePath(parent, { callee: path.node });
}
exports.isCalleeExpression = isCalleeExpression;
function getBaseAndProperty(path) {
    let p = path.get("callee");
    while ((0, types_1.isParenthesizedExpression)(p.node))
        p = p.get("expression");
    if (!((0, types_1.isMemberExpression)(p.node) || (0, types_1.isOptionalMemberExpression)(p.node)))
        return undefined;
    const base = p.node.object;
    if (!(0, types_1.isExpression)(base))
        return undefined;
    const property = getProperty(p.node);
    return { base, property };
}
exports.getBaseAndProperty = getBaseAndProperty;
function getExportName(exported) {
    return (0, types_1.isIdentifier)(exported) ? exported.name : exported.value;
}
exports.getExportName = getExportName;
function getImportName(imp) {
    return (0, types_1.isImportSpecifier)(imp) ? (0, types_1.isIdentifier)(imp.imported) ? imp.imported.name : imp.imported.value : "default";
}
exports.getImportName = getImportName;
function getClass(path) {
    return path.find((p) => p.isClass())?.node;
}
exports.getClass = getClass;
function getAdjustedCallNodePath(path) {
    return (0, types_1.isParenthesizedExpression)(path.parentPath.node) &&
        ((0, types_1.isNewExpression)(path.node) ||
            (!(0, types_1.isParenthesizedExpression)(path.node.callee) && !(0, types_1.isFunctionExpression)(path.node.callee))) ?
        path.parentPath : path;
}
exports.getAdjustedCallNodePath = getAdjustedCallNodePath;
function isMaybeUsedAsPromise(path) {
    return !(0, types_1.isExpressionStatement)(path.node) &&
        !((0, types_1.isCallExpression)(path.parent) && path.parent.callee === path.node) &&
        !((0, types_1.isMemberExpression)(path.parent) &&
            (0, types_1.isIdentifier)(path.parent.property) &&
            !['then', 'catch'].includes(path.parent.property.name));
}
exports.isMaybeUsedAsPromise = isMaybeUsedAsPromise;
function isInTryBlockOrBranch(path) {
    let p = path;
    do {
        p = p.parentPath;
        if (p) {
            if (p.isFunction())
                return false;
            if (p.isTryStatement() || p.isIfStatement() || p.isSwitchCase() || p.isConditionalExpression())
                return true;
        }
    } while (p);
    return false;
}
exports.isInTryBlockOrBranch = isInTryBlockOrBranch;
function registerArtificialClassPropertyInitializer(f, path) {
    if (!path.isClassProperty() && !path.isClassPrivateProperty())
        return;
    let sl;
    if (path.isClassPrivateProperty() || !path.node.computed)
        sl = path.node.key.loc;
    else if (!path.node.static)
        sl = path.node.loc;
    else {
        const tokens = path.hub.
            file.ast.tokens;
        const keyStart = path.node.key.start;
        (0, assert_1.default)(tokens && typeof keyStart === "number");
        let lo = 0;
        for (let hi = tokens.length; lo < hi;) {
            const mid = (lo + hi) >>> 1;
            if (tokens[mid].start >= keyStart)
                hi = mid;
            else
                lo = mid + 1;
        }
        (0, assert_1.default)(lo >= 1 && tokens[lo].start === keyStart && tokens[lo - 1].type.label === "[");
        sl = tokens[lo - 1].loc;
    }
    const m = path.node.loc.module;
    (0, assert_1.default)(m);
    f.registerArtificialFunction(m, sl);
}
exports.registerArtificialClassPropertyInitializer = registerArtificialClassPropertyInitializer;
//# sourceMappingURL=asthelpers.js.map