"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.mapCallsToFunctions = exports.SourceLocationsToJSON = exports.percent = exports.isArrayIndex = exports.strHash = exports.getMapHybridSetSize = exports.addAllMapHybridSet = exports.addMapHybridSet = exports.deleteMapSetAll = exports.deleteAll = exports.mapArrayAdd = exports.setAll = exports.addAll = exports.mapMapMapSetAll = exports.mapMapSetAll = exports.mapArrayPushAll = exports.mapSetAddAll = exports.mapMapSize = exports.getOrSet = exports.mapGetArray = exports.mapGetSet = exports.mapGetMap = exports.locationIn = exports.locationContains = exports.locationToStringWithFileAndEnd = exports.locationToStringWithFile = exports.locationToString = exports.nodeToString = exports.ternaryToString = exports.ternaryOr = exports.Ternary = void 0;
const types_1 = require("@babel/types");
const assert_1 = __importDefault(require("assert"));
const logger_1 = __importDefault(require("./logger"));
var Ternary;
(function (Ternary) {
    Ternary[Ternary["True"] = 1] = "True";
    Ternary[Ternary["False"] = 0] = "False";
    Ternary[Ternary["Maybe"] = -1] = "Maybe";
})(Ternary || (exports.Ternary = Ternary = {}));
function ternaryOr(t1, t2) {
    return t1 === Ternary.True || t2 === Ternary.True ? Ternary.True :
        t1 === Ternary.Maybe || t2 === Ternary.Maybe ? Ternary.Maybe :
            Ternary.False;
}
exports.ternaryOr = ternaryOr;
function ternaryToString(t) {
    switch (t) {
        case Ternary.True:
            return "true";
        case Ternary.False:
            return "false";
        case Ternary.Maybe:
            return "maybe";
    }
}
exports.ternaryToString = ternaryToString;
function nodeToString(n) {
    if ((0, types_1.isIdentifier)(n))
        return `'${n.name}'[${locationToStringWithFile(n.loc, true)}]`;
    else
        return `[${locationToStringWithFileAndEnd(n.loc, true)}]`;
}
exports.nodeToString = nodeToString;
function locationToString(loc, withFilename = false, withEnd = false, useModuleName) {
    if (!loc)
        return "?";
    const file = withFilename ?
        useModuleName ?
            "module" in loc ? loc.module?.toString() : "" :
            "filename" in loc ? loc.filename : "?" :
        "";
    const start = loc.start && loc.start.line !== 0 ? `${loc.start.line}:${loc.start.column + 1}` : "";
    const end = withEnd && loc.end && loc.end.line !== 0 ? `:${loc.end.line}:${loc.end.column + 1}` : "";
    const extra = "nodeIndex" in loc ? `$${loc.nodeIndex}` : "";
    const native = loc.native ?? "";
    return file + (file && start ? ":" : "") + start + end + extra + native;
}
exports.locationToString = locationToString;
function locationToStringWithFile(loc, useModuleName) {
    return locationToString(loc, true, false, useModuleName);
}
exports.locationToStringWithFile = locationToStringWithFile;
function locationToStringWithFileAndEnd(loc, useModuleName) {
    return locationToString(loc, true, true, useModuleName);
}
exports.locationToStringWithFileAndEnd = locationToStringWithFileAndEnd;
function locationContains(loc, file, line) {
    return Boolean(loc && loc.start && loc.end && "module" in loc && loc.module && loc.module.getPath() === file && loc.start.line <= line && line <= loc.end.line);
}
exports.locationContains = locationContains;
function locationIn(loc1, loc2) {
    if (!loc2)
        return false;
    const start = loc2.start.line < loc1.start.line ||
        (loc2.start.line === loc1.start.line && loc2.start.column <= loc1.start.column);
    const end = loc1.end.line < loc2.end.line ||
        (loc1.end.line === loc2.end.line && loc1.end.column <= loc2.end.column);
    return start && end;
}
exports.locationIn = locationIn;
function mapGetMap(m, k) {
    let mt = m.get(k);
    if (!mt) {
        mt = new Map();
        m.set(k, mt);
    }
    return mt;
}
exports.mapGetMap = mapGetMap;
function mapGetSet(m, k) {
    let mt = m.get(k);
    if (!mt) {
        mt = new Set;
        m.set(k, mt);
    }
    return mt;
}
exports.mapGetSet = mapGetSet;
function mapGetArray(m, k) {
    let mt = m.get(k);
    if (!mt) {
        mt = [];
        m.set(k, mt);
    }
    return mt;
}
exports.mapGetArray = mapGetArray;
function getOrSet(m, k, v) {
    let r = m.get(k);
    if (r === undefined) {
        r = v();
        m.set(k, r);
    }
    return r;
}
exports.getOrSet = getOrSet;
function mapMapSize(m) {
    let c = 0;
    for (const n of m.values())
        c += n.size;
    return c;
}
exports.mapMapSize = mapMapSize;
function mapSetAddAll(from, to) {
    for (const [k, vs] of from)
        addAll(vs, mapGetSet(to, k));
}
exports.mapSetAddAll = mapSetAddAll;
function mapArrayPushAll(from, to) {
    for (const [k, vs] of from)
        mapGetArray(to, k).push(...vs);
}
exports.mapArrayPushAll = mapArrayPushAll;
function mapMapSetAll(from, to) {
    for (const [k, m] of from)
        setAll(m, mapGetMap(to, k));
}
exports.mapMapSetAll = mapMapSetAll;
function mapMapMapSetAll(from, to) {
    for (const [k, m] of from)
        mapMapSetAll(m, mapGetMap(to, k));
}
exports.mapMapMapSetAll = mapMapMapSetAll;
function addAll(from, to) {
    if (!from)
        return 0;
    const before = to.size;
    for (const x of from)
        to.add(x);
    return to.size - before;
}
exports.addAll = addAll;
function setAll(from, to) {
    for (const [k, v] of from)
        to.set(k, v);
}
exports.setAll = setAll;
function mapArrayAdd(k, v, m) {
    let a = m.get(k);
    if (!a) {
        a = [];
        m.set(k, a);
    }
    a.push(v);
}
exports.mapArrayAdd = mapArrayAdd;
function deleteAll(xs, s) {
    for (const x of xs)
        s.delete(x);
}
exports.deleteAll = deleteAll;
function deleteMapSetAll(m, k, vs) {
    const s = m.get(k);
    if (s) {
        deleteAll(vs.values(), s);
        if (s.size === 0)
            m.delete(k);
    }
}
exports.deleteMapSetAll = deleteMapSetAll;
function addMapHybridSet(k, v, to) {
    const s = to.get(k);
    let added = false;
    if (s) {
        if (s instanceof Set) {
            if (!s.has(v)) {
                s.add(v);
                added = true;
            }
        }
        else if (s !== v) {
            to.set(k, new Set([s, v]));
            added = true;
        }
    }
    else {
        to.set(k, v);
        added = true;
    }
    return added;
}
exports.addMapHybridSet = addMapHybridSet;
function addAllMapHybridSet(from, to) {
    for (const [k, v] of from)
        if (v instanceof Set)
            for (const t of v)
                addMapHybridSet(k, t, to);
        else
            addMapHybridSet(k, v, to);
}
exports.addAllMapHybridSet = addAllMapHybridSet;
function getMapHybridSetSize(m) {
    let c = 0;
    for (const v of m.values())
        if (v instanceof Set)
            c += v.size;
        else
            c++;
    return c;
}
exports.getMapHybridSetSize = getMapHybridSetSize;
function strHash(s) {
    let h1 = 0, h2 = 0x41c6ce570;
    for (let i = 0, ch; i < s.length; i++) {
        ch = s.charCodeAt(i);
        h1 = Math.imul(h1 ^ ch, 2654435761);
        h2 = Math.imul(h2 ^ ch, 1597334677);
    }
    h1 = Math.imul(h1 ^ (h1 >>> 16), 2246822507);
    h1 ^= Math.imul(h2 ^ (h2 >>> 13), 3266489909);
    h2 = Math.imul(h2 ^ (h2 >>> 16), 2246822507);
    h2 ^= Math.imul(h1 ^ (h1 >>> 13), 3266489909);
    return 4294967296 * (2097151 & h2) + (h1 >>> 0);
}
exports.strHash = strHash;
function isArrayIndex(prop) {
    return Number.isSafeInteger(parseFloat(prop)) && parseInt(prop) >= 0;
}
exports.isArrayIndex = isArrayIndex;
function percent(x) {
    return `${(100 * x).toFixed(2)}%`;
}
exports.percent = percent;
class SourceLocationsToJSON {
    fileIndex = new Map();
    files;
    constructor(files) {
        this.files = files;
    }
    getFileIndex(file) {
        let n = this.fileIndex.get(file);
        if (n === undefined) {
            n = this.files.length;
            this.fileIndex.set(file, n);
            this.files.push(file);
        }
        return n;
    }
    makeLocString(loc) {
        (0, assert_1.default)(loc && ("module" in loc && loc.module || "filename" in loc && loc.filename));
        return `${this.getFileIndex(loc.module ? loc.module.getPath() : loc.filename)}:${loc.start.line}:${loc.start.column + 1}:${loc.end.line}:${loc.end.column + 1}`;
    }
    parseLocationJSON(loc) {
        const [_, _fileIndex, startLine, startCol, endLine, endCol] = /^(\d+):(\d+|\?):(\d+|\?):(\d+|\?):(\d+|\?)/.exec(loc);
        const fileIndex = Number(_fileIndex);
        (0, assert_1.default)(fileIndex < this.files.length);
        if (startLine === "?") {
            (0, assert_1.default)(startCol === "?" && endLine === "?" && endCol === "?");
            return {
                fileIndex,
                file: this.files[fileIndex],
            };
        }
        return {
            loc: {
                start: { line: Number(startLine), column: Number(startCol) - 1 },
                end: { line: Number(endLine), column: Number(endCol) - 1 },
            },
            fileIndex,
            file: this.files[fileIndex],
        };
    }
}
exports.SourceLocationsToJSON = SourceLocationsToJSON;
function mapCallsToFunctions(cg) {
    const parser = new SourceLocationsToJSON(cg.files);
    const ret = new Map();
    const byFile = Array.from(cg.files, () => ({ functions: [], calls: [] }));
    for (const kind of ["functions", "calls"])
        for (const [i, loc] of Object.entries(cg[kind])) {
            const parsed = parser.parseLocationJSON(loc);
            if (!parsed.loc)
                continue;
            byFile[parsed.fileIndex][kind].push({ ...parsed.loc, index: Number(i) });
        }
    function compareLC(a, b) {
        return a.line !== b.line ? a.line - b.line : a.column - b.column;
    }
    function compareSL(a, b) {
        return compareLC(a.start, b.start) || -compareLC(a.end, b.end) || a.index - b.index;
    }
    for (const [i, { functions, calls }] of byFile.entries()) {
        if (functions.length === 0) {
            logger_1.default.error(`Call graph contains file ${cg.files[i]} without functions`);
            continue;
        }
        functions.sort(compareSL);
        calls.sort(compareSL);
        let synthModFun = functions[0];
        if (synthModFun.start.line !== 1 || synthModFun.start.column !== 0) {
            const funs = functions.map(f => parser.makeLocString({ ...f, filename: cg.files[i] })).join("\n\t");
            logger_1.default.warn(`No synthetic module function for file ${cg.files[i]}\nFunctions:\n\t${funs}`);
            synthModFun = undefined;
        }
        const stack = [];
        let funIndex = 0;
        for (const call of calls) {
            if (synthModFun && !locationIn(call, synthModFun)) {
                const cs = parser.makeLocString({ ...call, filename: cg.files[i] });
                const fs = parser.makeLocString({ ...synthModFun, filename: cg.files[i] });
                logger_1.default.error(`Call ${cs} is outside module function (${fs})`);
                continue;
            }
            while (stack.length && compareLC(stack[stack.length - 1].end, call.start) <= 0)
                stack.pop();
            while (funIndex < functions.length) {
                const fun = functions[funIndex], cmp = compareLC(fun.start, call.start);
                if (cmp < 0 || (cmp === 0 && fun.start.line === 1 && fun.start.column === 0)) {
                    funIndex++;
                    if (compareLC(fun.end, call.start) > 0)
                        stack.push(fun);
                }
                else
                    break;
            }
            if (stack.length === 0) {
                logger_1.default.error(`No function surrounding call ${parser.makeLocString({ ...call, filename: cg.files[i] })}!`);
                continue;
            }
            const fun = stack[stack.length - 1];
            if (!locationIn(call, fun)) {
                const cs = parser.makeLocString({ ...call, filename: cg.files[i] }), fs = parser.makeLocString({ ...fun, filename: cg.files[i] });
                logger_1.default.error(`Error: ${cs} should be in ${fs}`);
            }
            ret.set(call.index, fun.index);
        }
    }
    return ret;
}
exports.mapCallsToFunctions = mapCallsToFunctions;
//# sourceMappingURL=util.js.map