"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.isInExports = exports.getPackageJsonInfo = exports.findPackageJson = void 0;
const path_1 = require("path");
const fs_1 = require("fs");
const logger_1 = __importDefault(require("./logger"));
const options_1 = require("../options");
function findPackageJson(file) {
    let dir = file;
    while (true) {
        if (doesDirContainPackageJsonForNpmPackage(dir))
            return { packageJson: (0, path_1.resolve)(dir, "package.json"), dir };
        const d = (0, path_1.dirname)(dir);
        if (d === dir || (options_1.options.basedir && !d.startsWith(options_1.options.basedir)))
            return undefined;
        dir = d;
    }
}
exports.findPackageJson = findPackageJson;
function doesDirContainPackageJsonForNpmPackage(dir) {
    const packageJson = (0, path_1.resolve)(dir, "package.json");
    if (!(0, fs_1.existsSync)(packageJson))
        return false;
    const nodeModulesDirString = `node_modules${path_1.sep}`;
    const lastIndexOfNodeModules = dir.lastIndexOf(nodeModulesDirString);
    if (lastIndexOfNodeModules === -1)
        return true;
    const lastNodeModulesPath = dir.substring(0, lastIndexOfNodeModules + nodeModulesDirString.length);
    const expectedNameOfPackage = (0, path_1.relative)(lastNodeModulesPath, dir);
    return parsePackageJson(packageJson).name === expectedNameOfPackage;
}
function parsePackageJson(packageJson) {
    return JSON.parse((0, fs_1.readFileSync)(packageJson, { encoding: "utf8" }));
}
function getPackageJsonInfo(tofile) {
    let packagekey, name, version, main, dir, exports;
    const p = findPackageJson(tofile);
    let f;
    if (p) {
        try {
            f = parsePackageJson(p.packageJson);
        }
        catch {
            logger_1.default.warn(`Unable to parse ${p.packageJson}`);
        }
    }
    if (p && f) {
        dir = p.dir;
        if (!f.name)
            logger_1.default.verbose(`Package name missing in ${p.packageJson}`);
        name = f.name || "<anonymous>";
        if (!f.version)
            logger_1.default.verbose(`Package version missing in ${p.packageJson}`);
        version = f.version;
        packagekey = `${name}@${version ?? "?"}`;
        if (f.main) {
            try {
                main = (0, path_1.relative)(dir, require.resolve("./".includes(f.main[0]) ? f.main : "./" + f.main, { paths: [dir] }));
            }
            catch {
                logger_1.default.verbose(`Unable to locate package main file '${f.main}' at ${dir}`);
                main = undefined;
            }
        }
        if (f.exports) {
            exports = [];
            const queue = [f.exports];
            while (queue.length > 0) {
                const exp = queue.pop();
                if (typeof exp === "string") {
                    if (exp.startsWith("./"))
                        exports.push(exp !== "./" && exp.endsWith("/") ? exp + "*" : exp);
                    else {
                        exports = undefined;
                        logger_1.default.warn(`Non-relative export (${exp}) found in package.json`);
                        break;
                    }
                }
                else if (Array.isArray(exp))
                    queue.push(...exp);
                else if (exp === null)
                    logger_1.default.warn("Warning: unsupported negative exports pattern found in package.json");
                else if (typeof exp === "object")
                    queue.push(...Object.values(exp));
                else {
                    exports = undefined;
                    logger_1.default.warn(`Invalid export (${exp}) found in package.json`);
                    break;
                }
            }
        }
    }
    else {
        name = "<main>";
        packagekey = "<unknown>";
        dir = process.cwd();
    }
    return { packagekey, name, version, main, dir, exports };
}
exports.getPackageJsonInfo = getPackageJsonInfo;
function isInExports(rel, exports) {
    for (const path of exports)
        if (path.includes("*")) {
            if (new RegExp(`^${path.replace(/\*/g, ".*")}$`).test(rel))
                return true;
        }
        else if (path === rel)
            return true;
    return false;
}
exports.isInExports = isInExports;
//# sourceMappingURL=packagejson.js.map