"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.toMatchAnalysisResults = void 0;
const assert_1 = __importDefault(require("assert"));
const jest_diff_1 = require("jest-diff");
const pretty_format_1 = require("pretty-format");
const expect_utils_1 = require("@jest/expect-utils");
const util_1 = require("../misc/util");
const infos_1 = require("../analysis/infos");
const solver_1 = __importDefault(require("../analysis/solver"));
const globalstate_1 = require("../analysis/globalstate");
const fragmentstate_1 = require("../analysis/fragmentstate");
const operations_1 = require("../analysis/operations");
const analysisstatereporter_1 = require("../output/analysisstatereporter");
const types_1 = require("@babel/types");
const scc_1 = require("../misc/scc");
const setPlugin = {
    test(x) { return x instanceof Set; },
    serialize(set, config, indentation, depth, refs, printer) {
        return `Set (size ${set.size}) ${printer([...set].sort(), config, indentation, depth, refs)}`;
    },
};
const mapPlugin = {
    test(x) { return x instanceof Map; },
    serialize(map, config, indentation, depth, refs, printer) {
        return `Map (size ${map.size}) ${printer([...map.entries()].sort(), config, indentation, depth, refs)}`;
    },
};
function filterFields(test, exclude) {
    const narrow = (o) => Object.assign(Object.create(Object.getPrototypeOf(o)), Object.fromEntries(Object.entries(o).filter(([key]) => !exclude(key))));
    return {
        test: (x) => test(x) && Object.keys(x).some(exclude),
        serialize(x, config, indentation, depth, refs, printer) {
            return printer(narrow(x), config, indentation, depth, refs);
        },
        equal(a, b, customTesters) {
            const aOK = test(a), bOK = test(b);
            if (aOK && bOK) {
                const an = narrow(a), bn = narrow(b);
                return Object.keys(an).length == Object.keys(bn).length &&
                    Object.entries(an).every(([key, value]) => key in bn && (this.equals(value, bn[key], customTesters, true)));
            }
            else if (aOK === bOK)
                return undefined;
            else
                return false;
        },
    };
}
const excludeFields = (fields) => (field) => fields.includes(field);
const isSL = (x) => Boolean(x && typeof x === "object" && "line" in x && "column" in x);
function isLocation(x) {
    return Boolean(x && typeof x === "object" && "start" in x && "end" in x && isSL(x.start) && isSL(x.end));
}
const locationPlugin = filterFields(isLocation, excludeFields(["filename", "identifierName"]));
const positionPlugin = filterFields(isSL, excludeFields(["index"]));
const nodePlugin = {
    test: types_1.isNode,
    serialize(x) {
        return (0, util_1.locationToStringWithFileAndEnd)(x.loc, true);
    },
    equal(a, b) {
        const aOK = (0, types_1.isNode)(a), bOK = (0, types_1.isNode)(b);
        if (aOK && bOK)
            return this.serialize(a) === this.serialize(b);
        else if (aOK === bOK)
            return undefined;
        return false;
    },
};
const singletonsPlugin = {
    singletons: [
        globalstate_1.GlobalState.prototype, fragmentstate_1.FragmentState.prototype, solver_1.default.prototype,
        infos_1.ModuleInfo.prototype, operations_1.Operations.prototype,
    ],
    sindex(x) {
        return x && typeof x === "object" ? this.singletons.indexOf(Object.getPrototypeOf(x)) : -1;
    },
    test(x) {
        return this.sindex(x) !== -1;
    },
    serialize(x) {
        const proto = Object.getPrototypeOf(x);
        if (Object.hasOwn(proto, "toString"))
            return x.toString();
        return x.constructor.name;
    },
    equal(a, b) {
        const ai = this.sindex(a), bi = this.sindex(b);
        if (ai !== -1 && ai === bi) {
            if (Object.hasOwn(this.singletons[ai], "toString")) {
                const toString = this.singletons[ai].toString;
                return toString.call(a) === toString.call(b);
            }
            return true;
        }
        else if (ai === -1 && bi === -1)
            return undefined;
        else
            return false;
    },
};
const equalPlugins = [
    locationPlugin.equal, nodePlugin.equal.bind(nodePlugin), positionPlugin.equal,
    singletonsPlugin.equal.bind(singletonsPlugin),
    expect_utils_1.iterableEquality,
];
function trydiff(expected, actual, { expand }) {
    const plugins = [
        singletonsPlugin,
        locationPlugin, positionPlugin,
        nodePlugin,
        setPlugin, mapPlugin,
    ];
    const a = (0, pretty_format_1.format)(expected, { plugins, indent: 0 });
    const b = (0, pretty_format_1.format)(actual, { plugins, indent: 0 });
    return a === b ? undefined
        : (0, jest_diff_1.diffLinesUnified2)((0, pretty_format_1.format)(expected, { plugins }).split("\n"), (0, pretty_format_1.format)(actual, { plugins }).split("\n"), a.split("\n"), b.split("\n"), { expand });
}
const toMatchAnalysisResults = function (_actual, expected) {
    let actual;
    if (_actual instanceof solver_1.default)
        actual = _actual.fragmentState;
    else if (_actual instanceof fragmentstate_1.FragmentState)
        actual = _actual;
    else
        throw new Error("Actual value must be a solver or fragment state instance!");
    if (expected instanceof solver_1.default)
        expected = expected.fragmentState;
    const getComps = (f) => {
        const [_, repmap] = (0, scc_1.nuutila)(f.vars.keys(), (v) => f.subsetEdges.get(v));
        const grep = (v) => {
            const rep = repmap.get(f.getRepresentative(v));
            (0, assert_1.default)(rep);
            return rep;
        };
        const comps = new Map();
        for (const v of f.vars) {
            const rep = grep(v);
            const c = (0, util_1.getOrSet)(comps, rep, () => ({ comp: [], tokens: [...f.getTokens(v)].map(t => t.toString()).sort() }));
            c.comp.push(v);
            if (v !== rep) {
                const aTokens = new Set(f.getTokens(v)), bTokens = new Set(f.getTokens(rep));
                assert_1.default.equal(aTokens.size, bTokens.size);
                for (const t of aTokens)
                    (0, assert_1.default)(bTokens.has(t));
            }
        }
        for (const v of f.redirections.keys())
            comps.get(grep(v)).comp.push(v);
        for (const c of comps.values())
            c.comp.sort();
        return { comps, grep };
    };
    const aComps = getComps(actual), eComps = getComps(expected);
    for (const [header, get] of [
        ["Modules", f => f.a.moduleInfos],
        ["Functions", f => {
                const m = new Map([...f.a.functionInfos]
                    .map(([f, info]) => [(0, util_1.locationToStringWithFileAndEnd)(f.loc, true), info.toString()]));
                assert_1.default.equal(m.size, f.a.functionInfos.size);
                return m;
            }],
        ["Function edges", f => {
                const m = new Map([...f.functionToFunction]
                    .map(([src, targets]) => [src.toString(), [...targets].map(t => t.toString()).sort()]));
                assert_1.default.equal(m.size, f.functionToFunction.size);
                return m;
            }],
        ["Require edges", f => f.requireGraph],
        ["Call locations", f => [...f.callLocations].map(node => (0, util_1.locationToStringWithFileAndEnd)(node.loc, true)).sort()],
        ["Call edges", f => {
                const m = new Map([...f.callToFunctionOrModule]
                    .map(([node, es]) => [(0, util_1.locationToStringWithFileAndEnd)(node.loc, true), [...es].map(t => t.toString()).sort()]));
                assert_1.default.equal(m.size, f.callToFunctionOrModule.size);
                return m;
            }],
        ["Zero caller functions", f => [...new analysisstatereporter_1.AnalysisStateReporter(f).getZeroCallerFunctions()].map(f => f.toString()).sort()],
        ["Object properties", f => {
                const m = new Map([...f.objectProperties].map(([t, props]) => [t.toString(), [...props].sort()]));
                assert_1.default.equal(m.size, f.objectProperties.size);
                return m;
            }],
        ["Widened objects", f => [...f.widened].map(t => t.toString()).sort()],
        ["ConstraintVar components", f => {
                const { comps } = f === actual ? aComps : eComps;
                const m = new Map([...comps.values()].map(({ comp }) => [comp[0].toString(), comp.map(v => v.toString())]));
                assert_1.default.equal(m.size, comps.size);
                return m;
            }],
        ["Subset edges", f => {
                const { comps, grep } = f === actual ? aComps : eComps;
                const edges = new Set();
                for (const [src, targets] of f.subsetEdges) {
                    const sRep = grep(src);
                    for (const target of targets) {
                        const tRep = grep(target);
                        if (sRep !== tRep) {
                            const c1 = comps.get(sRep).comp, c2 = comps.get(tRep).comp;
                            edges.add(`${c1[0]} (${c1.length}) -> ${c2[0]} (${c2.length})`);
                        }
                    }
                }
                return [...edges].sort();
            }],
        ["Tokens", f => {
                const { comps } = f === actual ? aComps : eComps;
                return new Map([...comps.values()].map(({ comp, tokens }) => [comp[0].toString(), tokens]));
            }],
    ]) {
        const act = get(actual), exp = get(expected);
        if (!this.equals(act, exp, equalPlugins, true))
            return {
                pass: false,
                message: () => this.utils.matcherHint("toMatchAnalysisResults", undefined, undefined, { comment: "Analysis results equality" }) +
                    `\n\nDifference for ${header}:\n\n${trydiff(exp, act, this)}`,
            };
    }
    return {
        pass: true,
        message: () => this.utils.matcherHint("toMatchAnalysisResults", undefined, undefined, { comment: "Analysis results equality" }) +
            "Should not be equal!",
    };
};
exports.toMatchAnalysisResults = toMatchAnalysisResults;
expect.extend({ toMatchAnalysisResults: exports.toMatchAnalysisResults });
//# sourceMappingURL=compare.js.map