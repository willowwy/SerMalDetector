"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.hasEdge = exports.runTest = void 0;
const options_1 = require("../options");
const tapirpatterns_1 = require("../patternmatching/tapirpatterns");
const analyzer_1 = require("../analysis/analyzer");
const assert_1 = __importDefault(require("assert"));
const globals_1 = require("@jest/globals");
const analysisstatereporter_1 = require("../output/analysisstatereporter");
const solver_1 = __importDefault(require("../analysis/solver"));
const apiusage_1 = require("../patternmatching/apiusage");
const compare_1 = require("../output/compare");
const vulnerabilitydetector_1 = require("../patternmatching/vulnerabilitydetector");
const patternloader_1 = require("../patternmatching/patternloader");
const logger_1 = __importDefault(require("../misc/logger"));
require("./compare");
function runTest(basedir, app, args) {
    const files = Array.isArray(app) ? app : [app];
    describe(files[0].replace(/\..*/, ""), () => {
        let tapirPatterns, detectionPatterns;
        let vulnerabilityDetector;
        const solver = new solver_1.default();
        beforeAll(async () => {
            (0, options_1.resetOptions)();
            logger_1.default.transports[0].level = options_1.options.loglevel = "error";
            Object.assign(options_1.options, args.options ?? {});
            options_1.options.basedir = basedir;
            options_1.options.patterns = args.patterns;
            options_1.options.soundness = args.soundness;
            if (args.patterns)
                [tapirPatterns, detectionPatterns] = (0, tapirpatterns_1.tapirLoadPatterns)(args.patterns);
            if (args.apiUsageAccessPathPatternsAtNodes !== undefined) {
                options_1.options.apiUsage = options_1.options.ignoreDependencies = true;
                options_1.options.trackedModules ??= ["**"];
            }
            if (args.vulnerabilities) {
                options_1.options.vulnerabilities = "someFile";
                vulnerabilityDetector = new vulnerabilitydetector_1.VulnerabilityDetector(args.vulnerabilities);
                const qs = vulnerabilityDetector.getPatterns();
                (0, options_1.setDefaultTrackedModules)((0, patternloader_1.getGlobs)(qs));
                (0, options_1.setPatternProperties)((0, patternloader_1.getProperties)(qs));
                solver.globalState.vulnerabilities = vulnerabilityDetector;
            }
            await (0, analyzer_1.analyzeFiles)(files, solver);
        });
        test("analysis facts", () => {
            if (args.functionInfos !== undefined)
                (0, globals_1.expect)(solver.globalState.functionInfos.size).toBe(args.functionInfos);
            if (args.moduleInfos !== undefined)
                (0, globals_1.expect)(solver.globalState.moduleInfos.size).toBe(args.moduleInfos);
            if (args.numberOfFunctionToFunctionEdges !== undefined)
                (0, globals_1.expect)(solver.fragmentState.numberOfFunctionToFunctionEdges).toBe(args.numberOfFunctionToFunctionEdges);
            if (args.oneCalleeCalls !== undefined)
                (0, globals_1.expect)(new analysisstatereporter_1.AnalysisStateReporter(solver.fragmentState).getOneCalleeCalls()).toBe(args.oneCalleeCalls);
        });
        test("merge regression", () => {
            const solver2 = new solver_1.default();
            solver2.globalState = solver.globalState;
            solver2.prepare();
            solver2.merge(solver.fragmentState, false);
            (0, globals_1.expect)(solver2).toMatchAnalysisResults(solver);
        });
        if (args.soundness)
            test("soundness", () => {
                const soundness = (0, compare_1.compareCallGraphs)(args.soundness, "<computed>", new analysisstatereporter_1.AnalysisStateReporter(solver.fragmentState).callGraphToJSON(files), false, true);
                if (args.funTotal !== undefined)
                    (0, globals_1.expect)(soundness.fun2funTotal).toBe(args.funTotal);
                if (args.callTotal !== undefined)
                    (0, globals_1.expect)(soundness.call2funTotal).toBe(args.callTotal);
                if (args.reachableTotal !== undefined)
                    (0, globals_1.expect)(soundness.reachableTotal).toBe(args.reachableTotal);
                (0, globals_1.expect)(soundness.fun2funFound).toBe(args.funFound ?? soundness.fun2funTotal);
                (0, globals_1.expect)(soundness.call2funFound).toBe(args.callFound ?? soundness.call2funTotal);
                (0, globals_1.expect)(soundness.reachableFound).toBe(args.reachableFound ?? soundness.reachableTotal);
            });
        if (args.matches)
            test("matches", () => {
                (0, assert_1.default)(args.matches && tapirPatterns !== undefined && detectionPatterns !== undefined);
                const { matches, matchesLow } = (0, tapirpatterns_1.tapirPatternMatch)(tapirPatterns, detectionPatterns, solver);
                (0, globals_1.expect)(matches).toBe(args.matches.total);
                if (args.matches.low !== undefined)
                    (0, globals_1.expect)(matchesLow).toBe(args.matches.low);
            });
        if (args.apiUsageAccessPathPatternsAtNodes !== undefined)
            test("API usage", () => {
                const [r1] = (0, apiusage_1.getAPIUsage)(solver.fragmentState);
                let numAccessPathPatternsAtNodes = 0;
                for (const m of Object.values(r1))
                    for (const ns of m.values())
                        numAccessPathPatternsAtNodes += ns.size;
                (0, globals_1.expect)(numAccessPathPatternsAtNodes).toBe(args.apiUsageAccessPathPatternsAtNodes);
            });
        if (args.vulnerabilitiesMatches !== undefined)
            test("vulnerabilities", () => {
                if (!vulnerabilityDetector)
                    throw new Error("vulnerabilitiesMatches can only be checked if vulnerabilities has been given.");
                const matches = vulnerabilityDetector.patternMatch(solver.fragmentState, undefined, solver.diagnostics);
                (0, globals_1.expect)(matches.size).toBe(args.vulnerabilitiesMatches);
            });
        if (options_1.options.cycleElimination)
            describe("cycle elimination regression", () => {
                test("data structure invariants", () => {
                    const check = (s) => {
                        for (const v of s.keys())
                            (0, assert_1.default)(f.isRepresentative(v));
                    };
                    const f = solver.fragmentState;
                    for (const [v] of f.getAllVarsAndTokens())
                        (0, assert_1.default)(f.isRepresentative(v));
                    for (const edges of [f.subsetEdges, f.reverseSubsetEdges])
                        for (const [v, es] of edges) {
                            (0, assert_1.default)(f.isRepresentative(v));
                            check(es);
                        }
                    check(f.tokenListeners);
                    for (const v of f.redirections.keys())
                        (0, assert_1.default)(!f.vars.has(v));
                });
                test("results equivalence", async () => {
                    try {
                        options_1.options.cycleElimination = false;
                        const solver2 = new solver_1.default();
                        await (0, analyzer_1.analyzeFiles)(files, solver2);
                        (0, globals_1.expect)(solver2).toMatchAnalysisResults(solver);
                    }
                    finally {
                        options_1.options.cycleElimination = true;
                    }
                });
            });
    });
}
exports.runTest = runTest;
function hasEdge(f, fromStr, toStr) {
    for (const [from, tos] of f.functionToFunction)
        for (const to of tos) {
            if (from.toString().includes(fromStr) && to.toString().includes(toStr))
                return true;
        }
    return false;
}
exports.hasEdge = hasEdge;
//# sourceMappingURL=runtest.js.map